
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Region
 * 
 */
export type Region = $Result.DefaultSelection<Prisma.$RegionPayload>
/**
 * Model POrC
 * 
 */
export type POrC = $Result.DefaultSelection<Prisma.$POrCPayload>
/**
 * Model COrM
 * 
 */
export type COrM = $Result.DefaultSelection<Prisma.$COrMPayload>
/**
 * Model Brgy
 * 
 */
export type Brgy = $Result.DefaultSelection<Prisma.$BrgyPayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model Facility
 * 
 */
export type Facility = $Result.DefaultSelection<Prisma.$FacilityPayload>
/**
 * Model Division
 * 
 */
export type Division = $Result.DefaultSelection<Prisma.$DivisionPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model AmbulanceService
 * 
 */
export type AmbulanceService = $Result.DefaultSelection<Prisma.$AmbulanceServicePayload>
/**
 * Model BloodTypeMapping
 * 
 */
export type BloodTypeMapping = $Result.DefaultSelection<Prisma.$BloodTypeMappingPayload>
/**
 * Model BloodBankService
 * 
 */
export type BloodBankService = $Result.DefaultSelection<Prisma.$BloodBankServicePayload>
/**
 * Model ERService
 * 
 */
export type ERService = $Result.DefaultSelection<Prisma.$ERServicePayload>
/**
 * Model ICUService
 * 
 */
export type ICUService = $Result.DefaultSelection<Prisma.$ICUServicePayload>
/**
 * Model OutpatientService
 * 
 */
export type OutpatientService = $Result.DefaultSelection<Prisma.$OutpatientServicePayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model UpdateLog
 * 
 */
export type UpdateLog = $Result.DefaultSelection<Prisma.$UpdateLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const FacilityType: {
  BARANGAY_HEALTH_CENTER: 'BARANGAY_HEALTH_CENTER',
  CLINIC: 'CLINIC',
  HEALTH_CENTER: 'HEALTH_CENTER',
  HOSPITAL: 'HOSPITAL',
  INFIRMARY: 'INFIRMARY',
  POLYCLINIC: 'POLYCLINIC',
  PRIMARY_CARE_CLINIC: 'PRIMARY_CARE_CLINIC',
  ALLERGY_CLINIC: 'ALLERGY_CLINIC',
  CARDIOLOGY_CLINIC: 'CARDIOLOGY_CLINIC',
  DENTAL_CLINIC: 'DENTAL_CLINIC',
  DERMATOLOGY_CLINIC: 'DERMATOLOGY_CLINIC',
  ENDOCRINOLOGY_CLINIC: 'ENDOCRINOLOGY_CLINIC',
  ENT_CLINIC: 'ENT_CLINIC',
  FERTILITY_CLINIC: 'FERTILITY_CLINIC',
  GASTROENTEROLOGY_CLINIC: 'GASTROENTEROLOGY_CLINIC',
  IMMUNOLOGY_CLINIC: 'IMMUNOLOGY_CLINIC',
  INFECTIOUS_DISEASE_CLINIC: 'INFECTIOUS_DISEASE_CLINIC',
  MATERNITY_CLINIC: 'MATERNITY_CLINIC',
  NEPHROLOGY_CLINIC: 'NEPHROLOGY_CLINIC',
  NEUROLOGY_CLINIC: 'NEUROLOGY_CLINIC',
  ONCOLOGY_CLINIC: 'ONCOLOGY_CLINIC',
  OPHTHALMOLOGY_CLINIC: 'OPHTHALMOLOGY_CLINIC',
  ORTHOPEDIC_CLINIC: 'ORTHOPEDIC_CLINIC',
  PEDIATRIC_CLINIC: 'PEDIATRIC_CLINIC',
  PULMONOLOGY_CLINIC: 'PULMONOLOGY_CLINIC',
  RHEUMATOLOGY_CLINIC: 'RHEUMATOLOGY_CLINIC',
  UROLOGY_CLINIC: 'UROLOGY_CLINIC',
  DIAGNOSTIC_LAB: 'DIAGNOSTIC_LAB',
  GENETIC_TESTING_LAB: 'GENETIC_TESTING_LAB',
  PATHOLOGY_LAB: 'PATHOLOGY_LAB',
  RADIOLOGY_CENTER: 'RADIOLOGY_CENTER',
  MICROBIOLOGY_LAB: 'MICROBIOLOGY_LAB',
  TOXICOLOGY_LAB: 'TOXICOLOGY_LAB',
  BURN_CENTER: 'BURN_CENTER',
  CRITICAL_CARE_CENTER: 'CRITICAL_CARE_CENTER',
  EMERGENCY_CENTER: 'EMERGENCY_CENTER',
  POISON_CONTROL_CENTER: 'POISON_CONTROL_CENTER',
  TRAUMA_CENTER: 'TRAUMA_CENTER',
  URGENT_CARE_CENTER: 'URGENT_CARE_CENTER',
  BLOOD_BANK: 'BLOOD_BANK',
  DIALYSIS_CENTER: 'DIALYSIS_CENTER',
  MENTAL_HEALTH_CENTER: 'MENTAL_HEALTH_CENTER',
  PAIN_MANAGEMENT_CENTER: 'PAIN_MANAGEMENT_CENTER',
  REHABILITATION_CENTER: 'REHABILITATION_CENTER',
  SLEEP_CENTER: 'SLEEP_CENTER',
  SUBSTANCE_ABUSE_CENTER: 'SUBSTANCE_ABUSE_CENTER',
  TRANSPLANT_CENTER: 'TRANSPLANT_CENTER',
  ALTERNATIVE_MEDICINE_CENTER: 'ALTERNATIVE_MEDICINE_CENTER',
  PHYSICAL_THERAPY_CENTER: 'PHYSICAL_THERAPY_CENTER',
  OCCUPATIONAL_THERAPY_CENTER: 'OCCUPATIONAL_THERAPY_CENTER',
  SPEECH_THERAPY_CENTER: 'SPEECH_THERAPY_CENTER',
  AMBULATORY_CARE_CENTER: 'AMBULATORY_CARE_CENTER',
  SURGICAL_CENTER: 'SURGICAL_CENTER',
  AMBULANCE_SERVICE: 'AMBULANCE_SERVICE'
};

export type FacilityType = (typeof FacilityType)[keyof typeof FacilityType]


export const Ownership: {
  PUBLIC: 'PUBLIC',
  PRIVATE: 'PRIVATE'
};

export type Ownership = (typeof Ownership)[keyof typeof Ownership]


export const Provider: {
  INTELLICARE: 'INTELLICARE',
  ASIACARE: 'ASIACARE',
  AVEGA: 'AVEGA',
  CAREWELL: 'CAREWELL',
  one_COOPHEALTH: 'one_COOPHEALTH',
  DYNAMIC_CARE_CORPORATION: 'DYNAMIC_CARE_CORPORATION',
  EASTWEST_HEALTHCARE: 'EASTWEST_HEALTHCARE',
  FORTICARE: 'FORTICARE',
  GETWELL: 'GETWELL',
  HC_and_D: 'HC_and_D',
  HEALTHFIRST: 'HEALTHFIRST',
  HMI: 'HMI',
  HPPI: 'HPPI',
  IWC: 'IWC',
  ICARE: 'ICARE',
  KAISER: 'KAISER',
  LIFE_and_HEALTH: 'LIFE_and_HEALTH',
  MAXICARE: 'MAXICARE',
  MEDICARD: 'MEDICARD',
  MEDICARE: 'MEDICARE',
  MEDOCARE: 'MEDOCARE',
  METROCARE: 'METROCARE',
  OMHSI: 'OMHSI',
  PACIFIC_CROSS: 'PACIFIC_CROSS',
  PHILHEALTH: 'PHILHEALTH',
  VALUCARE: 'VALUCARE',
  WELLCARE: 'WELLCARE'
};

export type Provider = (typeof Provider)[keyof typeof Provider]


export const Role: {
  MANAGER: 'MANAGER',
  ADMIN: 'ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Availability: {
  AVAILABLE: 'AVAILABLE',
  SHORT_DELAY: 'SHORT_DELAY',
  MODERATE_DELAY: 'MODERATE_DELAY',
  EXTENDED_DELAY: 'EXTENDED_DELAY',
  UNAVAILABLE: 'UNAVAILABLE'
};

export type Availability = (typeof Availability)[keyof typeof Availability]


export const Load: {
  STEADY: 'STEADY',
  MODERATE: 'MODERATE',
  CROWDED: 'CROWDED',
  NEAR_CAPACITY: 'NEAR_CAPACITY',
  FULL_CAPACITY: 'FULL_CAPACITY',
  CLOSED: 'CLOSED'
};

export type Load = (typeof Load)[keyof typeof Load]


export const ContactType: {
  PHONE: 'PHONE',
  EMAIL: 'EMAIL'
};

export type ContactType = (typeof ContactType)[keyof typeof ContactType]


export const Action: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE'
};

export type Action = (typeof Action)[keyof typeof Action]

}

export type FacilityType = $Enums.FacilityType

export const FacilityType: typeof $Enums.FacilityType

export type Ownership = $Enums.Ownership

export const Ownership: typeof $Enums.Ownership

export type Provider = $Enums.Provider

export const Provider: typeof $Enums.Provider

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Availability = $Enums.Availability

export const Availability: typeof $Enums.Availability

export type Load = $Enums.Load

export const Load: typeof $Enums.Load

export type ContactType = $Enums.ContactType

export const ContactType: typeof $Enums.ContactType

export type Action = $Enums.Action

export const Action: typeof $Enums.Action

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Regions
 * const regions = await prisma.region.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Regions
   * const regions = await prisma.region.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.region`: Exposes CRUD operations for the **Region** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regions
    * const regions = await prisma.region.findMany()
    * ```
    */
  get region(): Prisma.RegionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pOrC`: Exposes CRUD operations for the **POrC** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more POrCS
    * const pOrCS = await prisma.pOrC.findMany()
    * ```
    */
  get pOrC(): Prisma.POrCDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cOrM`: Exposes CRUD operations for the **COrM** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more COrMS
    * const cOrMS = await prisma.cOrM.findMany()
    * ```
    */
  get cOrM(): Prisma.COrMDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.brgy`: Exposes CRUD operations for the **Brgy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brgies
    * const brgies = await prisma.brgy.findMany()
    * ```
    */
  get brgy(): Prisma.BrgyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.facility`: Exposes CRUD operations for the **Facility** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Facilities
    * const facilities = await prisma.facility.findMany()
    * ```
    */
  get facility(): Prisma.FacilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.division`: Exposes CRUD operations for the **Division** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Divisions
    * const divisions = await prisma.division.findMany()
    * ```
    */
  get division(): Prisma.DivisionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ambulanceService`: Exposes CRUD operations for the **AmbulanceService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AmbulanceServices
    * const ambulanceServices = await prisma.ambulanceService.findMany()
    * ```
    */
  get ambulanceService(): Prisma.AmbulanceServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bloodTypeMapping`: Exposes CRUD operations for the **BloodTypeMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BloodTypeMappings
    * const bloodTypeMappings = await prisma.bloodTypeMapping.findMany()
    * ```
    */
  get bloodTypeMapping(): Prisma.BloodTypeMappingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bloodBankService`: Exposes CRUD operations for the **BloodBankService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BloodBankServices
    * const bloodBankServices = await prisma.bloodBankService.findMany()
    * ```
    */
  get bloodBankService(): Prisma.BloodBankServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eRService`: Exposes CRUD operations for the **ERService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ERServices
    * const eRServices = await prisma.eRService.findMany()
    * ```
    */
  get eRService(): Prisma.ERServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.iCUService`: Exposes CRUD operations for the **ICUService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ICUServices
    * const iCUServices = await prisma.iCUService.findMany()
    * ```
    */
  get iCUService(): Prisma.ICUServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.outpatientService`: Exposes CRUD operations for the **OutpatientService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OutpatientServices
    * const outpatientServices = await prisma.outpatientService.findMany()
    * ```
    */
  get outpatientService(): Prisma.OutpatientServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.updateLog`: Exposes CRUD operations for the **UpdateLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UpdateLogs
    * const updateLogs = await prisma.updateLog.findMany()
    * ```
    */
  get updateLog(): Prisma.UpdateLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.4.1
   * Query Engine version: a9055b89e58b4b5bfb59600785423b1db3d0e75d
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Region: 'Region',
    POrC: 'POrC',
    COrM: 'COrM',
    Brgy: 'Brgy',
    Address: 'Address',
    Facility: 'Facility',
    Division: 'Division',
    Employee: 'Employee',
    Session: 'Session',
    Service: 'Service',
    AmbulanceService: 'AmbulanceService',
    BloodTypeMapping: 'BloodTypeMapping',
    BloodBankService: 'BloodBankService',
    ERService: 'ERService',
    ICUService: 'ICUService',
    OutpatientService: 'OutpatientService',
    Contact: 'Contact',
    UpdateLog: 'UpdateLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "region" | "pOrC" | "cOrM" | "brgy" | "address" | "facility" | "division" | "employee" | "session" | "service" | "ambulanceService" | "bloodTypeMapping" | "bloodBankService" | "eRService" | "iCUService" | "outpatientService" | "contact" | "updateLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Region: {
        payload: Prisma.$RegionPayload<ExtArgs>
        fields: Prisma.RegionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findFirst: {
            args: Prisma.RegionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findMany: {
            args: Prisma.RegionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          create: {
            args: Prisma.RegionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          createMany: {
            args: Prisma.RegionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RegionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          delete: {
            args: Prisma.RegionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          update: {
            args: Prisma.RegionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          deleteMany: {
            args: Prisma.RegionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RegionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          upsert: {
            args: Prisma.RegionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          aggregate: {
            args: Prisma.RegionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegion>
          }
          groupBy: {
            args: Prisma.RegionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegionCountArgs<ExtArgs>
            result: $Utils.Optional<RegionCountAggregateOutputType> | number
          }
        }
      }
      POrC: {
        payload: Prisma.$POrCPayload<ExtArgs>
        fields: Prisma.POrCFieldRefs
        operations: {
          findUnique: {
            args: Prisma.POrCFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POrCPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.POrCFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POrCPayload>
          }
          findFirst: {
            args: Prisma.POrCFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POrCPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.POrCFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POrCPayload>
          }
          findMany: {
            args: Prisma.POrCFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POrCPayload>[]
          }
          create: {
            args: Prisma.POrCCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POrCPayload>
          }
          createMany: {
            args: Prisma.POrCCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.POrCCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POrCPayload>[]
          }
          delete: {
            args: Prisma.POrCDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POrCPayload>
          }
          update: {
            args: Prisma.POrCUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POrCPayload>
          }
          deleteMany: {
            args: Prisma.POrCDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.POrCUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.POrCUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POrCPayload>[]
          }
          upsert: {
            args: Prisma.POrCUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$POrCPayload>
          }
          aggregate: {
            args: Prisma.POrCAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePOrC>
          }
          groupBy: {
            args: Prisma.POrCGroupByArgs<ExtArgs>
            result: $Utils.Optional<POrCGroupByOutputType>[]
          }
          count: {
            args: Prisma.POrCCountArgs<ExtArgs>
            result: $Utils.Optional<POrCCountAggregateOutputType> | number
          }
        }
      }
      COrM: {
        payload: Prisma.$COrMPayload<ExtArgs>
        fields: Prisma.COrMFieldRefs
        operations: {
          findUnique: {
            args: Prisma.COrMFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$COrMPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.COrMFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$COrMPayload>
          }
          findFirst: {
            args: Prisma.COrMFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$COrMPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.COrMFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$COrMPayload>
          }
          findMany: {
            args: Prisma.COrMFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$COrMPayload>[]
          }
          create: {
            args: Prisma.COrMCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$COrMPayload>
          }
          createMany: {
            args: Prisma.COrMCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.COrMCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$COrMPayload>[]
          }
          delete: {
            args: Prisma.COrMDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$COrMPayload>
          }
          update: {
            args: Prisma.COrMUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$COrMPayload>
          }
          deleteMany: {
            args: Prisma.COrMDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.COrMUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.COrMUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$COrMPayload>[]
          }
          upsert: {
            args: Prisma.COrMUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$COrMPayload>
          }
          aggregate: {
            args: Prisma.COrMAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCOrM>
          }
          groupBy: {
            args: Prisma.COrMGroupByArgs<ExtArgs>
            result: $Utils.Optional<COrMGroupByOutputType>[]
          }
          count: {
            args: Prisma.COrMCountArgs<ExtArgs>
            result: $Utils.Optional<COrMCountAggregateOutputType> | number
          }
        }
      }
      Brgy: {
        payload: Prisma.$BrgyPayload<ExtArgs>
        fields: Prisma.BrgyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BrgyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrgyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BrgyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrgyPayload>
          }
          findFirst: {
            args: Prisma.BrgyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrgyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BrgyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrgyPayload>
          }
          findMany: {
            args: Prisma.BrgyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrgyPayload>[]
          }
          create: {
            args: Prisma.BrgyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrgyPayload>
          }
          createMany: {
            args: Prisma.BrgyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BrgyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrgyPayload>[]
          }
          delete: {
            args: Prisma.BrgyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrgyPayload>
          }
          update: {
            args: Prisma.BrgyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrgyPayload>
          }
          deleteMany: {
            args: Prisma.BrgyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BrgyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BrgyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrgyPayload>[]
          }
          upsert: {
            args: Prisma.BrgyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrgyPayload>
          }
          aggregate: {
            args: Prisma.BrgyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrgy>
          }
          groupBy: {
            args: Prisma.BrgyGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrgyGroupByOutputType>[]
          }
          count: {
            args: Prisma.BrgyCountArgs<ExtArgs>
            result: $Utils.Optional<BrgyCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      Facility: {
        payload: Prisma.$FacilityPayload<ExtArgs>
        fields: Prisma.FacilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          findFirst: {
            args: Prisma.FacilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          findMany: {
            args: Prisma.FacilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>[]
          }
          create: {
            args: Prisma.FacilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          createMany: {
            args: Prisma.FacilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>[]
          }
          delete: {
            args: Prisma.FacilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          update: {
            args: Prisma.FacilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          deleteMany: {
            args: Prisma.FacilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FacilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>[]
          }
          upsert: {
            args: Prisma.FacilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          aggregate: {
            args: Prisma.FacilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFacility>
          }
          groupBy: {
            args: Prisma.FacilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacilityCountArgs<ExtArgs>
            result: $Utils.Optional<FacilityCountAggregateOutputType> | number
          }
        }
      }
      Division: {
        payload: Prisma.$DivisionPayload<ExtArgs>
        fields: Prisma.DivisionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DivisionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DivisionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>
          }
          findFirst: {
            args: Prisma.DivisionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DivisionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>
          }
          findMany: {
            args: Prisma.DivisionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>[]
          }
          create: {
            args: Prisma.DivisionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>
          }
          createMany: {
            args: Prisma.DivisionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DivisionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>[]
          }
          delete: {
            args: Prisma.DivisionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>
          }
          update: {
            args: Prisma.DivisionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>
          }
          deleteMany: {
            args: Prisma.DivisionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DivisionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DivisionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>[]
          }
          upsert: {
            args: Prisma.DivisionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DivisionPayload>
          }
          aggregate: {
            args: Prisma.DivisionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDivision>
          }
          groupBy: {
            args: Prisma.DivisionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DivisionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DivisionCountArgs<ExtArgs>
            result: $Utils.Optional<DivisionCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      AmbulanceService: {
        payload: Prisma.$AmbulanceServicePayload<ExtArgs>
        fields: Prisma.AmbulanceServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmbulanceServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulanceServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmbulanceServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulanceServicePayload>
          }
          findFirst: {
            args: Prisma.AmbulanceServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulanceServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmbulanceServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulanceServicePayload>
          }
          findMany: {
            args: Prisma.AmbulanceServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulanceServicePayload>[]
          }
          create: {
            args: Prisma.AmbulanceServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulanceServicePayload>
          }
          createMany: {
            args: Prisma.AmbulanceServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AmbulanceServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulanceServicePayload>[]
          }
          delete: {
            args: Prisma.AmbulanceServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulanceServicePayload>
          }
          update: {
            args: Prisma.AmbulanceServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulanceServicePayload>
          }
          deleteMany: {
            args: Prisma.AmbulanceServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmbulanceServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AmbulanceServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulanceServicePayload>[]
          }
          upsert: {
            args: Prisma.AmbulanceServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmbulanceServicePayload>
          }
          aggregate: {
            args: Prisma.AmbulanceServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmbulanceService>
          }
          groupBy: {
            args: Prisma.AmbulanceServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmbulanceServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmbulanceServiceCountArgs<ExtArgs>
            result: $Utils.Optional<AmbulanceServiceCountAggregateOutputType> | number
          }
        }
      }
      BloodTypeMapping: {
        payload: Prisma.$BloodTypeMappingPayload<ExtArgs>
        fields: Prisma.BloodTypeMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BloodTypeMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodTypeMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BloodTypeMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodTypeMappingPayload>
          }
          findFirst: {
            args: Prisma.BloodTypeMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodTypeMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BloodTypeMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodTypeMappingPayload>
          }
          findMany: {
            args: Prisma.BloodTypeMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodTypeMappingPayload>[]
          }
          create: {
            args: Prisma.BloodTypeMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodTypeMappingPayload>
          }
          createMany: {
            args: Prisma.BloodTypeMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BloodTypeMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodTypeMappingPayload>[]
          }
          delete: {
            args: Prisma.BloodTypeMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodTypeMappingPayload>
          }
          update: {
            args: Prisma.BloodTypeMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodTypeMappingPayload>
          }
          deleteMany: {
            args: Prisma.BloodTypeMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BloodTypeMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BloodTypeMappingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodTypeMappingPayload>[]
          }
          upsert: {
            args: Prisma.BloodTypeMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodTypeMappingPayload>
          }
          aggregate: {
            args: Prisma.BloodTypeMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBloodTypeMapping>
          }
          groupBy: {
            args: Prisma.BloodTypeMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BloodTypeMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BloodTypeMappingCountArgs<ExtArgs>
            result: $Utils.Optional<BloodTypeMappingCountAggregateOutputType> | number
          }
        }
      }
      BloodBankService: {
        payload: Prisma.$BloodBankServicePayload<ExtArgs>
        fields: Prisma.BloodBankServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BloodBankServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodBankServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BloodBankServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodBankServicePayload>
          }
          findFirst: {
            args: Prisma.BloodBankServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodBankServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BloodBankServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodBankServicePayload>
          }
          findMany: {
            args: Prisma.BloodBankServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodBankServicePayload>[]
          }
          create: {
            args: Prisma.BloodBankServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodBankServicePayload>
          }
          createMany: {
            args: Prisma.BloodBankServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BloodBankServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodBankServicePayload>[]
          }
          delete: {
            args: Prisma.BloodBankServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodBankServicePayload>
          }
          update: {
            args: Prisma.BloodBankServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodBankServicePayload>
          }
          deleteMany: {
            args: Prisma.BloodBankServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BloodBankServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BloodBankServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodBankServicePayload>[]
          }
          upsert: {
            args: Prisma.BloodBankServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BloodBankServicePayload>
          }
          aggregate: {
            args: Prisma.BloodBankServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBloodBankService>
          }
          groupBy: {
            args: Prisma.BloodBankServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<BloodBankServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.BloodBankServiceCountArgs<ExtArgs>
            result: $Utils.Optional<BloodBankServiceCountAggregateOutputType> | number
          }
        }
      }
      ERService: {
        payload: Prisma.$ERServicePayload<ExtArgs>
        fields: Prisma.ERServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ERServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ERServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ERServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ERServicePayload>
          }
          findFirst: {
            args: Prisma.ERServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ERServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ERServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ERServicePayload>
          }
          findMany: {
            args: Prisma.ERServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ERServicePayload>[]
          }
          create: {
            args: Prisma.ERServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ERServicePayload>
          }
          createMany: {
            args: Prisma.ERServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ERServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ERServicePayload>[]
          }
          delete: {
            args: Prisma.ERServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ERServicePayload>
          }
          update: {
            args: Prisma.ERServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ERServicePayload>
          }
          deleteMany: {
            args: Prisma.ERServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ERServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ERServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ERServicePayload>[]
          }
          upsert: {
            args: Prisma.ERServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ERServicePayload>
          }
          aggregate: {
            args: Prisma.ERServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateERService>
          }
          groupBy: {
            args: Prisma.ERServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ERServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ERServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ERServiceCountAggregateOutputType> | number
          }
        }
      }
      ICUService: {
        payload: Prisma.$ICUServicePayload<ExtArgs>
        fields: Prisma.ICUServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ICUServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ICUServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ICUServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ICUServicePayload>
          }
          findFirst: {
            args: Prisma.ICUServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ICUServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ICUServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ICUServicePayload>
          }
          findMany: {
            args: Prisma.ICUServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ICUServicePayload>[]
          }
          create: {
            args: Prisma.ICUServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ICUServicePayload>
          }
          createMany: {
            args: Prisma.ICUServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ICUServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ICUServicePayload>[]
          }
          delete: {
            args: Prisma.ICUServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ICUServicePayload>
          }
          update: {
            args: Prisma.ICUServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ICUServicePayload>
          }
          deleteMany: {
            args: Prisma.ICUServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ICUServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ICUServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ICUServicePayload>[]
          }
          upsert: {
            args: Prisma.ICUServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ICUServicePayload>
          }
          aggregate: {
            args: Prisma.ICUServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateICUService>
          }
          groupBy: {
            args: Prisma.ICUServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ICUServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ICUServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ICUServiceCountAggregateOutputType> | number
          }
        }
      }
      OutpatientService: {
        payload: Prisma.$OutpatientServicePayload<ExtArgs>
        fields: Prisma.OutpatientServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OutpatientServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutpatientServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutpatientServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutpatientServicePayload>
          }
          findFirst: {
            args: Prisma.OutpatientServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutpatientServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutpatientServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutpatientServicePayload>
          }
          findMany: {
            args: Prisma.OutpatientServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutpatientServicePayload>[]
          }
          create: {
            args: Prisma.OutpatientServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutpatientServicePayload>
          }
          createMany: {
            args: Prisma.OutpatientServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OutpatientServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutpatientServicePayload>[]
          }
          delete: {
            args: Prisma.OutpatientServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutpatientServicePayload>
          }
          update: {
            args: Prisma.OutpatientServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutpatientServicePayload>
          }
          deleteMany: {
            args: Prisma.OutpatientServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OutpatientServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OutpatientServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutpatientServicePayload>[]
          }
          upsert: {
            args: Prisma.OutpatientServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutpatientServicePayload>
          }
          aggregate: {
            args: Prisma.OutpatientServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOutpatientService>
          }
          groupBy: {
            args: Prisma.OutpatientServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<OutpatientServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.OutpatientServiceCountArgs<ExtArgs>
            result: $Utils.Optional<OutpatientServiceCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      UpdateLog: {
        payload: Prisma.$UpdateLogPayload<ExtArgs>
        fields: Prisma.UpdateLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UpdateLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdateLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UpdateLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdateLogPayload>
          }
          findFirst: {
            args: Prisma.UpdateLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdateLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UpdateLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdateLogPayload>
          }
          findMany: {
            args: Prisma.UpdateLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdateLogPayload>[]
          }
          create: {
            args: Prisma.UpdateLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdateLogPayload>
          }
          createMany: {
            args: Prisma.UpdateLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UpdateLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdateLogPayload>[]
          }
          delete: {
            args: Prisma.UpdateLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdateLogPayload>
          }
          update: {
            args: Prisma.UpdateLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdateLogPayload>
          }
          deleteMany: {
            args: Prisma.UpdateLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UpdateLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UpdateLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdateLogPayload>[]
          }
          upsert: {
            args: Prisma.UpdateLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdateLogPayload>
          }
          aggregate: {
            args: Prisma.UpdateLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUpdateLog>
          }
          groupBy: {
            args: Prisma.UpdateLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<UpdateLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.UpdateLogCountArgs<ExtArgs>
            result: $Utils.Optional<UpdateLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    region?: RegionOmit
    pOrC?: POrCOmit
    cOrM?: COrMOmit
    brgy?: BrgyOmit
    address?: AddressOmit
    facility?: FacilityOmit
    division?: DivisionOmit
    employee?: EmployeeOmit
    session?: SessionOmit
    service?: ServiceOmit
    ambulanceService?: AmbulanceServiceOmit
    bloodTypeMapping?: BloodTypeMappingOmit
    bloodBankService?: BloodBankServiceOmit
    eRService?: ERServiceOmit
    iCUService?: ICUServiceOmit
    outpatientService?: OutpatientServiceOmit
    contact?: ContactOmit
    updateLog?: UpdateLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RegionCountOutputType
   */

  export type RegionCountOutputType = {
    pOrCs: number
    addresses: number
  }

  export type RegionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pOrCs?: boolean | RegionCountOutputTypeCountPOrCsArgs
    addresses?: boolean | RegionCountOutputTypeCountAddressesArgs
  }

  // Custom InputTypes
  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCountOutputType
     */
    select?: RegionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountPOrCsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POrCWhereInput
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }


  /**
   * Count Type POrCCountOutputType
   */

  export type POrCCountOutputType = {
    cOrMs: number
    addresses: number
  }

  export type POrCCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cOrMs?: boolean | POrCCountOutputTypeCountCOrMsArgs
    addresses?: boolean | POrCCountOutputTypeCountAddressesArgs
  }

  // Custom InputTypes
  /**
   * POrCCountOutputType without action
   */
  export type POrCCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POrCCountOutputType
     */
    select?: POrCCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * POrCCountOutputType without action
   */
  export type POrCCountOutputTypeCountCOrMsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: COrMWhereInput
  }

  /**
   * POrCCountOutputType without action
   */
  export type POrCCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }


  /**
   * Count Type COrMCountOutputType
   */

  export type COrMCountOutputType = {
    brgys: number
    addresses: number
  }

  export type COrMCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brgys?: boolean | COrMCountOutputTypeCountBrgysArgs
    addresses?: boolean | COrMCountOutputTypeCountAddressesArgs
  }

  // Custom InputTypes
  /**
   * COrMCountOutputType without action
   */
  export type COrMCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COrMCountOutputType
     */
    select?: COrMCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * COrMCountOutputType without action
   */
  export type COrMCountOutputTypeCountBrgysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrgyWhereInput
  }

  /**
   * COrMCountOutputType without action
   */
  export type COrMCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }


  /**
   * Count Type BrgyCountOutputType
   */

  export type BrgyCountOutputType = {
    addresses: number
  }

  export type BrgyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addresses?: boolean | BrgyCountOutputTypeCountAddressesArgs
  }

  // Custom InputTypes
  /**
   * BrgyCountOutputType without action
   */
  export type BrgyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrgyCountOutputType
     */
    select?: BrgyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BrgyCountOutputType without action
   */
  export type BrgyCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }


  /**
   * Count Type FacilityCountOutputType
   */

  export type FacilityCountOutputType = {
    contacts: number
    services: number
    employees: number
    divisions: number
    logs: number
  }

  export type FacilityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | FacilityCountOutputTypeCountContactsArgs
    services?: boolean | FacilityCountOutputTypeCountServicesArgs
    employees?: boolean | FacilityCountOutputTypeCountEmployeesArgs
    divisions?: boolean | FacilityCountOutputTypeCountDivisionsArgs
    logs?: boolean | FacilityCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityCountOutputType
     */
    select?: FacilityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountDivisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DivisionWhereInput
  }

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UpdateLogWhereInput
  }


  /**
   * Count Type DivisionCountOutputType
   */

  export type DivisionCountOutputType = {
    contacts: number
    services: number
    admins: number
    logs: number
  }

  export type DivisionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | DivisionCountOutputTypeCountContactsArgs
    services?: boolean | DivisionCountOutputTypeCountServicesArgs
    admins?: boolean | DivisionCountOutputTypeCountAdminsArgs
    logs?: boolean | DivisionCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * DivisionCountOutputType without action
   */
  export type DivisionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DivisionCountOutputType
     */
    select?: DivisionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DivisionCountOutputType without action
   */
  export type DivisionCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * DivisionCountOutputType without action
   */
  export type DivisionCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }

  /**
   * DivisionCountOutputType without action
   */
  export type DivisionCountOutputTypeCountAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * DivisionCountOutputType without action
   */
  export type DivisionCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UpdateLogWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    sessions: number
    divisions: number
    updateLog: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | EmployeeCountOutputTypeCountSessionsArgs
    divisions?: boolean | EmployeeCountOutputTypeCountDivisionsArgs
    updateLog?: boolean | EmployeeCountOutputTypeCountUpdateLogArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountDivisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DivisionWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountUpdateLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UpdateLogWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    phoneNumbers: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phoneNumbers?: boolean | ServiceCountOutputTypeCountPhoneNumbersArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountPhoneNumbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Region
   */

  export type AggregateRegion = {
    _count: RegionCountAggregateOutputType | null
    _avg: RegionAvgAggregateOutputType | null
    _sum: RegionSumAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  export type RegionAvgAggregateOutputType = {
    regionID: number | null
    id: number | null
  }

  export type RegionSumAggregateOutputType = {
    regionID: number | null
    id: number | null
  }

  export type RegionMinAggregateOutputType = {
    regionID: number | null
    name: string | null
    id: number | null
  }

  export type RegionMaxAggregateOutputType = {
    regionID: number | null
    name: string | null
    id: number | null
  }

  export type RegionCountAggregateOutputType = {
    regionID: number
    name: number
    id: number
    _all: number
  }


  export type RegionAvgAggregateInputType = {
    regionID?: true
    id?: true
  }

  export type RegionSumAggregateInputType = {
    regionID?: true
    id?: true
  }

  export type RegionMinAggregateInputType = {
    regionID?: true
    name?: true
    id?: true
  }

  export type RegionMaxAggregateInputType = {
    regionID?: true
    name?: true
    id?: true
  }

  export type RegionCountAggregateInputType = {
    regionID?: true
    name?: true
    id?: true
    _all?: true
  }

  export type RegionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Region to aggregate.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Regions
    **/
    _count?: true | RegionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionMaxAggregateInputType
  }

  export type GetRegionAggregateType<T extends RegionAggregateArgs> = {
        [P in keyof T & keyof AggregateRegion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegion[P]>
      : GetScalarType<T[P], AggregateRegion[P]>
  }




  export type RegionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionWhereInput
    orderBy?: RegionOrderByWithAggregationInput | RegionOrderByWithAggregationInput[]
    by: RegionScalarFieldEnum[] | RegionScalarFieldEnum
    having?: RegionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionCountAggregateInputType | true
    _avg?: RegionAvgAggregateInputType
    _sum?: RegionSumAggregateInputType
    _min?: RegionMinAggregateInputType
    _max?: RegionMaxAggregateInputType
  }

  export type RegionGroupByOutputType = {
    regionID: number
    name: string
    id: number
    _count: RegionCountAggregateOutputType | null
    _avg: RegionAvgAggregateOutputType | null
    _sum: RegionSumAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  type GetRegionGroupByPayload<T extends RegionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionGroupByOutputType[P]>
            : GetScalarType<T[P], RegionGroupByOutputType[P]>
        }
      >
    >


  export type RegionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    regionID?: boolean
    name?: boolean
    id?: boolean
    pOrCs?: boolean | Region$pOrCsArgs<ExtArgs>
    addresses?: boolean | Region$addressesArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["region"]>

  export type RegionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    regionID?: boolean
    name?: boolean
    id?: boolean
  }, ExtArgs["result"]["region"]>

  export type RegionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    regionID?: boolean
    name?: boolean
    id?: boolean
  }, ExtArgs["result"]["region"]>

  export type RegionSelectScalar = {
    regionID?: boolean
    name?: boolean
    id?: boolean
  }

  export type RegionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"regionID" | "name" | "id", ExtArgs["result"]["region"]>
  export type RegionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pOrCs?: boolean | Region$pOrCsArgs<ExtArgs>
    addresses?: boolean | Region$addressesArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RegionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RegionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RegionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Region"
    objects: {
      pOrCs: Prisma.$POrCPayload<ExtArgs>[]
      addresses: Prisma.$AddressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      regionID: number
      name: string
      id: number
    }, ExtArgs["result"]["region"]>
    composites: {}
  }

  type RegionGetPayload<S extends boolean | null | undefined | RegionDefaultArgs> = $Result.GetResult<Prisma.$RegionPayload, S>

  type RegionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegionCountAggregateInputType | true
    }

  export interface RegionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Region'], meta: { name: 'Region' } }
    /**
     * Find zero or one Region that matches the filter.
     * @param {RegionFindUniqueArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegionFindUniqueArgs>(args: SelectSubset<T, RegionFindUniqueArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Region that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegionFindUniqueOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegionFindUniqueOrThrowArgs>(args: SelectSubset<T, RegionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Region that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegionFindFirstArgs>(args?: SelectSubset<T, RegionFindFirstArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Region that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegionFindFirstOrThrowArgs>(args?: SelectSubset<T, RegionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regions
     * const regions = await prisma.region.findMany()
     * 
     * // Get first 10 Regions
     * const regions = await prisma.region.findMany({ take: 10 })
     * 
     * // Only select the `regionID`
     * const regionWithRegionIDOnly = await prisma.region.findMany({ select: { regionID: true } })
     * 
     */
    findMany<T extends RegionFindManyArgs>(args?: SelectSubset<T, RegionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Region.
     * @param {RegionCreateArgs} args - Arguments to create a Region.
     * @example
     * // Create one Region
     * const Region = await prisma.region.create({
     *   data: {
     *     // ... data to create a Region
     *   }
     * })
     * 
     */
    create<T extends RegionCreateArgs>(args: SelectSubset<T, RegionCreateArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Regions.
     * @param {RegionCreateManyArgs} args - Arguments to create many Regions.
     * @example
     * // Create many Regions
     * const region = await prisma.region.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegionCreateManyArgs>(args?: SelectSubset<T, RegionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Regions and returns the data saved in the database.
     * @param {RegionCreateManyAndReturnArgs} args - Arguments to create many Regions.
     * @example
     * // Create many Regions
     * const region = await prisma.region.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Regions and only return the `regionID`
     * const regionWithRegionIDOnly = await prisma.region.createManyAndReturn({
     *   select: { regionID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RegionCreateManyAndReturnArgs>(args?: SelectSubset<T, RegionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Region.
     * @param {RegionDeleteArgs} args - Arguments to delete one Region.
     * @example
     * // Delete one Region
     * const Region = await prisma.region.delete({
     *   where: {
     *     // ... filter to delete one Region
     *   }
     * })
     * 
     */
    delete<T extends RegionDeleteArgs>(args: SelectSubset<T, RegionDeleteArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Region.
     * @param {RegionUpdateArgs} args - Arguments to update one Region.
     * @example
     * // Update one Region
     * const region = await prisma.region.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegionUpdateArgs>(args: SelectSubset<T, RegionUpdateArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Regions.
     * @param {RegionDeleteManyArgs} args - Arguments to filter Regions to delete.
     * @example
     * // Delete a few Regions
     * const { count } = await prisma.region.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegionDeleteManyArgs>(args?: SelectSubset<T, RegionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegionUpdateManyArgs>(args: SelectSubset<T, RegionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions and returns the data updated in the database.
     * @param {RegionUpdateManyAndReturnArgs} args - Arguments to update many Regions.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Regions and only return the `regionID`
     * const regionWithRegionIDOnly = await prisma.region.updateManyAndReturn({
     *   select: { regionID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RegionUpdateManyAndReturnArgs>(args: SelectSubset<T, RegionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Region.
     * @param {RegionUpsertArgs} args - Arguments to update or create a Region.
     * @example
     * // Update or create a Region
     * const region = await prisma.region.upsert({
     *   create: {
     *     // ... data to create a Region
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Region we want to update
     *   }
     * })
     */
    upsert<T extends RegionUpsertArgs>(args: SelectSubset<T, RegionUpsertArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCountArgs} args - Arguments to filter Regions to count.
     * @example
     * // Count the number of Regions
     * const count = await prisma.region.count({
     *   where: {
     *     // ... the filter for the Regions we want to count
     *   }
     * })
    **/
    count<T extends RegionCountArgs>(
      args?: Subset<T, RegionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionAggregateArgs>(args: Subset<T, RegionAggregateArgs>): Prisma.PrismaPromise<GetRegionAggregateType<T>>

    /**
     * Group by Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionGroupByArgs['orderBy'] }
        : { orderBy?: RegionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Region model
   */
  readonly fields: RegionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Region.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pOrCs<T extends Region$pOrCsArgs<ExtArgs> = {}>(args?: Subset<T, Region$pOrCsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POrCPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    addresses<T extends Region$addressesArgs<ExtArgs> = {}>(args?: Subset<T, Region$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Region model
   */ 
  interface RegionFieldRefs {
    readonly regionID: FieldRef<"Region", 'Int'>
    readonly name: FieldRef<"Region", 'String'>
    readonly id: FieldRef<"Region", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Region findUnique
   */
  export type RegionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region findUniqueOrThrow
   */
  export type RegionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region findFirst
   */
  export type RegionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region findFirstOrThrow
   */
  export type RegionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region findMany
   */
  export type RegionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Regions to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region create
   */
  export type RegionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to create a Region.
     */
    data: XOR<RegionCreateInput, RegionUncheckedCreateInput>
  }

  /**
   * Region createMany
   */
  export type RegionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Regions.
     */
    data: RegionCreateManyInput | RegionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Region createManyAndReturn
   */
  export type RegionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * The data used to create many Regions.
     */
    data: RegionCreateManyInput | RegionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Region update
   */
  export type RegionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to update a Region.
     */
    data: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
    /**
     * Choose, which Region to update.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region updateMany
   */
  export type RegionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Regions.
     */
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>
    /**
     * Filter which Regions to update
     */
    where?: RegionWhereInput
    /**
     * Limit how many Regions to update.
     */
    limit?: number
  }

  /**
   * Region updateManyAndReturn
   */
  export type RegionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * The data used to update Regions.
     */
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>
    /**
     * Filter which Regions to update
     */
    where?: RegionWhereInput
    /**
     * Limit how many Regions to update.
     */
    limit?: number
  }

  /**
   * Region upsert
   */
  export type RegionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The filter to search for the Region to update in case it exists.
     */
    where: RegionWhereUniqueInput
    /**
     * In case the Region found by the `where` argument doesn't exist, create a new Region with this data.
     */
    create: XOR<RegionCreateInput, RegionUncheckedCreateInput>
    /**
     * In case the Region was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
  }

  /**
   * Region delete
   */
  export type RegionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter which Region to delete.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region deleteMany
   */
  export type RegionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Regions to delete
     */
    where?: RegionWhereInput
    /**
     * Limit how many Regions to delete.
     */
    limit?: number
  }

  /**
   * Region.pOrCs
   */
  export type Region$pOrCsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POrC
     */
    select?: POrCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POrC
     */
    omit?: POrCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POrCInclude<ExtArgs> | null
    where?: POrCWhereInput
    orderBy?: POrCOrderByWithRelationInput | POrCOrderByWithRelationInput[]
    cursor?: POrCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: POrCScalarFieldEnum | POrCScalarFieldEnum[]
  }

  /**
   * Region.addresses
   */
  export type Region$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Region without action
   */
  export type RegionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
  }


  /**
   * Model POrC
   */

  export type AggregatePOrC = {
    _count: POrCCountAggregateOutputType | null
    _avg: POrCAvgAggregateOutputType | null
    _sum: POrCSumAggregateOutputType | null
    _min: POrCMinAggregateOutputType | null
    _max: POrCMaxAggregateOutputType | null
  }

  export type POrCAvgAggregateOutputType = {
    pOrCID: number | null
    id: number | null
    regionID: number | null
  }

  export type POrCSumAggregateOutputType = {
    pOrCID: number | null
    id: number | null
    regionID: number | null
  }

  export type POrCMinAggregateOutputType = {
    pOrCID: number | null
    name: string | null
    id: number | null
    regionID: number | null
  }

  export type POrCMaxAggregateOutputType = {
    pOrCID: number | null
    name: string | null
    id: number | null
    regionID: number | null
  }

  export type POrCCountAggregateOutputType = {
    pOrCID: number
    name: number
    id: number
    regionID: number
    _all: number
  }


  export type POrCAvgAggregateInputType = {
    pOrCID?: true
    id?: true
    regionID?: true
  }

  export type POrCSumAggregateInputType = {
    pOrCID?: true
    id?: true
    regionID?: true
  }

  export type POrCMinAggregateInputType = {
    pOrCID?: true
    name?: true
    id?: true
    regionID?: true
  }

  export type POrCMaxAggregateInputType = {
    pOrCID?: true
    name?: true
    id?: true
    regionID?: true
  }

  export type POrCCountAggregateInputType = {
    pOrCID?: true
    name?: true
    id?: true
    regionID?: true
    _all?: true
  }

  export type POrCAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POrC to aggregate.
     */
    where?: POrCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POrCS to fetch.
     */
    orderBy?: POrCOrderByWithRelationInput | POrCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: POrCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POrCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POrCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned POrCS
    **/
    _count?: true | POrCCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: POrCAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: POrCSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: POrCMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: POrCMaxAggregateInputType
  }

  export type GetPOrCAggregateType<T extends POrCAggregateArgs> = {
        [P in keyof T & keyof AggregatePOrC]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePOrC[P]>
      : GetScalarType<T[P], AggregatePOrC[P]>
  }




  export type POrCGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: POrCWhereInput
    orderBy?: POrCOrderByWithAggregationInput | POrCOrderByWithAggregationInput[]
    by: POrCScalarFieldEnum[] | POrCScalarFieldEnum
    having?: POrCScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: POrCCountAggregateInputType | true
    _avg?: POrCAvgAggregateInputType
    _sum?: POrCSumAggregateInputType
    _min?: POrCMinAggregateInputType
    _max?: POrCMaxAggregateInputType
  }

  export type POrCGroupByOutputType = {
    pOrCID: number
    name: string
    id: number
    regionID: number
    _count: POrCCountAggregateOutputType | null
    _avg: POrCAvgAggregateOutputType | null
    _sum: POrCSumAggregateOutputType | null
    _min: POrCMinAggregateOutputType | null
    _max: POrCMaxAggregateOutputType | null
  }

  type GetPOrCGroupByPayload<T extends POrCGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<POrCGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof POrCGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], POrCGroupByOutputType[P]>
            : GetScalarType<T[P], POrCGroupByOutputType[P]>
        }
      >
    >


  export type POrCSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pOrCID?: boolean
    name?: boolean
    id?: boolean
    regionID?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
    cOrMs?: boolean | POrC$cOrMsArgs<ExtArgs>
    addresses?: boolean | POrC$addressesArgs<ExtArgs>
    _count?: boolean | POrCCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOrC"]>

  export type POrCSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pOrCID?: boolean
    name?: boolean
    id?: boolean
    regionID?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOrC"]>

  export type POrCSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pOrCID?: boolean
    name?: boolean
    id?: boolean
    regionID?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pOrC"]>

  export type POrCSelectScalar = {
    pOrCID?: boolean
    name?: boolean
    id?: boolean
    regionID?: boolean
  }

  export type POrCOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"pOrCID" | "name" | "id" | "regionID", ExtArgs["result"]["pOrC"]>
  export type POrCInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
    cOrMs?: boolean | POrC$cOrMsArgs<ExtArgs>
    addresses?: boolean | POrC$addressesArgs<ExtArgs>
    _count?: boolean | POrCCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type POrCIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
  }
  export type POrCIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
  }

  export type $POrCPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "POrC"
    objects: {
      region: Prisma.$RegionPayload<ExtArgs>
      cOrMs: Prisma.$COrMPayload<ExtArgs>[]
      addresses: Prisma.$AddressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      pOrCID: number
      name: string
      id: number
      regionID: number
    }, ExtArgs["result"]["pOrC"]>
    composites: {}
  }

  type POrCGetPayload<S extends boolean | null | undefined | POrCDefaultArgs> = $Result.GetResult<Prisma.$POrCPayload, S>

  type POrCCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<POrCFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: POrCCountAggregateInputType | true
    }

  export interface POrCDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['POrC'], meta: { name: 'POrC' } }
    /**
     * Find zero or one POrC that matches the filter.
     * @param {POrCFindUniqueArgs} args - Arguments to find a POrC
     * @example
     * // Get one POrC
     * const pOrC = await prisma.pOrC.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends POrCFindUniqueArgs>(args: SelectSubset<T, POrCFindUniqueArgs<ExtArgs>>): Prisma__POrCClient<$Result.GetResult<Prisma.$POrCPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one POrC that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {POrCFindUniqueOrThrowArgs} args - Arguments to find a POrC
     * @example
     * // Get one POrC
     * const pOrC = await prisma.pOrC.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends POrCFindUniqueOrThrowArgs>(args: SelectSubset<T, POrCFindUniqueOrThrowArgs<ExtArgs>>): Prisma__POrCClient<$Result.GetResult<Prisma.$POrCPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first POrC that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POrCFindFirstArgs} args - Arguments to find a POrC
     * @example
     * // Get one POrC
     * const pOrC = await prisma.pOrC.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends POrCFindFirstArgs>(args?: SelectSubset<T, POrCFindFirstArgs<ExtArgs>>): Prisma__POrCClient<$Result.GetResult<Prisma.$POrCPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first POrC that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POrCFindFirstOrThrowArgs} args - Arguments to find a POrC
     * @example
     * // Get one POrC
     * const pOrC = await prisma.pOrC.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends POrCFindFirstOrThrowArgs>(args?: SelectSubset<T, POrCFindFirstOrThrowArgs<ExtArgs>>): Prisma__POrCClient<$Result.GetResult<Prisma.$POrCPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more POrCS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POrCFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all POrCS
     * const pOrCS = await prisma.pOrC.findMany()
     * 
     * // Get first 10 POrCS
     * const pOrCS = await prisma.pOrC.findMany({ take: 10 })
     * 
     * // Only select the `pOrCID`
     * const pOrCWithPOrCIDOnly = await prisma.pOrC.findMany({ select: { pOrCID: true } })
     * 
     */
    findMany<T extends POrCFindManyArgs>(args?: SelectSubset<T, POrCFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POrCPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a POrC.
     * @param {POrCCreateArgs} args - Arguments to create a POrC.
     * @example
     * // Create one POrC
     * const POrC = await prisma.pOrC.create({
     *   data: {
     *     // ... data to create a POrC
     *   }
     * })
     * 
     */
    create<T extends POrCCreateArgs>(args: SelectSubset<T, POrCCreateArgs<ExtArgs>>): Prisma__POrCClient<$Result.GetResult<Prisma.$POrCPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many POrCS.
     * @param {POrCCreateManyArgs} args - Arguments to create many POrCS.
     * @example
     * // Create many POrCS
     * const pOrC = await prisma.pOrC.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends POrCCreateManyArgs>(args?: SelectSubset<T, POrCCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many POrCS and returns the data saved in the database.
     * @param {POrCCreateManyAndReturnArgs} args - Arguments to create many POrCS.
     * @example
     * // Create many POrCS
     * const pOrC = await prisma.pOrC.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many POrCS and only return the `pOrCID`
     * const pOrCWithPOrCIDOnly = await prisma.pOrC.createManyAndReturn({
     *   select: { pOrCID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends POrCCreateManyAndReturnArgs>(args?: SelectSubset<T, POrCCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POrCPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a POrC.
     * @param {POrCDeleteArgs} args - Arguments to delete one POrC.
     * @example
     * // Delete one POrC
     * const POrC = await prisma.pOrC.delete({
     *   where: {
     *     // ... filter to delete one POrC
     *   }
     * })
     * 
     */
    delete<T extends POrCDeleteArgs>(args: SelectSubset<T, POrCDeleteArgs<ExtArgs>>): Prisma__POrCClient<$Result.GetResult<Prisma.$POrCPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one POrC.
     * @param {POrCUpdateArgs} args - Arguments to update one POrC.
     * @example
     * // Update one POrC
     * const pOrC = await prisma.pOrC.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends POrCUpdateArgs>(args: SelectSubset<T, POrCUpdateArgs<ExtArgs>>): Prisma__POrCClient<$Result.GetResult<Prisma.$POrCPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more POrCS.
     * @param {POrCDeleteManyArgs} args - Arguments to filter POrCS to delete.
     * @example
     * // Delete a few POrCS
     * const { count } = await prisma.pOrC.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends POrCDeleteManyArgs>(args?: SelectSubset<T, POrCDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more POrCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POrCUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many POrCS
     * const pOrC = await prisma.pOrC.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends POrCUpdateManyArgs>(args: SelectSubset<T, POrCUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more POrCS and returns the data updated in the database.
     * @param {POrCUpdateManyAndReturnArgs} args - Arguments to update many POrCS.
     * @example
     * // Update many POrCS
     * const pOrC = await prisma.pOrC.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more POrCS and only return the `pOrCID`
     * const pOrCWithPOrCIDOnly = await prisma.pOrC.updateManyAndReturn({
     *   select: { pOrCID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends POrCUpdateManyAndReturnArgs>(args: SelectSubset<T, POrCUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$POrCPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one POrC.
     * @param {POrCUpsertArgs} args - Arguments to update or create a POrC.
     * @example
     * // Update or create a POrC
     * const pOrC = await prisma.pOrC.upsert({
     *   create: {
     *     // ... data to create a POrC
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the POrC we want to update
     *   }
     * })
     */
    upsert<T extends POrCUpsertArgs>(args: SelectSubset<T, POrCUpsertArgs<ExtArgs>>): Prisma__POrCClient<$Result.GetResult<Prisma.$POrCPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of POrCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POrCCountArgs} args - Arguments to filter POrCS to count.
     * @example
     * // Count the number of POrCS
     * const count = await prisma.pOrC.count({
     *   where: {
     *     // ... the filter for the POrCS we want to count
     *   }
     * })
    **/
    count<T extends POrCCountArgs>(
      args?: Subset<T, POrCCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], POrCCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a POrC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POrCAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends POrCAggregateArgs>(args: Subset<T, POrCAggregateArgs>): Prisma.PrismaPromise<GetPOrCAggregateType<T>>

    /**
     * Group by POrC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {POrCGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends POrCGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: POrCGroupByArgs['orderBy'] }
        : { orderBy?: POrCGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, POrCGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPOrCGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the POrC model
   */
  readonly fields: POrCFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for POrC.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__POrCClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    region<T extends RegionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegionDefaultArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    cOrMs<T extends POrC$cOrMsArgs<ExtArgs> = {}>(args?: Subset<T, POrC$cOrMsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$COrMPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    addresses<T extends POrC$addressesArgs<ExtArgs> = {}>(args?: Subset<T, POrC$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the POrC model
   */ 
  interface POrCFieldRefs {
    readonly pOrCID: FieldRef<"POrC", 'Int'>
    readonly name: FieldRef<"POrC", 'String'>
    readonly id: FieldRef<"POrC", 'Int'>
    readonly regionID: FieldRef<"POrC", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * POrC findUnique
   */
  export type POrCFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POrC
     */
    select?: POrCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POrC
     */
    omit?: POrCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POrCInclude<ExtArgs> | null
    /**
     * Filter, which POrC to fetch.
     */
    where: POrCWhereUniqueInput
  }

  /**
   * POrC findUniqueOrThrow
   */
  export type POrCFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POrC
     */
    select?: POrCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POrC
     */
    omit?: POrCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POrCInclude<ExtArgs> | null
    /**
     * Filter, which POrC to fetch.
     */
    where: POrCWhereUniqueInput
  }

  /**
   * POrC findFirst
   */
  export type POrCFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POrC
     */
    select?: POrCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POrC
     */
    omit?: POrCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POrCInclude<ExtArgs> | null
    /**
     * Filter, which POrC to fetch.
     */
    where?: POrCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POrCS to fetch.
     */
    orderBy?: POrCOrderByWithRelationInput | POrCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POrCS.
     */
    cursor?: POrCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POrCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POrCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POrCS.
     */
    distinct?: POrCScalarFieldEnum | POrCScalarFieldEnum[]
  }

  /**
   * POrC findFirstOrThrow
   */
  export type POrCFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POrC
     */
    select?: POrCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POrC
     */
    omit?: POrCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POrCInclude<ExtArgs> | null
    /**
     * Filter, which POrC to fetch.
     */
    where?: POrCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POrCS to fetch.
     */
    orderBy?: POrCOrderByWithRelationInput | POrCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for POrCS.
     */
    cursor?: POrCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POrCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POrCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of POrCS.
     */
    distinct?: POrCScalarFieldEnum | POrCScalarFieldEnum[]
  }

  /**
   * POrC findMany
   */
  export type POrCFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POrC
     */
    select?: POrCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POrC
     */
    omit?: POrCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POrCInclude<ExtArgs> | null
    /**
     * Filter, which POrCS to fetch.
     */
    where?: POrCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of POrCS to fetch.
     */
    orderBy?: POrCOrderByWithRelationInput | POrCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing POrCS.
     */
    cursor?: POrCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` POrCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` POrCS.
     */
    skip?: number
    distinct?: POrCScalarFieldEnum | POrCScalarFieldEnum[]
  }

  /**
   * POrC create
   */
  export type POrCCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POrC
     */
    select?: POrCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POrC
     */
    omit?: POrCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POrCInclude<ExtArgs> | null
    /**
     * The data needed to create a POrC.
     */
    data: XOR<POrCCreateInput, POrCUncheckedCreateInput>
  }

  /**
   * POrC createMany
   */
  export type POrCCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many POrCS.
     */
    data: POrCCreateManyInput | POrCCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * POrC createManyAndReturn
   */
  export type POrCCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POrC
     */
    select?: POrCSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the POrC
     */
    omit?: POrCOmit<ExtArgs> | null
    /**
     * The data used to create many POrCS.
     */
    data: POrCCreateManyInput | POrCCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POrCIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * POrC update
   */
  export type POrCUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POrC
     */
    select?: POrCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POrC
     */
    omit?: POrCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POrCInclude<ExtArgs> | null
    /**
     * The data needed to update a POrC.
     */
    data: XOR<POrCUpdateInput, POrCUncheckedUpdateInput>
    /**
     * Choose, which POrC to update.
     */
    where: POrCWhereUniqueInput
  }

  /**
   * POrC updateMany
   */
  export type POrCUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update POrCS.
     */
    data: XOR<POrCUpdateManyMutationInput, POrCUncheckedUpdateManyInput>
    /**
     * Filter which POrCS to update
     */
    where?: POrCWhereInput
    /**
     * Limit how many POrCS to update.
     */
    limit?: number
  }

  /**
   * POrC updateManyAndReturn
   */
  export type POrCUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POrC
     */
    select?: POrCSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the POrC
     */
    omit?: POrCOmit<ExtArgs> | null
    /**
     * The data used to update POrCS.
     */
    data: XOR<POrCUpdateManyMutationInput, POrCUncheckedUpdateManyInput>
    /**
     * Filter which POrCS to update
     */
    where?: POrCWhereInput
    /**
     * Limit how many POrCS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POrCIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * POrC upsert
   */
  export type POrCUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POrC
     */
    select?: POrCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POrC
     */
    omit?: POrCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POrCInclude<ExtArgs> | null
    /**
     * The filter to search for the POrC to update in case it exists.
     */
    where: POrCWhereUniqueInput
    /**
     * In case the POrC found by the `where` argument doesn't exist, create a new POrC with this data.
     */
    create: XOR<POrCCreateInput, POrCUncheckedCreateInput>
    /**
     * In case the POrC was found with the provided `where` argument, update it with this data.
     */
    update: XOR<POrCUpdateInput, POrCUncheckedUpdateInput>
  }

  /**
   * POrC delete
   */
  export type POrCDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POrC
     */
    select?: POrCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POrC
     */
    omit?: POrCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POrCInclude<ExtArgs> | null
    /**
     * Filter which POrC to delete.
     */
    where: POrCWhereUniqueInput
  }

  /**
   * POrC deleteMany
   */
  export type POrCDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which POrCS to delete
     */
    where?: POrCWhereInput
    /**
     * Limit how many POrCS to delete.
     */
    limit?: number
  }

  /**
   * POrC.cOrMs
   */
  export type POrC$cOrMsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COrM
     */
    select?: COrMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the COrM
     */
    omit?: COrMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: COrMInclude<ExtArgs> | null
    where?: COrMWhereInput
    orderBy?: COrMOrderByWithRelationInput | COrMOrderByWithRelationInput[]
    cursor?: COrMWhereUniqueInput
    take?: number
    skip?: number
    distinct?: COrMScalarFieldEnum | COrMScalarFieldEnum[]
  }

  /**
   * POrC.addresses
   */
  export type POrC$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * POrC without action
   */
  export type POrCDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the POrC
     */
    select?: POrCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the POrC
     */
    omit?: POrCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: POrCInclude<ExtArgs> | null
  }


  /**
   * Model COrM
   */

  export type AggregateCOrM = {
    _count: COrMCountAggregateOutputType | null
    _avg: COrMAvgAggregateOutputType | null
    _sum: COrMSumAggregateOutputType | null
    _min: COrMMinAggregateOutputType | null
    _max: COrMMaxAggregateOutputType | null
  }

  export type COrMAvgAggregateOutputType = {
    cOrMID: number | null
    id: number | null
    pOrCID: number | null
  }

  export type COrMSumAggregateOutputType = {
    cOrMID: number | null
    id: number | null
    pOrCID: number | null
  }

  export type COrMMinAggregateOutputType = {
    cOrMID: number | null
    name: string | null
    id: number | null
    pOrCID: number | null
  }

  export type COrMMaxAggregateOutputType = {
    cOrMID: number | null
    name: string | null
    id: number | null
    pOrCID: number | null
  }

  export type COrMCountAggregateOutputType = {
    cOrMID: number
    name: number
    id: number
    pOrCID: number
    _all: number
  }


  export type COrMAvgAggregateInputType = {
    cOrMID?: true
    id?: true
    pOrCID?: true
  }

  export type COrMSumAggregateInputType = {
    cOrMID?: true
    id?: true
    pOrCID?: true
  }

  export type COrMMinAggregateInputType = {
    cOrMID?: true
    name?: true
    id?: true
    pOrCID?: true
  }

  export type COrMMaxAggregateInputType = {
    cOrMID?: true
    name?: true
    id?: true
    pOrCID?: true
  }

  export type COrMCountAggregateInputType = {
    cOrMID?: true
    name?: true
    id?: true
    pOrCID?: true
    _all?: true
  }

  export type COrMAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which COrM to aggregate.
     */
    where?: COrMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of COrMS to fetch.
     */
    orderBy?: COrMOrderByWithRelationInput | COrMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: COrMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` COrMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` COrMS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned COrMS
    **/
    _count?: true | COrMCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: COrMAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: COrMSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: COrMMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: COrMMaxAggregateInputType
  }

  export type GetCOrMAggregateType<T extends COrMAggregateArgs> = {
        [P in keyof T & keyof AggregateCOrM]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCOrM[P]>
      : GetScalarType<T[P], AggregateCOrM[P]>
  }




  export type COrMGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: COrMWhereInput
    orderBy?: COrMOrderByWithAggregationInput | COrMOrderByWithAggregationInput[]
    by: COrMScalarFieldEnum[] | COrMScalarFieldEnum
    having?: COrMScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: COrMCountAggregateInputType | true
    _avg?: COrMAvgAggregateInputType
    _sum?: COrMSumAggregateInputType
    _min?: COrMMinAggregateInputType
    _max?: COrMMaxAggregateInputType
  }

  export type COrMGroupByOutputType = {
    cOrMID: number
    name: string
    id: number
    pOrCID: number
    _count: COrMCountAggregateOutputType | null
    _avg: COrMAvgAggregateOutputType | null
    _sum: COrMSumAggregateOutputType | null
    _min: COrMMinAggregateOutputType | null
    _max: COrMMaxAggregateOutputType | null
  }

  type GetCOrMGroupByPayload<T extends COrMGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<COrMGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof COrMGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], COrMGroupByOutputType[P]>
            : GetScalarType<T[P], COrMGroupByOutputType[P]>
        }
      >
    >


  export type COrMSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cOrMID?: boolean
    name?: boolean
    id?: boolean
    pOrCID?: boolean
    pOrC?: boolean | POrCDefaultArgs<ExtArgs>
    brgys?: boolean | COrM$brgysArgs<ExtArgs>
    addresses?: boolean | COrM$addressesArgs<ExtArgs>
    _count?: boolean | COrMCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cOrM"]>

  export type COrMSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cOrMID?: boolean
    name?: boolean
    id?: boolean
    pOrCID?: boolean
    pOrC?: boolean | POrCDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cOrM"]>

  export type COrMSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cOrMID?: boolean
    name?: boolean
    id?: boolean
    pOrCID?: boolean
    pOrC?: boolean | POrCDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cOrM"]>

  export type COrMSelectScalar = {
    cOrMID?: boolean
    name?: boolean
    id?: boolean
    pOrCID?: boolean
  }

  export type COrMOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cOrMID" | "name" | "id" | "pOrCID", ExtArgs["result"]["cOrM"]>
  export type COrMInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pOrC?: boolean | POrCDefaultArgs<ExtArgs>
    brgys?: boolean | COrM$brgysArgs<ExtArgs>
    addresses?: boolean | COrM$addressesArgs<ExtArgs>
    _count?: boolean | COrMCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type COrMIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pOrC?: boolean | POrCDefaultArgs<ExtArgs>
  }
  export type COrMIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pOrC?: boolean | POrCDefaultArgs<ExtArgs>
  }

  export type $COrMPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "COrM"
    objects: {
      pOrC: Prisma.$POrCPayload<ExtArgs>
      brgys: Prisma.$BrgyPayload<ExtArgs>[]
      addresses: Prisma.$AddressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      cOrMID: number
      name: string
      id: number
      pOrCID: number
    }, ExtArgs["result"]["cOrM"]>
    composites: {}
  }

  type COrMGetPayload<S extends boolean | null | undefined | COrMDefaultArgs> = $Result.GetResult<Prisma.$COrMPayload, S>

  type COrMCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<COrMFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: COrMCountAggregateInputType | true
    }

  export interface COrMDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['COrM'], meta: { name: 'COrM' } }
    /**
     * Find zero or one COrM that matches the filter.
     * @param {COrMFindUniqueArgs} args - Arguments to find a COrM
     * @example
     * // Get one COrM
     * const cOrM = await prisma.cOrM.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends COrMFindUniqueArgs>(args: SelectSubset<T, COrMFindUniqueArgs<ExtArgs>>): Prisma__COrMClient<$Result.GetResult<Prisma.$COrMPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one COrM that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {COrMFindUniqueOrThrowArgs} args - Arguments to find a COrM
     * @example
     * // Get one COrM
     * const cOrM = await prisma.cOrM.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends COrMFindUniqueOrThrowArgs>(args: SelectSubset<T, COrMFindUniqueOrThrowArgs<ExtArgs>>): Prisma__COrMClient<$Result.GetResult<Prisma.$COrMPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first COrM that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {COrMFindFirstArgs} args - Arguments to find a COrM
     * @example
     * // Get one COrM
     * const cOrM = await prisma.cOrM.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends COrMFindFirstArgs>(args?: SelectSubset<T, COrMFindFirstArgs<ExtArgs>>): Prisma__COrMClient<$Result.GetResult<Prisma.$COrMPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first COrM that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {COrMFindFirstOrThrowArgs} args - Arguments to find a COrM
     * @example
     * // Get one COrM
     * const cOrM = await prisma.cOrM.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends COrMFindFirstOrThrowArgs>(args?: SelectSubset<T, COrMFindFirstOrThrowArgs<ExtArgs>>): Prisma__COrMClient<$Result.GetResult<Prisma.$COrMPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more COrMS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {COrMFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all COrMS
     * const cOrMS = await prisma.cOrM.findMany()
     * 
     * // Get first 10 COrMS
     * const cOrMS = await prisma.cOrM.findMany({ take: 10 })
     * 
     * // Only select the `cOrMID`
     * const cOrMWithCOrMIDOnly = await prisma.cOrM.findMany({ select: { cOrMID: true } })
     * 
     */
    findMany<T extends COrMFindManyArgs>(args?: SelectSubset<T, COrMFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$COrMPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a COrM.
     * @param {COrMCreateArgs} args - Arguments to create a COrM.
     * @example
     * // Create one COrM
     * const COrM = await prisma.cOrM.create({
     *   data: {
     *     // ... data to create a COrM
     *   }
     * })
     * 
     */
    create<T extends COrMCreateArgs>(args: SelectSubset<T, COrMCreateArgs<ExtArgs>>): Prisma__COrMClient<$Result.GetResult<Prisma.$COrMPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many COrMS.
     * @param {COrMCreateManyArgs} args - Arguments to create many COrMS.
     * @example
     * // Create many COrMS
     * const cOrM = await prisma.cOrM.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends COrMCreateManyArgs>(args?: SelectSubset<T, COrMCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many COrMS and returns the data saved in the database.
     * @param {COrMCreateManyAndReturnArgs} args - Arguments to create many COrMS.
     * @example
     * // Create many COrMS
     * const cOrM = await prisma.cOrM.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many COrMS and only return the `cOrMID`
     * const cOrMWithCOrMIDOnly = await prisma.cOrM.createManyAndReturn({
     *   select: { cOrMID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends COrMCreateManyAndReturnArgs>(args?: SelectSubset<T, COrMCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$COrMPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a COrM.
     * @param {COrMDeleteArgs} args - Arguments to delete one COrM.
     * @example
     * // Delete one COrM
     * const COrM = await prisma.cOrM.delete({
     *   where: {
     *     // ... filter to delete one COrM
     *   }
     * })
     * 
     */
    delete<T extends COrMDeleteArgs>(args: SelectSubset<T, COrMDeleteArgs<ExtArgs>>): Prisma__COrMClient<$Result.GetResult<Prisma.$COrMPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one COrM.
     * @param {COrMUpdateArgs} args - Arguments to update one COrM.
     * @example
     * // Update one COrM
     * const cOrM = await prisma.cOrM.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends COrMUpdateArgs>(args: SelectSubset<T, COrMUpdateArgs<ExtArgs>>): Prisma__COrMClient<$Result.GetResult<Prisma.$COrMPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more COrMS.
     * @param {COrMDeleteManyArgs} args - Arguments to filter COrMS to delete.
     * @example
     * // Delete a few COrMS
     * const { count } = await prisma.cOrM.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends COrMDeleteManyArgs>(args?: SelectSubset<T, COrMDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more COrMS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {COrMUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many COrMS
     * const cOrM = await prisma.cOrM.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends COrMUpdateManyArgs>(args: SelectSubset<T, COrMUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more COrMS and returns the data updated in the database.
     * @param {COrMUpdateManyAndReturnArgs} args - Arguments to update many COrMS.
     * @example
     * // Update many COrMS
     * const cOrM = await prisma.cOrM.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more COrMS and only return the `cOrMID`
     * const cOrMWithCOrMIDOnly = await prisma.cOrM.updateManyAndReturn({
     *   select: { cOrMID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends COrMUpdateManyAndReturnArgs>(args: SelectSubset<T, COrMUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$COrMPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one COrM.
     * @param {COrMUpsertArgs} args - Arguments to update or create a COrM.
     * @example
     * // Update or create a COrM
     * const cOrM = await prisma.cOrM.upsert({
     *   create: {
     *     // ... data to create a COrM
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the COrM we want to update
     *   }
     * })
     */
    upsert<T extends COrMUpsertArgs>(args: SelectSubset<T, COrMUpsertArgs<ExtArgs>>): Prisma__COrMClient<$Result.GetResult<Prisma.$COrMPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of COrMS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {COrMCountArgs} args - Arguments to filter COrMS to count.
     * @example
     * // Count the number of COrMS
     * const count = await prisma.cOrM.count({
     *   where: {
     *     // ... the filter for the COrMS we want to count
     *   }
     * })
    **/
    count<T extends COrMCountArgs>(
      args?: Subset<T, COrMCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], COrMCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a COrM.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {COrMAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends COrMAggregateArgs>(args: Subset<T, COrMAggregateArgs>): Prisma.PrismaPromise<GetCOrMAggregateType<T>>

    /**
     * Group by COrM.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {COrMGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends COrMGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: COrMGroupByArgs['orderBy'] }
        : { orderBy?: COrMGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, COrMGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCOrMGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the COrM model
   */
  readonly fields: COrMFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for COrM.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__COrMClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pOrC<T extends POrCDefaultArgs<ExtArgs> = {}>(args?: Subset<T, POrCDefaultArgs<ExtArgs>>): Prisma__POrCClient<$Result.GetResult<Prisma.$POrCPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    brgys<T extends COrM$brgysArgs<ExtArgs> = {}>(args?: Subset<T, COrM$brgysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrgyPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    addresses<T extends COrM$addressesArgs<ExtArgs> = {}>(args?: Subset<T, COrM$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the COrM model
   */ 
  interface COrMFieldRefs {
    readonly cOrMID: FieldRef<"COrM", 'Int'>
    readonly name: FieldRef<"COrM", 'String'>
    readonly id: FieldRef<"COrM", 'Int'>
    readonly pOrCID: FieldRef<"COrM", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * COrM findUnique
   */
  export type COrMFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COrM
     */
    select?: COrMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the COrM
     */
    omit?: COrMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: COrMInclude<ExtArgs> | null
    /**
     * Filter, which COrM to fetch.
     */
    where: COrMWhereUniqueInput
  }

  /**
   * COrM findUniqueOrThrow
   */
  export type COrMFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COrM
     */
    select?: COrMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the COrM
     */
    omit?: COrMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: COrMInclude<ExtArgs> | null
    /**
     * Filter, which COrM to fetch.
     */
    where: COrMWhereUniqueInput
  }

  /**
   * COrM findFirst
   */
  export type COrMFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COrM
     */
    select?: COrMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the COrM
     */
    omit?: COrMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: COrMInclude<ExtArgs> | null
    /**
     * Filter, which COrM to fetch.
     */
    where?: COrMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of COrMS to fetch.
     */
    orderBy?: COrMOrderByWithRelationInput | COrMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for COrMS.
     */
    cursor?: COrMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` COrMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` COrMS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of COrMS.
     */
    distinct?: COrMScalarFieldEnum | COrMScalarFieldEnum[]
  }

  /**
   * COrM findFirstOrThrow
   */
  export type COrMFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COrM
     */
    select?: COrMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the COrM
     */
    omit?: COrMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: COrMInclude<ExtArgs> | null
    /**
     * Filter, which COrM to fetch.
     */
    where?: COrMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of COrMS to fetch.
     */
    orderBy?: COrMOrderByWithRelationInput | COrMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for COrMS.
     */
    cursor?: COrMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` COrMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` COrMS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of COrMS.
     */
    distinct?: COrMScalarFieldEnum | COrMScalarFieldEnum[]
  }

  /**
   * COrM findMany
   */
  export type COrMFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COrM
     */
    select?: COrMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the COrM
     */
    omit?: COrMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: COrMInclude<ExtArgs> | null
    /**
     * Filter, which COrMS to fetch.
     */
    where?: COrMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of COrMS to fetch.
     */
    orderBy?: COrMOrderByWithRelationInput | COrMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing COrMS.
     */
    cursor?: COrMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` COrMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` COrMS.
     */
    skip?: number
    distinct?: COrMScalarFieldEnum | COrMScalarFieldEnum[]
  }

  /**
   * COrM create
   */
  export type COrMCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COrM
     */
    select?: COrMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the COrM
     */
    omit?: COrMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: COrMInclude<ExtArgs> | null
    /**
     * The data needed to create a COrM.
     */
    data: XOR<COrMCreateInput, COrMUncheckedCreateInput>
  }

  /**
   * COrM createMany
   */
  export type COrMCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many COrMS.
     */
    data: COrMCreateManyInput | COrMCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * COrM createManyAndReturn
   */
  export type COrMCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COrM
     */
    select?: COrMSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the COrM
     */
    omit?: COrMOmit<ExtArgs> | null
    /**
     * The data used to create many COrMS.
     */
    data: COrMCreateManyInput | COrMCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: COrMIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * COrM update
   */
  export type COrMUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COrM
     */
    select?: COrMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the COrM
     */
    omit?: COrMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: COrMInclude<ExtArgs> | null
    /**
     * The data needed to update a COrM.
     */
    data: XOR<COrMUpdateInput, COrMUncheckedUpdateInput>
    /**
     * Choose, which COrM to update.
     */
    where: COrMWhereUniqueInput
  }

  /**
   * COrM updateMany
   */
  export type COrMUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update COrMS.
     */
    data: XOR<COrMUpdateManyMutationInput, COrMUncheckedUpdateManyInput>
    /**
     * Filter which COrMS to update
     */
    where?: COrMWhereInput
    /**
     * Limit how many COrMS to update.
     */
    limit?: number
  }

  /**
   * COrM updateManyAndReturn
   */
  export type COrMUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COrM
     */
    select?: COrMSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the COrM
     */
    omit?: COrMOmit<ExtArgs> | null
    /**
     * The data used to update COrMS.
     */
    data: XOR<COrMUpdateManyMutationInput, COrMUncheckedUpdateManyInput>
    /**
     * Filter which COrMS to update
     */
    where?: COrMWhereInput
    /**
     * Limit how many COrMS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: COrMIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * COrM upsert
   */
  export type COrMUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COrM
     */
    select?: COrMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the COrM
     */
    omit?: COrMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: COrMInclude<ExtArgs> | null
    /**
     * The filter to search for the COrM to update in case it exists.
     */
    where: COrMWhereUniqueInput
    /**
     * In case the COrM found by the `where` argument doesn't exist, create a new COrM with this data.
     */
    create: XOR<COrMCreateInput, COrMUncheckedCreateInput>
    /**
     * In case the COrM was found with the provided `where` argument, update it with this data.
     */
    update: XOR<COrMUpdateInput, COrMUncheckedUpdateInput>
  }

  /**
   * COrM delete
   */
  export type COrMDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COrM
     */
    select?: COrMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the COrM
     */
    omit?: COrMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: COrMInclude<ExtArgs> | null
    /**
     * Filter which COrM to delete.
     */
    where: COrMWhereUniqueInput
  }

  /**
   * COrM deleteMany
   */
  export type COrMDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which COrMS to delete
     */
    where?: COrMWhereInput
    /**
     * Limit how many COrMS to delete.
     */
    limit?: number
  }

  /**
   * COrM.brgys
   */
  export type COrM$brgysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brgy
     */
    select?: BrgySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brgy
     */
    omit?: BrgyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrgyInclude<ExtArgs> | null
    where?: BrgyWhereInput
    orderBy?: BrgyOrderByWithRelationInput | BrgyOrderByWithRelationInput[]
    cursor?: BrgyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BrgyScalarFieldEnum | BrgyScalarFieldEnum[]
  }

  /**
   * COrM.addresses
   */
  export type COrM$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * COrM without action
   */
  export type COrMDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the COrM
     */
    select?: COrMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the COrM
     */
    omit?: COrMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: COrMInclude<ExtArgs> | null
  }


  /**
   * Model Brgy
   */

  export type AggregateBrgy = {
    _count: BrgyCountAggregateOutputType | null
    _avg: BrgyAvgAggregateOutputType | null
    _sum: BrgySumAggregateOutputType | null
    _min: BrgyMinAggregateOutputType | null
    _max: BrgyMaxAggregateOutputType | null
  }

  export type BrgyAvgAggregateOutputType = {
    brgyID: number | null
    id: number | null
    cOrMID: number | null
  }

  export type BrgySumAggregateOutputType = {
    brgyID: number | null
    id: number | null
    cOrMID: number | null
  }

  export type BrgyMinAggregateOutputType = {
    brgyID: number | null
    name: string | null
    id: number | null
    cOrMID: number | null
  }

  export type BrgyMaxAggregateOutputType = {
    brgyID: number | null
    name: string | null
    id: number | null
    cOrMID: number | null
  }

  export type BrgyCountAggregateOutputType = {
    brgyID: number
    name: number
    id: number
    cOrMID: number
    _all: number
  }


  export type BrgyAvgAggregateInputType = {
    brgyID?: true
    id?: true
    cOrMID?: true
  }

  export type BrgySumAggregateInputType = {
    brgyID?: true
    id?: true
    cOrMID?: true
  }

  export type BrgyMinAggregateInputType = {
    brgyID?: true
    name?: true
    id?: true
    cOrMID?: true
  }

  export type BrgyMaxAggregateInputType = {
    brgyID?: true
    name?: true
    id?: true
    cOrMID?: true
  }

  export type BrgyCountAggregateInputType = {
    brgyID?: true
    name?: true
    id?: true
    cOrMID?: true
    _all?: true
  }

  export type BrgyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brgy to aggregate.
     */
    where?: BrgyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brgies to fetch.
     */
    orderBy?: BrgyOrderByWithRelationInput | BrgyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BrgyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brgies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brgies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Brgies
    **/
    _count?: true | BrgyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BrgyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BrgySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrgyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrgyMaxAggregateInputType
  }

  export type GetBrgyAggregateType<T extends BrgyAggregateArgs> = {
        [P in keyof T & keyof AggregateBrgy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrgy[P]>
      : GetScalarType<T[P], AggregateBrgy[P]>
  }




  export type BrgyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrgyWhereInput
    orderBy?: BrgyOrderByWithAggregationInput | BrgyOrderByWithAggregationInput[]
    by: BrgyScalarFieldEnum[] | BrgyScalarFieldEnum
    having?: BrgyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrgyCountAggregateInputType | true
    _avg?: BrgyAvgAggregateInputType
    _sum?: BrgySumAggregateInputType
    _min?: BrgyMinAggregateInputType
    _max?: BrgyMaxAggregateInputType
  }

  export type BrgyGroupByOutputType = {
    brgyID: number
    name: string
    id: number
    cOrMID: number
    _count: BrgyCountAggregateOutputType | null
    _avg: BrgyAvgAggregateOutputType | null
    _sum: BrgySumAggregateOutputType | null
    _min: BrgyMinAggregateOutputType | null
    _max: BrgyMaxAggregateOutputType | null
  }

  type GetBrgyGroupByPayload<T extends BrgyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrgyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrgyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrgyGroupByOutputType[P]>
            : GetScalarType<T[P], BrgyGroupByOutputType[P]>
        }
      >
    >


  export type BrgySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    brgyID?: boolean
    name?: boolean
    id?: boolean
    cOrMID?: boolean
    cOrM?: boolean | COrMDefaultArgs<ExtArgs>
    addresses?: boolean | Brgy$addressesArgs<ExtArgs>
    _count?: boolean | BrgyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brgy"]>

  export type BrgySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    brgyID?: boolean
    name?: boolean
    id?: boolean
    cOrMID?: boolean
    cOrM?: boolean | COrMDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brgy"]>

  export type BrgySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    brgyID?: boolean
    name?: boolean
    id?: boolean
    cOrMID?: boolean
    cOrM?: boolean | COrMDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brgy"]>

  export type BrgySelectScalar = {
    brgyID?: boolean
    name?: boolean
    id?: boolean
    cOrMID?: boolean
  }

  export type BrgyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"brgyID" | "name" | "id" | "cOrMID", ExtArgs["result"]["brgy"]>
  export type BrgyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cOrM?: boolean | COrMDefaultArgs<ExtArgs>
    addresses?: boolean | Brgy$addressesArgs<ExtArgs>
    _count?: boolean | BrgyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BrgyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cOrM?: boolean | COrMDefaultArgs<ExtArgs>
  }
  export type BrgyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cOrM?: boolean | COrMDefaultArgs<ExtArgs>
  }

  export type $BrgyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Brgy"
    objects: {
      cOrM: Prisma.$COrMPayload<ExtArgs>
      addresses: Prisma.$AddressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      brgyID: number
      name: string
      id: number
      cOrMID: number
    }, ExtArgs["result"]["brgy"]>
    composites: {}
  }

  type BrgyGetPayload<S extends boolean | null | undefined | BrgyDefaultArgs> = $Result.GetResult<Prisma.$BrgyPayload, S>

  type BrgyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BrgyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BrgyCountAggregateInputType | true
    }

  export interface BrgyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Brgy'], meta: { name: 'Brgy' } }
    /**
     * Find zero or one Brgy that matches the filter.
     * @param {BrgyFindUniqueArgs} args - Arguments to find a Brgy
     * @example
     * // Get one Brgy
     * const brgy = await prisma.brgy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BrgyFindUniqueArgs>(args: SelectSubset<T, BrgyFindUniqueArgs<ExtArgs>>): Prisma__BrgyClient<$Result.GetResult<Prisma.$BrgyPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Brgy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BrgyFindUniqueOrThrowArgs} args - Arguments to find a Brgy
     * @example
     * // Get one Brgy
     * const brgy = await prisma.brgy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BrgyFindUniqueOrThrowArgs>(args: SelectSubset<T, BrgyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BrgyClient<$Result.GetResult<Prisma.$BrgyPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Brgy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrgyFindFirstArgs} args - Arguments to find a Brgy
     * @example
     * // Get one Brgy
     * const brgy = await prisma.brgy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BrgyFindFirstArgs>(args?: SelectSubset<T, BrgyFindFirstArgs<ExtArgs>>): Prisma__BrgyClient<$Result.GetResult<Prisma.$BrgyPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Brgy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrgyFindFirstOrThrowArgs} args - Arguments to find a Brgy
     * @example
     * // Get one Brgy
     * const brgy = await prisma.brgy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BrgyFindFirstOrThrowArgs>(args?: SelectSubset<T, BrgyFindFirstOrThrowArgs<ExtArgs>>): Prisma__BrgyClient<$Result.GetResult<Prisma.$BrgyPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Brgies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrgyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brgies
     * const brgies = await prisma.brgy.findMany()
     * 
     * // Get first 10 Brgies
     * const brgies = await prisma.brgy.findMany({ take: 10 })
     * 
     * // Only select the `brgyID`
     * const brgyWithBrgyIDOnly = await prisma.brgy.findMany({ select: { brgyID: true } })
     * 
     */
    findMany<T extends BrgyFindManyArgs>(args?: SelectSubset<T, BrgyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrgyPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Brgy.
     * @param {BrgyCreateArgs} args - Arguments to create a Brgy.
     * @example
     * // Create one Brgy
     * const Brgy = await prisma.brgy.create({
     *   data: {
     *     // ... data to create a Brgy
     *   }
     * })
     * 
     */
    create<T extends BrgyCreateArgs>(args: SelectSubset<T, BrgyCreateArgs<ExtArgs>>): Prisma__BrgyClient<$Result.GetResult<Prisma.$BrgyPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Brgies.
     * @param {BrgyCreateManyArgs} args - Arguments to create many Brgies.
     * @example
     * // Create many Brgies
     * const brgy = await prisma.brgy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BrgyCreateManyArgs>(args?: SelectSubset<T, BrgyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Brgies and returns the data saved in the database.
     * @param {BrgyCreateManyAndReturnArgs} args - Arguments to create many Brgies.
     * @example
     * // Create many Brgies
     * const brgy = await prisma.brgy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Brgies and only return the `brgyID`
     * const brgyWithBrgyIDOnly = await prisma.brgy.createManyAndReturn({
     *   select: { brgyID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BrgyCreateManyAndReturnArgs>(args?: SelectSubset<T, BrgyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrgyPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Brgy.
     * @param {BrgyDeleteArgs} args - Arguments to delete one Brgy.
     * @example
     * // Delete one Brgy
     * const Brgy = await prisma.brgy.delete({
     *   where: {
     *     // ... filter to delete one Brgy
     *   }
     * })
     * 
     */
    delete<T extends BrgyDeleteArgs>(args: SelectSubset<T, BrgyDeleteArgs<ExtArgs>>): Prisma__BrgyClient<$Result.GetResult<Prisma.$BrgyPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Brgy.
     * @param {BrgyUpdateArgs} args - Arguments to update one Brgy.
     * @example
     * // Update one Brgy
     * const brgy = await prisma.brgy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BrgyUpdateArgs>(args: SelectSubset<T, BrgyUpdateArgs<ExtArgs>>): Prisma__BrgyClient<$Result.GetResult<Prisma.$BrgyPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Brgies.
     * @param {BrgyDeleteManyArgs} args - Arguments to filter Brgies to delete.
     * @example
     * // Delete a few Brgies
     * const { count } = await prisma.brgy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BrgyDeleteManyArgs>(args?: SelectSubset<T, BrgyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brgies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrgyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brgies
     * const brgy = await prisma.brgy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BrgyUpdateManyArgs>(args: SelectSubset<T, BrgyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brgies and returns the data updated in the database.
     * @param {BrgyUpdateManyAndReturnArgs} args - Arguments to update many Brgies.
     * @example
     * // Update many Brgies
     * const brgy = await prisma.brgy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Brgies and only return the `brgyID`
     * const brgyWithBrgyIDOnly = await prisma.brgy.updateManyAndReturn({
     *   select: { brgyID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BrgyUpdateManyAndReturnArgs>(args: SelectSubset<T, BrgyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrgyPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Brgy.
     * @param {BrgyUpsertArgs} args - Arguments to update or create a Brgy.
     * @example
     * // Update or create a Brgy
     * const brgy = await prisma.brgy.upsert({
     *   create: {
     *     // ... data to create a Brgy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brgy we want to update
     *   }
     * })
     */
    upsert<T extends BrgyUpsertArgs>(args: SelectSubset<T, BrgyUpsertArgs<ExtArgs>>): Prisma__BrgyClient<$Result.GetResult<Prisma.$BrgyPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Brgies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrgyCountArgs} args - Arguments to filter Brgies to count.
     * @example
     * // Count the number of Brgies
     * const count = await prisma.brgy.count({
     *   where: {
     *     // ... the filter for the Brgies we want to count
     *   }
     * })
    **/
    count<T extends BrgyCountArgs>(
      args?: Subset<T, BrgyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrgyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brgy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrgyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrgyAggregateArgs>(args: Subset<T, BrgyAggregateArgs>): Prisma.PrismaPromise<GetBrgyAggregateType<T>>

    /**
     * Group by Brgy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrgyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BrgyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BrgyGroupByArgs['orderBy'] }
        : { orderBy?: BrgyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BrgyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrgyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Brgy model
   */
  readonly fields: BrgyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Brgy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BrgyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cOrM<T extends COrMDefaultArgs<ExtArgs> = {}>(args?: Subset<T, COrMDefaultArgs<ExtArgs>>): Prisma__COrMClient<$Result.GetResult<Prisma.$COrMPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    addresses<T extends Brgy$addressesArgs<ExtArgs> = {}>(args?: Subset<T, Brgy$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Brgy model
   */ 
  interface BrgyFieldRefs {
    readonly brgyID: FieldRef<"Brgy", 'Int'>
    readonly name: FieldRef<"Brgy", 'String'>
    readonly id: FieldRef<"Brgy", 'Int'>
    readonly cOrMID: FieldRef<"Brgy", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Brgy findUnique
   */
  export type BrgyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brgy
     */
    select?: BrgySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brgy
     */
    omit?: BrgyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrgyInclude<ExtArgs> | null
    /**
     * Filter, which Brgy to fetch.
     */
    where: BrgyWhereUniqueInput
  }

  /**
   * Brgy findUniqueOrThrow
   */
  export type BrgyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brgy
     */
    select?: BrgySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brgy
     */
    omit?: BrgyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrgyInclude<ExtArgs> | null
    /**
     * Filter, which Brgy to fetch.
     */
    where: BrgyWhereUniqueInput
  }

  /**
   * Brgy findFirst
   */
  export type BrgyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brgy
     */
    select?: BrgySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brgy
     */
    omit?: BrgyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrgyInclude<ExtArgs> | null
    /**
     * Filter, which Brgy to fetch.
     */
    where?: BrgyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brgies to fetch.
     */
    orderBy?: BrgyOrderByWithRelationInput | BrgyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brgies.
     */
    cursor?: BrgyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brgies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brgies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brgies.
     */
    distinct?: BrgyScalarFieldEnum | BrgyScalarFieldEnum[]
  }

  /**
   * Brgy findFirstOrThrow
   */
  export type BrgyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brgy
     */
    select?: BrgySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brgy
     */
    omit?: BrgyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrgyInclude<ExtArgs> | null
    /**
     * Filter, which Brgy to fetch.
     */
    where?: BrgyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brgies to fetch.
     */
    orderBy?: BrgyOrderByWithRelationInput | BrgyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brgies.
     */
    cursor?: BrgyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brgies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brgies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brgies.
     */
    distinct?: BrgyScalarFieldEnum | BrgyScalarFieldEnum[]
  }

  /**
   * Brgy findMany
   */
  export type BrgyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brgy
     */
    select?: BrgySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brgy
     */
    omit?: BrgyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrgyInclude<ExtArgs> | null
    /**
     * Filter, which Brgies to fetch.
     */
    where?: BrgyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brgies to fetch.
     */
    orderBy?: BrgyOrderByWithRelationInput | BrgyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Brgies.
     */
    cursor?: BrgyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brgies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brgies.
     */
    skip?: number
    distinct?: BrgyScalarFieldEnum | BrgyScalarFieldEnum[]
  }

  /**
   * Brgy create
   */
  export type BrgyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brgy
     */
    select?: BrgySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brgy
     */
    omit?: BrgyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrgyInclude<ExtArgs> | null
    /**
     * The data needed to create a Brgy.
     */
    data: XOR<BrgyCreateInput, BrgyUncheckedCreateInput>
  }

  /**
   * Brgy createMany
   */
  export type BrgyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Brgies.
     */
    data: BrgyCreateManyInput | BrgyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Brgy createManyAndReturn
   */
  export type BrgyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brgy
     */
    select?: BrgySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Brgy
     */
    omit?: BrgyOmit<ExtArgs> | null
    /**
     * The data used to create many Brgies.
     */
    data: BrgyCreateManyInput | BrgyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrgyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Brgy update
   */
  export type BrgyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brgy
     */
    select?: BrgySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brgy
     */
    omit?: BrgyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrgyInclude<ExtArgs> | null
    /**
     * The data needed to update a Brgy.
     */
    data: XOR<BrgyUpdateInput, BrgyUncheckedUpdateInput>
    /**
     * Choose, which Brgy to update.
     */
    where: BrgyWhereUniqueInput
  }

  /**
   * Brgy updateMany
   */
  export type BrgyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Brgies.
     */
    data: XOR<BrgyUpdateManyMutationInput, BrgyUncheckedUpdateManyInput>
    /**
     * Filter which Brgies to update
     */
    where?: BrgyWhereInput
    /**
     * Limit how many Brgies to update.
     */
    limit?: number
  }

  /**
   * Brgy updateManyAndReturn
   */
  export type BrgyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brgy
     */
    select?: BrgySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Brgy
     */
    omit?: BrgyOmit<ExtArgs> | null
    /**
     * The data used to update Brgies.
     */
    data: XOR<BrgyUpdateManyMutationInput, BrgyUncheckedUpdateManyInput>
    /**
     * Filter which Brgies to update
     */
    where?: BrgyWhereInput
    /**
     * Limit how many Brgies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrgyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Brgy upsert
   */
  export type BrgyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brgy
     */
    select?: BrgySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brgy
     */
    omit?: BrgyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrgyInclude<ExtArgs> | null
    /**
     * The filter to search for the Brgy to update in case it exists.
     */
    where: BrgyWhereUniqueInput
    /**
     * In case the Brgy found by the `where` argument doesn't exist, create a new Brgy with this data.
     */
    create: XOR<BrgyCreateInput, BrgyUncheckedCreateInput>
    /**
     * In case the Brgy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BrgyUpdateInput, BrgyUncheckedUpdateInput>
  }

  /**
   * Brgy delete
   */
  export type BrgyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brgy
     */
    select?: BrgySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brgy
     */
    omit?: BrgyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrgyInclude<ExtArgs> | null
    /**
     * Filter which Brgy to delete.
     */
    where: BrgyWhereUniqueInput
  }

  /**
   * Brgy deleteMany
   */
  export type BrgyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brgies to delete
     */
    where?: BrgyWhereInput
    /**
     * Limit how many Brgies to delete.
     */
    limit?: number
  }

  /**
   * Brgy.addresses
   */
  export type Brgy$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Brgy without action
   */
  export type BrgyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brgy
     */
    select?: BrgySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brgy
     */
    omit?: BrgyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrgyInclude<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressAvgAggregateOutputType = {
    regionID: number | null
    pOrCID: number | null
    cOrMID: number | null
    brgyID: number | null
  }

  export type AddressSumAggregateOutputType = {
    regionID: number | null
    pOrCID: number | null
    cOrMID: number | null
    brgyID: number | null
  }

  export type AddressMinAggregateOutputType = {
    regionID: number | null
    pOrCID: number | null
    cOrMID: number | null
    brgyID: number | null
    street: string | null
    facilityID: string | null
  }

  export type AddressMaxAggregateOutputType = {
    regionID: number | null
    pOrCID: number | null
    cOrMID: number | null
    brgyID: number | null
    street: string | null
    facilityID: string | null
  }

  export type AddressCountAggregateOutputType = {
    regionID: number
    pOrCID: number
    cOrMID: number
    brgyID: number
    street: number
    facilityID: number
    _all: number
  }


  export type AddressAvgAggregateInputType = {
    regionID?: true
    pOrCID?: true
    cOrMID?: true
    brgyID?: true
  }

  export type AddressSumAggregateInputType = {
    regionID?: true
    pOrCID?: true
    cOrMID?: true
    brgyID?: true
  }

  export type AddressMinAggregateInputType = {
    regionID?: true
    pOrCID?: true
    cOrMID?: true
    brgyID?: true
    street?: true
    facilityID?: true
  }

  export type AddressMaxAggregateInputType = {
    regionID?: true
    pOrCID?: true
    cOrMID?: true
    brgyID?: true
    street?: true
    facilityID?: true
  }

  export type AddressCountAggregateInputType = {
    regionID?: true
    pOrCID?: true
    cOrMID?: true
    brgyID?: true
    street?: true
    facilityID?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _avg?: AddressAvgAggregateInputType
    _sum?: AddressSumAggregateInputType
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    regionID: number
    pOrCID: number
    cOrMID: number
    brgyID: number
    street: string
    facilityID: string
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    regionID?: boolean
    pOrCID?: boolean
    cOrMID?: boolean
    brgyID?: boolean
    street?: boolean
    facilityID?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
    pOrC?: boolean | POrCDefaultArgs<ExtArgs>
    cOrM?: boolean | COrMDefaultArgs<ExtArgs>
    brgy?: boolean | BrgyDefaultArgs<ExtArgs>
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    regionID?: boolean
    pOrCID?: boolean
    cOrMID?: boolean
    brgyID?: boolean
    street?: boolean
    facilityID?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
    pOrC?: boolean | POrCDefaultArgs<ExtArgs>
    cOrM?: boolean | COrMDefaultArgs<ExtArgs>
    brgy?: boolean | BrgyDefaultArgs<ExtArgs>
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    regionID?: boolean
    pOrCID?: boolean
    cOrMID?: boolean
    brgyID?: boolean
    street?: boolean
    facilityID?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
    pOrC?: boolean | POrCDefaultArgs<ExtArgs>
    cOrM?: boolean | COrMDefaultArgs<ExtArgs>
    brgy?: boolean | BrgyDefaultArgs<ExtArgs>
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    regionID?: boolean
    pOrCID?: boolean
    cOrMID?: boolean
    brgyID?: boolean
    street?: boolean
    facilityID?: boolean
  }

  export type AddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"regionID" | "pOrCID" | "cOrMID" | "brgyID" | "street" | "facilityID", ExtArgs["result"]["address"]>
  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
    pOrC?: boolean | POrCDefaultArgs<ExtArgs>
    cOrM?: boolean | COrMDefaultArgs<ExtArgs>
    brgy?: boolean | BrgyDefaultArgs<ExtArgs>
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
    pOrC?: boolean | POrCDefaultArgs<ExtArgs>
    cOrM?: boolean | COrMDefaultArgs<ExtArgs>
    brgy?: boolean | BrgyDefaultArgs<ExtArgs>
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }
  export type AddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
    pOrC?: boolean | POrCDefaultArgs<ExtArgs>
    cOrM?: boolean | COrMDefaultArgs<ExtArgs>
    brgy?: boolean | BrgyDefaultArgs<ExtArgs>
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      region: Prisma.$RegionPayload<ExtArgs>
      pOrC: Prisma.$POrCPayload<ExtArgs>
      cOrM: Prisma.$COrMPayload<ExtArgs>
      brgy: Prisma.$BrgyPayload<ExtArgs>
      facility: Prisma.$FacilityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      regionID: number
      pOrCID: number
      cOrMID: number
      brgyID: number
      street: string
      facilityID: string
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `regionID`
     * const addressWithRegionIDOnly = await prisma.address.findMany({ select: { regionID: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `regionID`
     * const addressWithRegionIDOnly = await prisma.address.createManyAndReturn({
     *   select: { regionID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses and returns the data updated in the database.
     * @param {AddressUpdateManyAndReturnArgs} args - Arguments to update many Addresses.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addresses and only return the `regionID`
     * const addressWithRegionIDOnly = await prisma.address.updateManyAndReturn({
     *   select: { regionID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddressUpdateManyAndReturnArgs>(args: SelectSubset<T, AddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    region<T extends RegionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegionDefaultArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    pOrC<T extends POrCDefaultArgs<ExtArgs> = {}>(args?: Subset<T, POrCDefaultArgs<ExtArgs>>): Prisma__POrCClient<$Result.GetResult<Prisma.$POrCPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    cOrM<T extends COrMDefaultArgs<ExtArgs> = {}>(args?: Subset<T, COrMDefaultArgs<ExtArgs>>): Prisma__COrMClient<$Result.GetResult<Prisma.$COrMPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    brgy<T extends BrgyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BrgyDefaultArgs<ExtArgs>>): Prisma__BrgyClient<$Result.GetResult<Prisma.$BrgyPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    facility<T extends FacilityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacilityDefaultArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */ 
  interface AddressFieldRefs {
    readonly regionID: FieldRef<"Address", 'Int'>
    readonly pOrCID: FieldRef<"Address", 'Int'>
    readonly cOrMID: FieldRef<"Address", 'Int'>
    readonly brgyID: FieldRef<"Address", 'Int'>
    readonly street: FieldRef<"Address", 'String'>
    readonly facilityID: FieldRef<"Address", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address updateManyAndReturn
   */
  export type AddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model Facility
   */

  export type AggregateFacility = {
    _count: FacilityCountAggregateOutputType | null
    _min: FacilityMinAggregateOutputType | null
    _max: FacilityMaxAggregateOutputType | null
  }

  export type FacilityMinAggregateOutputType = {
    facilityID: string | null
    name: string | null
    photo: string | null
    openingTime: Date | null
    closingTime: Date | null
    facilityType: $Enums.FacilityType | null
    ownership: $Enums.Ownership | null
    bookingSystem: string | null
    updatedAt: Date | null
  }

  export type FacilityMaxAggregateOutputType = {
    facilityID: string | null
    name: string | null
    photo: string | null
    openingTime: Date | null
    closingTime: Date | null
    facilityType: $Enums.FacilityType | null
    ownership: $Enums.Ownership | null
    bookingSystem: string | null
    updatedAt: Date | null
  }

  export type FacilityCountAggregateOutputType = {
    facilityID: number
    name: number
    photo: number
    openingTime: number
    closingTime: number
    facilityType: number
    ownership: number
    bookingSystem: number
    acceptedProviders: number
    updatedAt: number
    _all: number
  }


  export type FacilityMinAggregateInputType = {
    facilityID?: true
    name?: true
    photo?: true
    openingTime?: true
    closingTime?: true
    facilityType?: true
    ownership?: true
    bookingSystem?: true
    updatedAt?: true
  }

  export type FacilityMaxAggregateInputType = {
    facilityID?: true
    name?: true
    photo?: true
    openingTime?: true
    closingTime?: true
    facilityType?: true
    ownership?: true
    bookingSystem?: true
    updatedAt?: true
  }

  export type FacilityCountAggregateInputType = {
    facilityID?: true
    name?: true
    photo?: true
    openingTime?: true
    closingTime?: true
    facilityType?: true
    ownership?: true
    bookingSystem?: true
    acceptedProviders?: true
    updatedAt?: true
    _all?: true
  }

  export type FacilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Facility to aggregate.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Facilities
    **/
    _count?: true | FacilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacilityMaxAggregateInputType
  }

  export type GetFacilityAggregateType<T extends FacilityAggregateArgs> = {
        [P in keyof T & keyof AggregateFacility]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacility[P]>
      : GetScalarType<T[P], AggregateFacility[P]>
  }




  export type FacilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityWhereInput
    orderBy?: FacilityOrderByWithAggregationInput | FacilityOrderByWithAggregationInput[]
    by: FacilityScalarFieldEnum[] | FacilityScalarFieldEnum
    having?: FacilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacilityCountAggregateInputType | true
    _min?: FacilityMinAggregateInputType
    _max?: FacilityMaxAggregateInputType
  }

  export type FacilityGroupByOutputType = {
    facilityID: string
    name: string
    photo: string
    openingTime: Date | null
    closingTime: Date | null
    facilityType: $Enums.FacilityType
    ownership: $Enums.Ownership
    bookingSystem: string | null
    acceptedProviders: $Enums.Provider[]
    updatedAt: Date
    _count: FacilityCountAggregateOutputType | null
    _min: FacilityMinAggregateOutputType | null
    _max: FacilityMaxAggregateOutputType | null
  }

  type GetFacilityGroupByPayload<T extends FacilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacilityGroupByOutputType[P]>
            : GetScalarType<T[P], FacilityGroupByOutputType[P]>
        }
      >
    >


  export type FacilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    facilityID?: boolean
    name?: boolean
    photo?: boolean
    openingTime?: boolean
    closingTime?: boolean
    facilityType?: boolean
    ownership?: boolean
    bookingSystem?: boolean
    acceptedProviders?: boolean
    updatedAt?: boolean
    address?: boolean | Facility$addressArgs<ExtArgs>
    contacts?: boolean | Facility$contactsArgs<ExtArgs>
    services?: boolean | Facility$servicesArgs<ExtArgs>
    employees?: boolean | Facility$employeesArgs<ExtArgs>
    divisions?: boolean | Facility$divisionsArgs<ExtArgs>
    logs?: boolean | Facility$logsArgs<ExtArgs>
    _count?: boolean | FacilityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facility"]>

  export type FacilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    facilityID?: boolean
    name?: boolean
    photo?: boolean
    openingTime?: boolean
    closingTime?: boolean
    facilityType?: boolean
    ownership?: boolean
    bookingSystem?: boolean
    acceptedProviders?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["facility"]>

  export type FacilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    facilityID?: boolean
    name?: boolean
    photo?: boolean
    openingTime?: boolean
    closingTime?: boolean
    facilityType?: boolean
    ownership?: boolean
    bookingSystem?: boolean
    acceptedProviders?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["facility"]>

  export type FacilitySelectScalar = {
    facilityID?: boolean
    name?: boolean
    photo?: boolean
    openingTime?: boolean
    closingTime?: boolean
    facilityType?: boolean
    ownership?: boolean
    bookingSystem?: boolean
    acceptedProviders?: boolean
    updatedAt?: boolean
  }

  export type FacilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"facilityID" | "name" | "photo" | "openingTime" | "closingTime" | "facilityType" | "ownership" | "bookingSystem" | "acceptedProviders" | "updatedAt", ExtArgs["result"]["facility"]>
  export type FacilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | Facility$addressArgs<ExtArgs>
    contacts?: boolean | Facility$contactsArgs<ExtArgs>
    services?: boolean | Facility$servicesArgs<ExtArgs>
    employees?: boolean | Facility$employeesArgs<ExtArgs>
    divisions?: boolean | Facility$divisionsArgs<ExtArgs>
    logs?: boolean | Facility$logsArgs<ExtArgs>
    _count?: boolean | FacilityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FacilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FacilityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FacilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Facility"
    objects: {
      address: Prisma.$AddressPayload<ExtArgs> | null
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      services: Prisma.$ServicePayload<ExtArgs>[]
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      divisions: Prisma.$DivisionPayload<ExtArgs>[]
      logs: Prisma.$UpdateLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      facilityID: string
      name: string
      photo: string
      openingTime: Date | null
      closingTime: Date | null
      facilityType: $Enums.FacilityType
      ownership: $Enums.Ownership
      bookingSystem: string | null
      acceptedProviders: $Enums.Provider[]
      updatedAt: Date
    }, ExtArgs["result"]["facility"]>
    composites: {}
  }

  type FacilityGetPayload<S extends boolean | null | undefined | FacilityDefaultArgs> = $Result.GetResult<Prisma.$FacilityPayload, S>

  type FacilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FacilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FacilityCountAggregateInputType | true
    }

  export interface FacilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Facility'], meta: { name: 'Facility' } }
    /**
     * Find zero or one Facility that matches the filter.
     * @param {FacilityFindUniqueArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacilityFindUniqueArgs>(args: SelectSubset<T, FacilityFindUniqueArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Facility that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacilityFindUniqueOrThrowArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacilityFindUniqueOrThrowArgs>(args: SelectSubset<T, FacilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Facility that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindFirstArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacilityFindFirstArgs>(args?: SelectSubset<T, FacilityFindFirstArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Facility that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindFirstOrThrowArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacilityFindFirstOrThrowArgs>(args?: SelectSubset<T, FacilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Facilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Facilities
     * const facilities = await prisma.facility.findMany()
     * 
     * // Get first 10 Facilities
     * const facilities = await prisma.facility.findMany({ take: 10 })
     * 
     * // Only select the `facilityID`
     * const facilityWithFacilityIDOnly = await prisma.facility.findMany({ select: { facilityID: true } })
     * 
     */
    findMany<T extends FacilityFindManyArgs>(args?: SelectSubset<T, FacilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Facility.
     * @param {FacilityCreateArgs} args - Arguments to create a Facility.
     * @example
     * // Create one Facility
     * const Facility = await prisma.facility.create({
     *   data: {
     *     // ... data to create a Facility
     *   }
     * })
     * 
     */
    create<T extends FacilityCreateArgs>(args: SelectSubset<T, FacilityCreateArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Facilities.
     * @param {FacilityCreateManyArgs} args - Arguments to create many Facilities.
     * @example
     * // Create many Facilities
     * const facility = await prisma.facility.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacilityCreateManyArgs>(args?: SelectSubset<T, FacilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Facilities and returns the data saved in the database.
     * @param {FacilityCreateManyAndReturnArgs} args - Arguments to create many Facilities.
     * @example
     * // Create many Facilities
     * const facility = await prisma.facility.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Facilities and only return the `facilityID`
     * const facilityWithFacilityIDOnly = await prisma.facility.createManyAndReturn({
     *   select: { facilityID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FacilityCreateManyAndReturnArgs>(args?: SelectSubset<T, FacilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Facility.
     * @param {FacilityDeleteArgs} args - Arguments to delete one Facility.
     * @example
     * // Delete one Facility
     * const Facility = await prisma.facility.delete({
     *   where: {
     *     // ... filter to delete one Facility
     *   }
     * })
     * 
     */
    delete<T extends FacilityDeleteArgs>(args: SelectSubset<T, FacilityDeleteArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Facility.
     * @param {FacilityUpdateArgs} args - Arguments to update one Facility.
     * @example
     * // Update one Facility
     * const facility = await prisma.facility.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacilityUpdateArgs>(args: SelectSubset<T, FacilityUpdateArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Facilities.
     * @param {FacilityDeleteManyArgs} args - Arguments to filter Facilities to delete.
     * @example
     * // Delete a few Facilities
     * const { count } = await prisma.facility.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacilityDeleteManyArgs>(args?: SelectSubset<T, FacilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Facilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Facilities
     * const facility = await prisma.facility.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacilityUpdateManyArgs>(args: SelectSubset<T, FacilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Facilities and returns the data updated in the database.
     * @param {FacilityUpdateManyAndReturnArgs} args - Arguments to update many Facilities.
     * @example
     * // Update many Facilities
     * const facility = await prisma.facility.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Facilities and only return the `facilityID`
     * const facilityWithFacilityIDOnly = await prisma.facility.updateManyAndReturn({
     *   select: { facilityID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FacilityUpdateManyAndReturnArgs>(args: SelectSubset<T, FacilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Facility.
     * @param {FacilityUpsertArgs} args - Arguments to update or create a Facility.
     * @example
     * // Update or create a Facility
     * const facility = await prisma.facility.upsert({
     *   create: {
     *     // ... data to create a Facility
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Facility we want to update
     *   }
     * })
     */
    upsert<T extends FacilityUpsertArgs>(args: SelectSubset<T, FacilityUpsertArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Facilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityCountArgs} args - Arguments to filter Facilities to count.
     * @example
     * // Count the number of Facilities
     * const count = await prisma.facility.count({
     *   where: {
     *     // ... the filter for the Facilities we want to count
     *   }
     * })
    **/
    count<T extends FacilityCountArgs>(
      args?: Subset<T, FacilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Facility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacilityAggregateArgs>(args: Subset<T, FacilityAggregateArgs>): Prisma.PrismaPromise<GetFacilityAggregateType<T>>

    /**
     * Group by Facility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacilityGroupByArgs['orderBy'] }
        : { orderBy?: FacilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Facility model
   */
  readonly fields: FacilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Facility.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    address<T extends Facility$addressArgs<ExtArgs> = {}>(args?: Subset<T, Facility$addressArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    contacts<T extends Facility$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Facility$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    services<T extends Facility$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Facility$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    employees<T extends Facility$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Facility$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    divisions<T extends Facility$divisionsArgs<ExtArgs> = {}>(args?: Subset<T, Facility$divisionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    logs<T extends Facility$logsArgs<ExtArgs> = {}>(args?: Subset<T, Facility$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpdateLogPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Facility model
   */ 
  interface FacilityFieldRefs {
    readonly facilityID: FieldRef<"Facility", 'String'>
    readonly name: FieldRef<"Facility", 'String'>
    readonly photo: FieldRef<"Facility", 'String'>
    readonly openingTime: FieldRef<"Facility", 'DateTime'>
    readonly closingTime: FieldRef<"Facility", 'DateTime'>
    readonly facilityType: FieldRef<"Facility", 'FacilityType'>
    readonly ownership: FieldRef<"Facility", 'Ownership'>
    readonly bookingSystem: FieldRef<"Facility", 'String'>
    readonly acceptedProviders: FieldRef<"Facility", 'Provider[]'>
    readonly updatedAt: FieldRef<"Facility", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Facility findUnique
   */
  export type FacilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility findUniqueOrThrow
   */
  export type FacilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility findFirst
   */
  export type FacilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Facilities.
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Facilities.
     */
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility findFirstOrThrow
   */
  export type FacilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Facilities.
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Facilities.
     */
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility findMany
   */
  export type FacilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter, which Facilities to fetch.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Facilities.
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility create
   */
  export type FacilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * The data needed to create a Facility.
     */
    data: XOR<FacilityCreateInput, FacilityUncheckedCreateInput>
  }

  /**
   * Facility createMany
   */
  export type FacilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Facilities.
     */
    data: FacilityCreateManyInput | FacilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Facility createManyAndReturn
   */
  export type FacilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * The data used to create many Facilities.
     */
    data: FacilityCreateManyInput | FacilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Facility update
   */
  export type FacilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * The data needed to update a Facility.
     */
    data: XOR<FacilityUpdateInput, FacilityUncheckedUpdateInput>
    /**
     * Choose, which Facility to update.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility updateMany
   */
  export type FacilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Facilities.
     */
    data: XOR<FacilityUpdateManyMutationInput, FacilityUncheckedUpdateManyInput>
    /**
     * Filter which Facilities to update
     */
    where?: FacilityWhereInput
    /**
     * Limit how many Facilities to update.
     */
    limit?: number
  }

  /**
   * Facility updateManyAndReturn
   */
  export type FacilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * The data used to update Facilities.
     */
    data: XOR<FacilityUpdateManyMutationInput, FacilityUncheckedUpdateManyInput>
    /**
     * Filter which Facilities to update
     */
    where?: FacilityWhereInput
    /**
     * Limit how many Facilities to update.
     */
    limit?: number
  }

  /**
   * Facility upsert
   */
  export type FacilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * The filter to search for the Facility to update in case it exists.
     */
    where: FacilityWhereUniqueInput
    /**
     * In case the Facility found by the `where` argument doesn't exist, create a new Facility with this data.
     */
    create: XOR<FacilityCreateInput, FacilityUncheckedCreateInput>
    /**
     * In case the Facility was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacilityUpdateInput, FacilityUncheckedUpdateInput>
  }

  /**
   * Facility delete
   */
  export type FacilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    /**
     * Filter which Facility to delete.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility deleteMany
   */
  export type FacilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Facilities to delete
     */
    where?: FacilityWhereInput
    /**
     * Limit how many Facilities to delete.
     */
    limit?: number
  }

  /**
   * Facility.address
   */
  export type Facility$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
  }

  /**
   * Facility.contacts
   */
  export type Facility$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Facility.services
   */
  export type Facility$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Facility.employees
   */
  export type Facility$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Facility.divisions
   */
  export type Facility$divisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    where?: DivisionWhereInput
    orderBy?: DivisionOrderByWithRelationInput | DivisionOrderByWithRelationInput[]
    cursor?: DivisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DivisionScalarFieldEnum | DivisionScalarFieldEnum[]
  }

  /**
   * Facility.logs
   */
  export type Facility$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateLog
     */
    select?: UpdateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateLog
     */
    omit?: UpdateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateLogInclude<ExtArgs> | null
    where?: UpdateLogWhereInput
    orderBy?: UpdateLogOrderByWithRelationInput | UpdateLogOrderByWithRelationInput[]
    cursor?: UpdateLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UpdateLogScalarFieldEnum | UpdateLogScalarFieldEnum[]
  }

  /**
   * Facility without action
   */
  export type FacilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
  }


  /**
   * Model Division
   */

  export type AggregateDivision = {
    _count: DivisionCountAggregateOutputType | null
    _min: DivisionMinAggregateOutputType | null
    _max: DivisionMaxAggregateOutputType | null
  }

  export type DivisionMinAggregateOutputType = {
    divisionID: string | null
    name: string | null
    openingTime: Date | null
    closingTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    facilityID: string | null
  }

  export type DivisionMaxAggregateOutputType = {
    divisionID: string | null
    name: string | null
    openingTime: Date | null
    closingTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    facilityID: string | null
  }

  export type DivisionCountAggregateOutputType = {
    divisionID: number
    name: number
    openingTime: number
    closingTime: number
    createdAt: number
    updatedAt: number
    facilityID: number
    _all: number
  }


  export type DivisionMinAggregateInputType = {
    divisionID?: true
    name?: true
    openingTime?: true
    closingTime?: true
    createdAt?: true
    updatedAt?: true
    facilityID?: true
  }

  export type DivisionMaxAggregateInputType = {
    divisionID?: true
    name?: true
    openingTime?: true
    closingTime?: true
    createdAt?: true
    updatedAt?: true
    facilityID?: true
  }

  export type DivisionCountAggregateInputType = {
    divisionID?: true
    name?: true
    openingTime?: true
    closingTime?: true
    createdAt?: true
    updatedAt?: true
    facilityID?: true
    _all?: true
  }

  export type DivisionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Division to aggregate.
     */
    where?: DivisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Divisions to fetch.
     */
    orderBy?: DivisionOrderByWithRelationInput | DivisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DivisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Divisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Divisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Divisions
    **/
    _count?: true | DivisionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DivisionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DivisionMaxAggregateInputType
  }

  export type GetDivisionAggregateType<T extends DivisionAggregateArgs> = {
        [P in keyof T & keyof AggregateDivision]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDivision[P]>
      : GetScalarType<T[P], AggregateDivision[P]>
  }




  export type DivisionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DivisionWhereInput
    orderBy?: DivisionOrderByWithAggregationInput | DivisionOrderByWithAggregationInput[]
    by: DivisionScalarFieldEnum[] | DivisionScalarFieldEnum
    having?: DivisionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DivisionCountAggregateInputType | true
    _min?: DivisionMinAggregateInputType
    _max?: DivisionMaxAggregateInputType
  }

  export type DivisionGroupByOutputType = {
    divisionID: string
    name: string
    openingTime: Date
    closingTime: Date
    createdAt: Date
    updatedAt: Date
    facilityID: string
    _count: DivisionCountAggregateOutputType | null
    _min: DivisionMinAggregateOutputType | null
    _max: DivisionMaxAggregateOutputType | null
  }

  type GetDivisionGroupByPayload<T extends DivisionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DivisionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DivisionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DivisionGroupByOutputType[P]>
            : GetScalarType<T[P], DivisionGroupByOutputType[P]>
        }
      >
    >


  export type DivisionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    divisionID?: boolean
    name?: boolean
    openingTime?: boolean
    closingTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    facilityID?: boolean
    contacts?: boolean | Division$contactsArgs<ExtArgs>
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    services?: boolean | Division$servicesArgs<ExtArgs>
    admins?: boolean | Division$adminsArgs<ExtArgs>
    logs?: boolean | Division$logsArgs<ExtArgs>
    _count?: boolean | DivisionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["division"]>

  export type DivisionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    divisionID?: boolean
    name?: boolean
    openingTime?: boolean
    closingTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    facilityID?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["division"]>

  export type DivisionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    divisionID?: boolean
    name?: boolean
    openingTime?: boolean
    closingTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    facilityID?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["division"]>

  export type DivisionSelectScalar = {
    divisionID?: boolean
    name?: boolean
    openingTime?: boolean
    closingTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    facilityID?: boolean
  }

  export type DivisionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"divisionID" | "name" | "openingTime" | "closingTime" | "createdAt" | "updatedAt" | "facilityID", ExtArgs["result"]["division"]>
  export type DivisionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | Division$contactsArgs<ExtArgs>
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    services?: boolean | Division$servicesArgs<ExtArgs>
    admins?: boolean | Division$adminsArgs<ExtArgs>
    logs?: boolean | Division$logsArgs<ExtArgs>
    _count?: boolean | DivisionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DivisionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }
  export type DivisionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }

  export type $DivisionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Division"
    objects: {
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      facility: Prisma.$FacilityPayload<ExtArgs>
      services: Prisma.$ServicePayload<ExtArgs>[]
      admins: Prisma.$EmployeePayload<ExtArgs>[]
      logs: Prisma.$UpdateLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      divisionID: string
      name: string
      openingTime: Date
      closingTime: Date
      createdAt: Date
      updatedAt: Date
      facilityID: string
    }, ExtArgs["result"]["division"]>
    composites: {}
  }

  type DivisionGetPayload<S extends boolean | null | undefined | DivisionDefaultArgs> = $Result.GetResult<Prisma.$DivisionPayload, S>

  type DivisionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DivisionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DivisionCountAggregateInputType | true
    }

  export interface DivisionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Division'], meta: { name: 'Division' } }
    /**
     * Find zero or one Division that matches the filter.
     * @param {DivisionFindUniqueArgs} args - Arguments to find a Division
     * @example
     * // Get one Division
     * const division = await prisma.division.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DivisionFindUniqueArgs>(args: SelectSubset<T, DivisionFindUniqueArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Division that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DivisionFindUniqueOrThrowArgs} args - Arguments to find a Division
     * @example
     * // Get one Division
     * const division = await prisma.division.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DivisionFindUniqueOrThrowArgs>(args: SelectSubset<T, DivisionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Division that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionFindFirstArgs} args - Arguments to find a Division
     * @example
     * // Get one Division
     * const division = await prisma.division.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DivisionFindFirstArgs>(args?: SelectSubset<T, DivisionFindFirstArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Division that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionFindFirstOrThrowArgs} args - Arguments to find a Division
     * @example
     * // Get one Division
     * const division = await prisma.division.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DivisionFindFirstOrThrowArgs>(args?: SelectSubset<T, DivisionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Divisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Divisions
     * const divisions = await prisma.division.findMany()
     * 
     * // Get first 10 Divisions
     * const divisions = await prisma.division.findMany({ take: 10 })
     * 
     * // Only select the `divisionID`
     * const divisionWithDivisionIDOnly = await prisma.division.findMany({ select: { divisionID: true } })
     * 
     */
    findMany<T extends DivisionFindManyArgs>(args?: SelectSubset<T, DivisionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Division.
     * @param {DivisionCreateArgs} args - Arguments to create a Division.
     * @example
     * // Create one Division
     * const Division = await prisma.division.create({
     *   data: {
     *     // ... data to create a Division
     *   }
     * })
     * 
     */
    create<T extends DivisionCreateArgs>(args: SelectSubset<T, DivisionCreateArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Divisions.
     * @param {DivisionCreateManyArgs} args - Arguments to create many Divisions.
     * @example
     * // Create many Divisions
     * const division = await prisma.division.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DivisionCreateManyArgs>(args?: SelectSubset<T, DivisionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Divisions and returns the data saved in the database.
     * @param {DivisionCreateManyAndReturnArgs} args - Arguments to create many Divisions.
     * @example
     * // Create many Divisions
     * const division = await prisma.division.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Divisions and only return the `divisionID`
     * const divisionWithDivisionIDOnly = await prisma.division.createManyAndReturn({
     *   select: { divisionID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DivisionCreateManyAndReturnArgs>(args?: SelectSubset<T, DivisionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Division.
     * @param {DivisionDeleteArgs} args - Arguments to delete one Division.
     * @example
     * // Delete one Division
     * const Division = await prisma.division.delete({
     *   where: {
     *     // ... filter to delete one Division
     *   }
     * })
     * 
     */
    delete<T extends DivisionDeleteArgs>(args: SelectSubset<T, DivisionDeleteArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Division.
     * @param {DivisionUpdateArgs} args - Arguments to update one Division.
     * @example
     * // Update one Division
     * const division = await prisma.division.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DivisionUpdateArgs>(args: SelectSubset<T, DivisionUpdateArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Divisions.
     * @param {DivisionDeleteManyArgs} args - Arguments to filter Divisions to delete.
     * @example
     * // Delete a few Divisions
     * const { count } = await prisma.division.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DivisionDeleteManyArgs>(args?: SelectSubset<T, DivisionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Divisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Divisions
     * const division = await prisma.division.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DivisionUpdateManyArgs>(args: SelectSubset<T, DivisionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Divisions and returns the data updated in the database.
     * @param {DivisionUpdateManyAndReturnArgs} args - Arguments to update many Divisions.
     * @example
     * // Update many Divisions
     * const division = await prisma.division.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Divisions and only return the `divisionID`
     * const divisionWithDivisionIDOnly = await prisma.division.updateManyAndReturn({
     *   select: { divisionID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DivisionUpdateManyAndReturnArgs>(args: SelectSubset<T, DivisionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Division.
     * @param {DivisionUpsertArgs} args - Arguments to update or create a Division.
     * @example
     * // Update or create a Division
     * const division = await prisma.division.upsert({
     *   create: {
     *     // ... data to create a Division
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Division we want to update
     *   }
     * })
     */
    upsert<T extends DivisionUpsertArgs>(args: SelectSubset<T, DivisionUpsertArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Divisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionCountArgs} args - Arguments to filter Divisions to count.
     * @example
     * // Count the number of Divisions
     * const count = await prisma.division.count({
     *   where: {
     *     // ... the filter for the Divisions we want to count
     *   }
     * })
    **/
    count<T extends DivisionCountArgs>(
      args?: Subset<T, DivisionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DivisionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Division.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DivisionAggregateArgs>(args: Subset<T, DivisionAggregateArgs>): Prisma.PrismaPromise<GetDivisionAggregateType<T>>

    /**
     * Group by Division.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DivisionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DivisionGroupByArgs['orderBy'] }
        : { orderBy?: DivisionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DivisionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDivisionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Division model
   */
  readonly fields: DivisionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Division.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DivisionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contacts<T extends Division$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Division$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    facility<T extends FacilityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacilityDefaultArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    services<T extends Division$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Division$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    admins<T extends Division$adminsArgs<ExtArgs> = {}>(args?: Subset<T, Division$adminsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    logs<T extends Division$logsArgs<ExtArgs> = {}>(args?: Subset<T, Division$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpdateLogPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Division model
   */ 
  interface DivisionFieldRefs {
    readonly divisionID: FieldRef<"Division", 'String'>
    readonly name: FieldRef<"Division", 'String'>
    readonly openingTime: FieldRef<"Division", 'DateTime'>
    readonly closingTime: FieldRef<"Division", 'DateTime'>
    readonly createdAt: FieldRef<"Division", 'DateTime'>
    readonly updatedAt: FieldRef<"Division", 'DateTime'>
    readonly facilityID: FieldRef<"Division", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Division findUnique
   */
  export type DivisionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * Filter, which Division to fetch.
     */
    where: DivisionWhereUniqueInput
  }

  /**
   * Division findUniqueOrThrow
   */
  export type DivisionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * Filter, which Division to fetch.
     */
    where: DivisionWhereUniqueInput
  }

  /**
   * Division findFirst
   */
  export type DivisionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * Filter, which Division to fetch.
     */
    where?: DivisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Divisions to fetch.
     */
    orderBy?: DivisionOrderByWithRelationInput | DivisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Divisions.
     */
    cursor?: DivisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Divisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Divisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Divisions.
     */
    distinct?: DivisionScalarFieldEnum | DivisionScalarFieldEnum[]
  }

  /**
   * Division findFirstOrThrow
   */
  export type DivisionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * Filter, which Division to fetch.
     */
    where?: DivisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Divisions to fetch.
     */
    orderBy?: DivisionOrderByWithRelationInput | DivisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Divisions.
     */
    cursor?: DivisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Divisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Divisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Divisions.
     */
    distinct?: DivisionScalarFieldEnum | DivisionScalarFieldEnum[]
  }

  /**
   * Division findMany
   */
  export type DivisionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * Filter, which Divisions to fetch.
     */
    where?: DivisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Divisions to fetch.
     */
    orderBy?: DivisionOrderByWithRelationInput | DivisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Divisions.
     */
    cursor?: DivisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Divisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Divisions.
     */
    skip?: number
    distinct?: DivisionScalarFieldEnum | DivisionScalarFieldEnum[]
  }

  /**
   * Division create
   */
  export type DivisionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * The data needed to create a Division.
     */
    data: XOR<DivisionCreateInput, DivisionUncheckedCreateInput>
  }

  /**
   * Division createMany
   */
  export type DivisionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Divisions.
     */
    data: DivisionCreateManyInput | DivisionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Division createManyAndReturn
   */
  export type DivisionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * The data used to create many Divisions.
     */
    data: DivisionCreateManyInput | DivisionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Division update
   */
  export type DivisionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * The data needed to update a Division.
     */
    data: XOR<DivisionUpdateInput, DivisionUncheckedUpdateInput>
    /**
     * Choose, which Division to update.
     */
    where: DivisionWhereUniqueInput
  }

  /**
   * Division updateMany
   */
  export type DivisionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Divisions.
     */
    data: XOR<DivisionUpdateManyMutationInput, DivisionUncheckedUpdateManyInput>
    /**
     * Filter which Divisions to update
     */
    where?: DivisionWhereInput
    /**
     * Limit how many Divisions to update.
     */
    limit?: number
  }

  /**
   * Division updateManyAndReturn
   */
  export type DivisionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * The data used to update Divisions.
     */
    data: XOR<DivisionUpdateManyMutationInput, DivisionUncheckedUpdateManyInput>
    /**
     * Filter which Divisions to update
     */
    where?: DivisionWhereInput
    /**
     * Limit how many Divisions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Division upsert
   */
  export type DivisionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * The filter to search for the Division to update in case it exists.
     */
    where: DivisionWhereUniqueInput
    /**
     * In case the Division found by the `where` argument doesn't exist, create a new Division with this data.
     */
    create: XOR<DivisionCreateInput, DivisionUncheckedCreateInput>
    /**
     * In case the Division was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DivisionUpdateInput, DivisionUncheckedUpdateInput>
  }

  /**
   * Division delete
   */
  export type DivisionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    /**
     * Filter which Division to delete.
     */
    where: DivisionWhereUniqueInput
  }

  /**
   * Division deleteMany
   */
  export type DivisionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Divisions to delete
     */
    where?: DivisionWhereInput
    /**
     * Limit how many Divisions to delete.
     */
    limit?: number
  }

  /**
   * Division.contacts
   */
  export type Division$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Division.services
   */
  export type Division$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Division.admins
   */
  export type Division$adminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Division.logs
   */
  export type Division$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateLog
     */
    select?: UpdateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateLog
     */
    omit?: UpdateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateLogInclude<ExtArgs> | null
    where?: UpdateLogWhereInput
    orderBy?: UpdateLogOrderByWithRelationInput | UpdateLogOrderByWithRelationInput[]
    cursor?: UpdateLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UpdateLogScalarFieldEnum | UpdateLogScalarFieldEnum[]
  }

  /**
   * Division without action
   */
  export type DivisionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeMinAggregateOutputType = {
    employeeID: string | null
    password: string | null
    role: $Enums.Role | null
    fname: string | null
    mname: string | null
    lname: string | null
    photo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    facilityID: string | null
  }

  export type EmployeeMaxAggregateOutputType = {
    employeeID: string | null
    password: string | null
    role: $Enums.Role | null
    fname: string | null
    mname: string | null
    lname: string | null
    photo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    facilityID: string | null
  }

  export type EmployeeCountAggregateOutputType = {
    employeeID: number
    password: number
    role: number
    fname: number
    mname: number
    lname: number
    photo: number
    createdAt: number
    updatedAt: number
    facilityID: number
    _all: number
  }


  export type EmployeeMinAggregateInputType = {
    employeeID?: true
    password?: true
    role?: true
    fname?: true
    mname?: true
    lname?: true
    photo?: true
    createdAt?: true
    updatedAt?: true
    facilityID?: true
  }

  export type EmployeeMaxAggregateInputType = {
    employeeID?: true
    password?: true
    role?: true
    fname?: true
    mname?: true
    lname?: true
    photo?: true
    createdAt?: true
    updatedAt?: true
    facilityID?: true
  }

  export type EmployeeCountAggregateInputType = {
    employeeID?: true
    password?: true
    role?: true
    fname?: true
    mname?: true
    lname?: true
    photo?: true
    createdAt?: true
    updatedAt?: true
    facilityID?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    employeeID: string
    password: string
    role: $Enums.Role
    fname: string
    mname: string | null
    lname: string
    photo: string
    createdAt: Date
    updatedAt: Date
    facilityID: string
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employeeID?: boolean
    password?: boolean
    role?: boolean
    fname?: boolean
    mname?: boolean
    lname?: boolean
    photo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    facilityID?: boolean
    sessions?: boolean | Employee$sessionsArgs<ExtArgs>
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    divisions?: boolean | Employee$divisionsArgs<ExtArgs>
    updateLog?: boolean | Employee$updateLogArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employeeID?: boolean
    password?: boolean
    role?: boolean
    fname?: boolean
    mname?: boolean
    lname?: boolean
    photo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    facilityID?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employeeID?: boolean
    password?: boolean
    role?: boolean
    fname?: boolean
    mname?: boolean
    lname?: boolean
    photo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    facilityID?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    employeeID?: boolean
    password?: boolean
    role?: boolean
    fname?: boolean
    mname?: boolean
    lname?: boolean
    photo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    facilityID?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"employeeID" | "password" | "role" | "fname" | "mname" | "lname" | "photo" | "createdAt" | "updatedAt" | "facilityID", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | Employee$sessionsArgs<ExtArgs>
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    divisions?: boolean | Employee$divisionsArgs<ExtArgs>
    updateLog?: boolean | Employee$updateLogArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      facility: Prisma.$FacilityPayload<ExtArgs>
      divisions: Prisma.$DivisionPayload<ExtArgs>[]
      updateLog: Prisma.$UpdateLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      employeeID: string
      password: string
      role: $Enums.Role
      fname: string
      mname: string | null
      lname: string
      photo: string
      createdAt: Date
      updatedAt: Date
      facilityID: string
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `employeeID`
     * const employeeWithEmployeeIDOnly = await prisma.employee.findMany({ select: { employeeID: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `employeeID`
     * const employeeWithEmployeeIDOnly = await prisma.employee.createManyAndReturn({
     *   select: { employeeID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `employeeID`
     * const employeeWithEmployeeIDOnly = await prisma.employee.updateManyAndReturn({
     *   select: { employeeID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends Employee$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    facility<T extends FacilityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacilityDefaultArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    divisions<T extends Employee$divisionsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$divisionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    updateLog<T extends Employee$updateLogArgs<ExtArgs> = {}>(args?: Subset<T, Employee$updateLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpdateLogPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */ 
  interface EmployeeFieldRefs {
    readonly employeeID: FieldRef<"Employee", 'String'>
    readonly password: FieldRef<"Employee", 'String'>
    readonly role: FieldRef<"Employee", 'Role'>
    readonly fname: FieldRef<"Employee", 'String'>
    readonly mname: FieldRef<"Employee", 'String'>
    readonly lname: FieldRef<"Employee", 'String'>
    readonly photo: FieldRef<"Employee", 'String'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
    readonly facilityID: FieldRef<"Employee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.sessions
   */
  export type Employee$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Employee.divisions
   */
  export type Employee$divisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    where?: DivisionWhereInput
    orderBy?: DivisionOrderByWithRelationInput | DivisionOrderByWithRelationInput[]
    cursor?: DivisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DivisionScalarFieldEnum | DivisionScalarFieldEnum[]
  }

  /**
   * Employee.updateLog
   */
  export type Employee$updateLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateLog
     */
    select?: UpdateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateLog
     */
    omit?: UpdateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateLogInclude<ExtArgs> | null
    where?: UpdateLogWhereInput
    orderBy?: UpdateLogOrderByWithRelationInput | UpdateLogOrderByWithRelationInput[]
    cursor?: UpdateLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UpdateLogScalarFieldEnum | UpdateLogScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    sessionID: string | null
    expiresAt: Date | null
    employeeID: string | null
  }

  export type SessionMaxAggregateOutputType = {
    sessionID: string | null
    expiresAt: Date | null
    employeeID: string | null
  }

  export type SessionCountAggregateOutputType = {
    sessionID: number
    expiresAt: number
    employeeID: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    sessionID?: true
    expiresAt?: true
    employeeID?: true
  }

  export type SessionMaxAggregateInputType = {
    sessionID?: true
    expiresAt?: true
    employeeID?: true
  }

  export type SessionCountAggregateInputType = {
    sessionID?: true
    expiresAt?: true
    employeeID?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    sessionID: string
    expiresAt: Date
    employeeID: string
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionID?: boolean
    expiresAt?: boolean
    employeeID?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionID?: boolean
    expiresAt?: boolean
    employeeID?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionID?: boolean
    expiresAt?: boolean
    employeeID?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    sessionID?: boolean
    expiresAt?: boolean
    employeeID?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sessionID" | "expiresAt" | "employeeID", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sessionID: string
      expiresAt: Date
      employeeID: string
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `sessionID`
     * const sessionWithSessionIDOnly = await prisma.session.findMany({ select: { sessionID: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `sessionID`
     * const sessionWithSessionIDOnly = await prisma.session.createManyAndReturn({
     *   select: { sessionID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `sessionID`
     * const sessionWithSessionIDOnly = await prisma.session.updateManyAndReturn({
     *   select: { sessionID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly sessionID: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly employeeID: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceMinAggregateOutputType = {
    serviceID: string | null
    type: string | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
    facilityID: string | null
    divisionID: string | null
  }

  export type ServiceMaxAggregateOutputType = {
    serviceID: string | null
    type: string | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
    facilityID: string | null
    divisionID: string | null
  }

  export type ServiceCountAggregateOutputType = {
    serviceID: number
    type: number
    keywords: number
    note: number
    createdAt: number
    updatedAt: number
    facilityID: number
    divisionID: number
    _all: number
  }


  export type ServiceMinAggregateInputType = {
    serviceID?: true
    type?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    facilityID?: true
    divisionID?: true
  }

  export type ServiceMaxAggregateInputType = {
    serviceID?: true
    type?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    facilityID?: true
    divisionID?: true
  }

  export type ServiceCountAggregateInputType = {
    serviceID?: true
    type?: true
    keywords?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    facilityID?: true
    divisionID?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    serviceID: string
    type: string
    keywords: string[]
    note: string | null
    createdAt: Date
    updatedAt: Date
    facilityID: string
    divisionID: string | null
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    serviceID?: boolean
    type?: boolean
    keywords?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    facilityID?: boolean
    divisionID?: boolean
    phoneNumbers?: boolean | Service$phoneNumbersArgs<ExtArgs>
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    division?: boolean | Service$divisionArgs<ExtArgs>
    ambulanceService?: boolean | Service$ambulanceServiceArgs<ExtArgs>
    bloodBankService?: boolean | Service$bloodBankServiceArgs<ExtArgs>
    erService?: boolean | Service$erServiceArgs<ExtArgs>
    icuService?: boolean | Service$icuServiceArgs<ExtArgs>
    outpatientService?: boolean | Service$outpatientServiceArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    serviceID?: boolean
    type?: boolean
    keywords?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    facilityID?: boolean
    divisionID?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    division?: boolean | Service$divisionArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    serviceID?: boolean
    type?: boolean
    keywords?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    facilityID?: boolean
    divisionID?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    division?: boolean | Service$divisionArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    serviceID?: boolean
    type?: boolean
    keywords?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    facilityID?: boolean
    divisionID?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"serviceID" | "type" | "keywords" | "note" | "createdAt" | "updatedAt" | "facilityID" | "divisionID", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phoneNumbers?: boolean | Service$phoneNumbersArgs<ExtArgs>
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    division?: boolean | Service$divisionArgs<ExtArgs>
    ambulanceService?: boolean | Service$ambulanceServiceArgs<ExtArgs>
    bloodBankService?: boolean | Service$bloodBankServiceArgs<ExtArgs>
    erService?: boolean | Service$erServiceArgs<ExtArgs>
    icuService?: boolean | Service$icuServiceArgs<ExtArgs>
    outpatientService?: boolean | Service$outpatientServiceArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    division?: boolean | Service$divisionArgs<ExtArgs>
  }
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    division?: boolean | Service$divisionArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      phoneNumbers: Prisma.$ContactPayload<ExtArgs>[]
      facility: Prisma.$FacilityPayload<ExtArgs>
      division: Prisma.$DivisionPayload<ExtArgs> | null
      ambulanceService: Prisma.$AmbulanceServicePayload<ExtArgs> | null
      bloodBankService: Prisma.$BloodBankServicePayload<ExtArgs> | null
      erService: Prisma.$ERServicePayload<ExtArgs> | null
      icuService: Prisma.$ICUServicePayload<ExtArgs> | null
      outpatientService: Prisma.$OutpatientServicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      serviceID: string
      type: string
      keywords: string[]
      note: string | null
      createdAt: Date
      updatedAt: Date
      facilityID: string
      divisionID: string | null
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `serviceID`
     * const serviceWithServiceIDOnly = await prisma.service.findMany({ select: { serviceID: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `serviceID`
     * const serviceWithServiceIDOnly = await prisma.service.createManyAndReturn({
     *   select: { serviceID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `serviceID`
     * const serviceWithServiceIDOnly = await prisma.service.updateManyAndReturn({
     *   select: { serviceID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    phoneNumbers<T extends Service$phoneNumbersArgs<ExtArgs> = {}>(args?: Subset<T, Service$phoneNumbersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    facility<T extends FacilityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacilityDefaultArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    division<T extends Service$divisionArgs<ExtArgs> = {}>(args?: Subset<T, Service$divisionArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    ambulanceService<T extends Service$ambulanceServiceArgs<ExtArgs> = {}>(args?: Subset<T, Service$ambulanceServiceArgs<ExtArgs>>): Prisma__AmbulanceServiceClient<$Result.GetResult<Prisma.$AmbulanceServicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    bloodBankService<T extends Service$bloodBankServiceArgs<ExtArgs> = {}>(args?: Subset<T, Service$bloodBankServiceArgs<ExtArgs>>): Prisma__BloodBankServiceClient<$Result.GetResult<Prisma.$BloodBankServicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    erService<T extends Service$erServiceArgs<ExtArgs> = {}>(args?: Subset<T, Service$erServiceArgs<ExtArgs>>): Prisma__ERServiceClient<$Result.GetResult<Prisma.$ERServicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    icuService<T extends Service$icuServiceArgs<ExtArgs> = {}>(args?: Subset<T, Service$icuServiceArgs<ExtArgs>>): Prisma__ICUServiceClient<$Result.GetResult<Prisma.$ICUServicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    outpatientService<T extends Service$outpatientServiceArgs<ExtArgs> = {}>(args?: Subset<T, Service$outpatientServiceArgs<ExtArgs>>): Prisma__OutpatientServiceClient<$Result.GetResult<Prisma.$OutpatientServicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */ 
  interface ServiceFieldRefs {
    readonly serviceID: FieldRef<"Service", 'String'>
    readonly type: FieldRef<"Service", 'String'>
    readonly keywords: FieldRef<"Service", 'String[]'>
    readonly note: FieldRef<"Service", 'String'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
    readonly facilityID: FieldRef<"Service", 'String'>
    readonly divisionID: FieldRef<"Service", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.phoneNumbers
   */
  export type Service$phoneNumbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Service.division
   */
  export type Service$divisionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    where?: DivisionWhereInput
  }

  /**
   * Service.ambulanceService
   */
  export type Service$ambulanceServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceInclude<ExtArgs> | null
    where?: AmbulanceServiceWhereInput
  }

  /**
   * Service.bloodBankService
   */
  export type Service$bloodBankServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodBankService
     */
    select?: BloodBankServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BloodBankService
     */
    omit?: BloodBankServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodBankServiceInclude<ExtArgs> | null
    where?: BloodBankServiceWhereInput
  }

  /**
   * Service.erService
   */
  export type Service$erServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ERService
     */
    select?: ERServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ERService
     */
    omit?: ERServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ERServiceInclude<ExtArgs> | null
    where?: ERServiceWhereInput
  }

  /**
   * Service.icuService
   */
  export type Service$icuServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICUService
     */
    select?: ICUServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ICUService
     */
    omit?: ICUServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICUServiceInclude<ExtArgs> | null
    where?: ICUServiceWhereInput
  }

  /**
   * Service.outpatientService
   */
  export type Service$outpatientServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutpatientService
     */
    select?: OutpatientServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutpatientService
     */
    omit?: OutpatientServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutpatientServiceInclude<ExtArgs> | null
    where?: OutpatientServiceWhereInput
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model AmbulanceService
   */

  export type AggregateAmbulanceService = {
    _count: AmbulanceServiceCountAggregateOutputType | null
    _avg: AmbulanceServiceAvgAggregateOutputType | null
    _sum: AmbulanceServiceSumAggregateOutputType | null
    _min: AmbulanceServiceMinAggregateOutputType | null
    _max: AmbulanceServiceMaxAggregateOutputType | null
  }

  export type AmbulanceServiceAvgAggregateOutputType = {
    baseRate: number | null
    minCoverageRadius: number | null
    mileageRate: number | null
    maxCoverageRadius: number | null
  }

  export type AmbulanceServiceSumAggregateOutputType = {
    baseRate: number | null
    minCoverageRadius: number | null
    mileageRate: number | null
    maxCoverageRadius: number | null
  }

  export type AmbulanceServiceMinAggregateOutputType = {
    openingTime: Date | null
    closingTime: Date | null
    availability: $Enums.Availability | null
    baseRate: number | null
    minCoverageRadius: number | null
    mileageRate: number | null
    maxCoverageRadius: number | null
    serviceID: string | null
  }

  export type AmbulanceServiceMaxAggregateOutputType = {
    openingTime: Date | null
    closingTime: Date | null
    availability: $Enums.Availability | null
    baseRate: number | null
    minCoverageRadius: number | null
    mileageRate: number | null
    maxCoverageRadius: number | null
    serviceID: string | null
  }

  export type AmbulanceServiceCountAggregateOutputType = {
    openingTime: number
    closingTime: number
    availability: number
    baseRate: number
    minCoverageRadius: number
    mileageRate: number
    maxCoverageRadius: number
    serviceID: number
    _all: number
  }


  export type AmbulanceServiceAvgAggregateInputType = {
    baseRate?: true
    minCoverageRadius?: true
    mileageRate?: true
    maxCoverageRadius?: true
  }

  export type AmbulanceServiceSumAggregateInputType = {
    baseRate?: true
    minCoverageRadius?: true
    mileageRate?: true
    maxCoverageRadius?: true
  }

  export type AmbulanceServiceMinAggregateInputType = {
    openingTime?: true
    closingTime?: true
    availability?: true
    baseRate?: true
    minCoverageRadius?: true
    mileageRate?: true
    maxCoverageRadius?: true
    serviceID?: true
  }

  export type AmbulanceServiceMaxAggregateInputType = {
    openingTime?: true
    closingTime?: true
    availability?: true
    baseRate?: true
    minCoverageRadius?: true
    mileageRate?: true
    maxCoverageRadius?: true
    serviceID?: true
  }

  export type AmbulanceServiceCountAggregateInputType = {
    openingTime?: true
    closingTime?: true
    availability?: true
    baseRate?: true
    minCoverageRadius?: true
    mileageRate?: true
    maxCoverageRadius?: true
    serviceID?: true
    _all?: true
  }

  export type AmbulanceServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AmbulanceService to aggregate.
     */
    where?: AmbulanceServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmbulanceServices to fetch.
     */
    orderBy?: AmbulanceServiceOrderByWithRelationInput | AmbulanceServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmbulanceServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmbulanceServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmbulanceServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AmbulanceServices
    **/
    _count?: true | AmbulanceServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AmbulanceServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AmbulanceServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmbulanceServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmbulanceServiceMaxAggregateInputType
  }

  export type GetAmbulanceServiceAggregateType<T extends AmbulanceServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateAmbulanceService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmbulanceService[P]>
      : GetScalarType<T[P], AggregateAmbulanceService[P]>
  }




  export type AmbulanceServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmbulanceServiceWhereInput
    orderBy?: AmbulanceServiceOrderByWithAggregationInput | AmbulanceServiceOrderByWithAggregationInput[]
    by: AmbulanceServiceScalarFieldEnum[] | AmbulanceServiceScalarFieldEnum
    having?: AmbulanceServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmbulanceServiceCountAggregateInputType | true
    _avg?: AmbulanceServiceAvgAggregateInputType
    _sum?: AmbulanceServiceSumAggregateInputType
    _min?: AmbulanceServiceMinAggregateInputType
    _max?: AmbulanceServiceMaxAggregateInputType
  }

  export type AmbulanceServiceGroupByOutputType = {
    openingTime: Date | null
    closingTime: Date | null
    availability: $Enums.Availability
    baseRate: number
    minCoverageRadius: number
    mileageRate: number
    maxCoverageRadius: number
    serviceID: string
    _count: AmbulanceServiceCountAggregateOutputType | null
    _avg: AmbulanceServiceAvgAggregateOutputType | null
    _sum: AmbulanceServiceSumAggregateOutputType | null
    _min: AmbulanceServiceMinAggregateOutputType | null
    _max: AmbulanceServiceMaxAggregateOutputType | null
  }

  type GetAmbulanceServiceGroupByPayload<T extends AmbulanceServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmbulanceServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmbulanceServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmbulanceServiceGroupByOutputType[P]>
            : GetScalarType<T[P], AmbulanceServiceGroupByOutputType[P]>
        }
      >
    >


  export type AmbulanceServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    openingTime?: boolean
    closingTime?: boolean
    availability?: boolean
    baseRate?: boolean
    minCoverageRadius?: boolean
    mileageRate?: boolean
    maxCoverageRadius?: boolean
    serviceID?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ambulanceService"]>

  export type AmbulanceServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    openingTime?: boolean
    closingTime?: boolean
    availability?: boolean
    baseRate?: boolean
    minCoverageRadius?: boolean
    mileageRate?: boolean
    maxCoverageRadius?: boolean
    serviceID?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ambulanceService"]>

  export type AmbulanceServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    openingTime?: boolean
    closingTime?: boolean
    availability?: boolean
    baseRate?: boolean
    minCoverageRadius?: boolean
    mileageRate?: boolean
    maxCoverageRadius?: boolean
    serviceID?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ambulanceService"]>

  export type AmbulanceServiceSelectScalar = {
    openingTime?: boolean
    closingTime?: boolean
    availability?: boolean
    baseRate?: boolean
    minCoverageRadius?: boolean
    mileageRate?: boolean
    maxCoverageRadius?: boolean
    serviceID?: boolean
  }

  export type AmbulanceServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"openingTime" | "closingTime" | "availability" | "baseRate" | "minCoverageRadius" | "mileageRate" | "maxCoverageRadius" | "serviceID", ExtArgs["result"]["ambulanceService"]>
  export type AmbulanceServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type AmbulanceServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type AmbulanceServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $AmbulanceServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AmbulanceService"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      openingTime: Date | null
      closingTime: Date | null
      availability: $Enums.Availability
      baseRate: number
      minCoverageRadius: number
      mileageRate: number
      maxCoverageRadius: number
      serviceID: string
    }, ExtArgs["result"]["ambulanceService"]>
    composites: {}
  }

  type AmbulanceServiceGetPayload<S extends boolean | null | undefined | AmbulanceServiceDefaultArgs> = $Result.GetResult<Prisma.$AmbulanceServicePayload, S>

  type AmbulanceServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmbulanceServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmbulanceServiceCountAggregateInputType | true
    }

  export interface AmbulanceServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AmbulanceService'], meta: { name: 'AmbulanceService' } }
    /**
     * Find zero or one AmbulanceService that matches the filter.
     * @param {AmbulanceServiceFindUniqueArgs} args - Arguments to find a AmbulanceService
     * @example
     * // Get one AmbulanceService
     * const ambulanceService = await prisma.ambulanceService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmbulanceServiceFindUniqueArgs>(args: SelectSubset<T, AmbulanceServiceFindUniqueArgs<ExtArgs>>): Prisma__AmbulanceServiceClient<$Result.GetResult<Prisma.$AmbulanceServicePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AmbulanceService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmbulanceServiceFindUniqueOrThrowArgs} args - Arguments to find a AmbulanceService
     * @example
     * // Get one AmbulanceService
     * const ambulanceService = await prisma.ambulanceService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmbulanceServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, AmbulanceServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmbulanceServiceClient<$Result.GetResult<Prisma.$AmbulanceServicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AmbulanceService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmbulanceServiceFindFirstArgs} args - Arguments to find a AmbulanceService
     * @example
     * // Get one AmbulanceService
     * const ambulanceService = await prisma.ambulanceService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmbulanceServiceFindFirstArgs>(args?: SelectSubset<T, AmbulanceServiceFindFirstArgs<ExtArgs>>): Prisma__AmbulanceServiceClient<$Result.GetResult<Prisma.$AmbulanceServicePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AmbulanceService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmbulanceServiceFindFirstOrThrowArgs} args - Arguments to find a AmbulanceService
     * @example
     * // Get one AmbulanceService
     * const ambulanceService = await prisma.ambulanceService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmbulanceServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, AmbulanceServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmbulanceServiceClient<$Result.GetResult<Prisma.$AmbulanceServicePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AmbulanceServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmbulanceServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AmbulanceServices
     * const ambulanceServices = await prisma.ambulanceService.findMany()
     * 
     * // Get first 10 AmbulanceServices
     * const ambulanceServices = await prisma.ambulanceService.findMany({ take: 10 })
     * 
     * // Only select the `openingTime`
     * const ambulanceServiceWithOpeningTimeOnly = await prisma.ambulanceService.findMany({ select: { openingTime: true } })
     * 
     */
    findMany<T extends AmbulanceServiceFindManyArgs>(args?: SelectSubset<T, AmbulanceServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmbulanceServicePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AmbulanceService.
     * @param {AmbulanceServiceCreateArgs} args - Arguments to create a AmbulanceService.
     * @example
     * // Create one AmbulanceService
     * const AmbulanceService = await prisma.ambulanceService.create({
     *   data: {
     *     // ... data to create a AmbulanceService
     *   }
     * })
     * 
     */
    create<T extends AmbulanceServiceCreateArgs>(args: SelectSubset<T, AmbulanceServiceCreateArgs<ExtArgs>>): Prisma__AmbulanceServiceClient<$Result.GetResult<Prisma.$AmbulanceServicePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AmbulanceServices.
     * @param {AmbulanceServiceCreateManyArgs} args - Arguments to create many AmbulanceServices.
     * @example
     * // Create many AmbulanceServices
     * const ambulanceService = await prisma.ambulanceService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmbulanceServiceCreateManyArgs>(args?: SelectSubset<T, AmbulanceServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AmbulanceServices and returns the data saved in the database.
     * @param {AmbulanceServiceCreateManyAndReturnArgs} args - Arguments to create many AmbulanceServices.
     * @example
     * // Create many AmbulanceServices
     * const ambulanceService = await prisma.ambulanceService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AmbulanceServices and only return the `openingTime`
     * const ambulanceServiceWithOpeningTimeOnly = await prisma.ambulanceService.createManyAndReturn({
     *   select: { openingTime: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AmbulanceServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, AmbulanceServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmbulanceServicePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AmbulanceService.
     * @param {AmbulanceServiceDeleteArgs} args - Arguments to delete one AmbulanceService.
     * @example
     * // Delete one AmbulanceService
     * const AmbulanceService = await prisma.ambulanceService.delete({
     *   where: {
     *     // ... filter to delete one AmbulanceService
     *   }
     * })
     * 
     */
    delete<T extends AmbulanceServiceDeleteArgs>(args: SelectSubset<T, AmbulanceServiceDeleteArgs<ExtArgs>>): Prisma__AmbulanceServiceClient<$Result.GetResult<Prisma.$AmbulanceServicePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AmbulanceService.
     * @param {AmbulanceServiceUpdateArgs} args - Arguments to update one AmbulanceService.
     * @example
     * // Update one AmbulanceService
     * const ambulanceService = await prisma.ambulanceService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmbulanceServiceUpdateArgs>(args: SelectSubset<T, AmbulanceServiceUpdateArgs<ExtArgs>>): Prisma__AmbulanceServiceClient<$Result.GetResult<Prisma.$AmbulanceServicePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AmbulanceServices.
     * @param {AmbulanceServiceDeleteManyArgs} args - Arguments to filter AmbulanceServices to delete.
     * @example
     * // Delete a few AmbulanceServices
     * const { count } = await prisma.ambulanceService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmbulanceServiceDeleteManyArgs>(args?: SelectSubset<T, AmbulanceServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AmbulanceServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmbulanceServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AmbulanceServices
     * const ambulanceService = await prisma.ambulanceService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmbulanceServiceUpdateManyArgs>(args: SelectSubset<T, AmbulanceServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AmbulanceServices and returns the data updated in the database.
     * @param {AmbulanceServiceUpdateManyAndReturnArgs} args - Arguments to update many AmbulanceServices.
     * @example
     * // Update many AmbulanceServices
     * const ambulanceService = await prisma.ambulanceService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AmbulanceServices and only return the `openingTime`
     * const ambulanceServiceWithOpeningTimeOnly = await prisma.ambulanceService.updateManyAndReturn({
     *   select: { openingTime: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AmbulanceServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, AmbulanceServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmbulanceServicePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AmbulanceService.
     * @param {AmbulanceServiceUpsertArgs} args - Arguments to update or create a AmbulanceService.
     * @example
     * // Update or create a AmbulanceService
     * const ambulanceService = await prisma.ambulanceService.upsert({
     *   create: {
     *     // ... data to create a AmbulanceService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AmbulanceService we want to update
     *   }
     * })
     */
    upsert<T extends AmbulanceServiceUpsertArgs>(args: SelectSubset<T, AmbulanceServiceUpsertArgs<ExtArgs>>): Prisma__AmbulanceServiceClient<$Result.GetResult<Prisma.$AmbulanceServicePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AmbulanceServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmbulanceServiceCountArgs} args - Arguments to filter AmbulanceServices to count.
     * @example
     * // Count the number of AmbulanceServices
     * const count = await prisma.ambulanceService.count({
     *   where: {
     *     // ... the filter for the AmbulanceServices we want to count
     *   }
     * })
    **/
    count<T extends AmbulanceServiceCountArgs>(
      args?: Subset<T, AmbulanceServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmbulanceServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AmbulanceService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmbulanceServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmbulanceServiceAggregateArgs>(args: Subset<T, AmbulanceServiceAggregateArgs>): Prisma.PrismaPromise<GetAmbulanceServiceAggregateType<T>>

    /**
     * Group by AmbulanceService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmbulanceServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmbulanceServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmbulanceServiceGroupByArgs['orderBy'] }
        : { orderBy?: AmbulanceServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmbulanceServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmbulanceServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AmbulanceService model
   */
  readonly fields: AmbulanceServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AmbulanceService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmbulanceServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AmbulanceService model
   */ 
  interface AmbulanceServiceFieldRefs {
    readonly openingTime: FieldRef<"AmbulanceService", 'DateTime'>
    readonly closingTime: FieldRef<"AmbulanceService", 'DateTime'>
    readonly availability: FieldRef<"AmbulanceService", 'Availability'>
    readonly baseRate: FieldRef<"AmbulanceService", 'Float'>
    readonly minCoverageRadius: FieldRef<"AmbulanceService", 'Float'>
    readonly mileageRate: FieldRef<"AmbulanceService", 'Float'>
    readonly maxCoverageRadius: FieldRef<"AmbulanceService", 'Float'>
    readonly serviceID: FieldRef<"AmbulanceService", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AmbulanceService findUnique
   */
  export type AmbulanceServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceInclude<ExtArgs> | null
    /**
     * Filter, which AmbulanceService to fetch.
     */
    where: AmbulanceServiceWhereUniqueInput
  }

  /**
   * AmbulanceService findUniqueOrThrow
   */
  export type AmbulanceServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceInclude<ExtArgs> | null
    /**
     * Filter, which AmbulanceService to fetch.
     */
    where: AmbulanceServiceWhereUniqueInput
  }

  /**
   * AmbulanceService findFirst
   */
  export type AmbulanceServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceInclude<ExtArgs> | null
    /**
     * Filter, which AmbulanceService to fetch.
     */
    where?: AmbulanceServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmbulanceServices to fetch.
     */
    orderBy?: AmbulanceServiceOrderByWithRelationInput | AmbulanceServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AmbulanceServices.
     */
    cursor?: AmbulanceServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmbulanceServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmbulanceServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AmbulanceServices.
     */
    distinct?: AmbulanceServiceScalarFieldEnum | AmbulanceServiceScalarFieldEnum[]
  }

  /**
   * AmbulanceService findFirstOrThrow
   */
  export type AmbulanceServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceInclude<ExtArgs> | null
    /**
     * Filter, which AmbulanceService to fetch.
     */
    where?: AmbulanceServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmbulanceServices to fetch.
     */
    orderBy?: AmbulanceServiceOrderByWithRelationInput | AmbulanceServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AmbulanceServices.
     */
    cursor?: AmbulanceServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmbulanceServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmbulanceServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AmbulanceServices.
     */
    distinct?: AmbulanceServiceScalarFieldEnum | AmbulanceServiceScalarFieldEnum[]
  }

  /**
   * AmbulanceService findMany
   */
  export type AmbulanceServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceInclude<ExtArgs> | null
    /**
     * Filter, which AmbulanceServices to fetch.
     */
    where?: AmbulanceServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AmbulanceServices to fetch.
     */
    orderBy?: AmbulanceServiceOrderByWithRelationInput | AmbulanceServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AmbulanceServices.
     */
    cursor?: AmbulanceServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AmbulanceServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AmbulanceServices.
     */
    skip?: number
    distinct?: AmbulanceServiceScalarFieldEnum | AmbulanceServiceScalarFieldEnum[]
  }

  /**
   * AmbulanceService create
   */
  export type AmbulanceServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a AmbulanceService.
     */
    data: XOR<AmbulanceServiceCreateInput, AmbulanceServiceUncheckedCreateInput>
  }

  /**
   * AmbulanceService createMany
   */
  export type AmbulanceServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AmbulanceServices.
     */
    data: AmbulanceServiceCreateManyInput | AmbulanceServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AmbulanceService createManyAndReturn
   */
  export type AmbulanceServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * The data used to create many AmbulanceServices.
     */
    data: AmbulanceServiceCreateManyInput | AmbulanceServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AmbulanceService update
   */
  export type AmbulanceServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a AmbulanceService.
     */
    data: XOR<AmbulanceServiceUpdateInput, AmbulanceServiceUncheckedUpdateInput>
    /**
     * Choose, which AmbulanceService to update.
     */
    where: AmbulanceServiceWhereUniqueInput
  }

  /**
   * AmbulanceService updateMany
   */
  export type AmbulanceServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AmbulanceServices.
     */
    data: XOR<AmbulanceServiceUpdateManyMutationInput, AmbulanceServiceUncheckedUpdateManyInput>
    /**
     * Filter which AmbulanceServices to update
     */
    where?: AmbulanceServiceWhereInput
    /**
     * Limit how many AmbulanceServices to update.
     */
    limit?: number
  }

  /**
   * AmbulanceService updateManyAndReturn
   */
  export type AmbulanceServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * The data used to update AmbulanceServices.
     */
    data: XOR<AmbulanceServiceUpdateManyMutationInput, AmbulanceServiceUncheckedUpdateManyInput>
    /**
     * Filter which AmbulanceServices to update
     */
    where?: AmbulanceServiceWhereInput
    /**
     * Limit how many AmbulanceServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AmbulanceService upsert
   */
  export type AmbulanceServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the AmbulanceService to update in case it exists.
     */
    where: AmbulanceServiceWhereUniqueInput
    /**
     * In case the AmbulanceService found by the `where` argument doesn't exist, create a new AmbulanceService with this data.
     */
    create: XOR<AmbulanceServiceCreateInput, AmbulanceServiceUncheckedCreateInput>
    /**
     * In case the AmbulanceService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmbulanceServiceUpdateInput, AmbulanceServiceUncheckedUpdateInput>
  }

  /**
   * AmbulanceService delete
   */
  export type AmbulanceServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceInclude<ExtArgs> | null
    /**
     * Filter which AmbulanceService to delete.
     */
    where: AmbulanceServiceWhereUniqueInput
  }

  /**
   * AmbulanceService deleteMany
   */
  export type AmbulanceServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AmbulanceServices to delete
     */
    where?: AmbulanceServiceWhereInput
    /**
     * Limit how many AmbulanceServices to delete.
     */
    limit?: number
  }

  /**
   * AmbulanceService without action
   */
  export type AmbulanceServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmbulanceService
     */
    select?: AmbulanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AmbulanceService
     */
    omit?: AmbulanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmbulanceServiceInclude<ExtArgs> | null
  }


  /**
   * Model BloodTypeMapping
   */

  export type AggregateBloodTypeMapping = {
    _count: BloodTypeMappingCountAggregateOutputType | null
    _min: BloodTypeMappingMinAggregateOutputType | null
    _max: BloodTypeMappingMaxAggregateOutputType | null
  }

  export type BloodTypeMappingMinAggregateOutputType = {
    A_P: boolean | null
    A_N: boolean | null
    B_P: boolean | null
    B_N: boolean | null
    O_P: boolean | null
    O_N: boolean | null
    AB_P: boolean | null
    AB_N: boolean | null
    serviceID: string | null
  }

  export type BloodTypeMappingMaxAggregateOutputType = {
    A_P: boolean | null
    A_N: boolean | null
    B_P: boolean | null
    B_N: boolean | null
    O_P: boolean | null
    O_N: boolean | null
    AB_P: boolean | null
    AB_N: boolean | null
    serviceID: string | null
  }

  export type BloodTypeMappingCountAggregateOutputType = {
    A_P: number
    A_N: number
    B_P: number
    B_N: number
    O_P: number
    O_N: number
    AB_P: number
    AB_N: number
    serviceID: number
    _all: number
  }


  export type BloodTypeMappingMinAggregateInputType = {
    A_P?: true
    A_N?: true
    B_P?: true
    B_N?: true
    O_P?: true
    O_N?: true
    AB_P?: true
    AB_N?: true
    serviceID?: true
  }

  export type BloodTypeMappingMaxAggregateInputType = {
    A_P?: true
    A_N?: true
    B_P?: true
    B_N?: true
    O_P?: true
    O_N?: true
    AB_P?: true
    AB_N?: true
    serviceID?: true
  }

  export type BloodTypeMappingCountAggregateInputType = {
    A_P?: true
    A_N?: true
    B_P?: true
    B_N?: true
    O_P?: true
    O_N?: true
    AB_P?: true
    AB_N?: true
    serviceID?: true
    _all?: true
  }

  export type BloodTypeMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BloodTypeMapping to aggregate.
     */
    where?: BloodTypeMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BloodTypeMappings to fetch.
     */
    orderBy?: BloodTypeMappingOrderByWithRelationInput | BloodTypeMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BloodTypeMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BloodTypeMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BloodTypeMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BloodTypeMappings
    **/
    _count?: true | BloodTypeMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BloodTypeMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BloodTypeMappingMaxAggregateInputType
  }

  export type GetBloodTypeMappingAggregateType<T extends BloodTypeMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateBloodTypeMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBloodTypeMapping[P]>
      : GetScalarType<T[P], AggregateBloodTypeMapping[P]>
  }




  export type BloodTypeMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BloodTypeMappingWhereInput
    orderBy?: BloodTypeMappingOrderByWithAggregationInput | BloodTypeMappingOrderByWithAggregationInput[]
    by: BloodTypeMappingScalarFieldEnum[] | BloodTypeMappingScalarFieldEnum
    having?: BloodTypeMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BloodTypeMappingCountAggregateInputType | true
    _min?: BloodTypeMappingMinAggregateInputType
    _max?: BloodTypeMappingMaxAggregateInputType
  }

  export type BloodTypeMappingGroupByOutputType = {
    A_P: boolean
    A_N: boolean
    B_P: boolean
    B_N: boolean
    O_P: boolean
    O_N: boolean
    AB_P: boolean
    AB_N: boolean
    serviceID: string
    _count: BloodTypeMappingCountAggregateOutputType | null
    _min: BloodTypeMappingMinAggregateOutputType | null
    _max: BloodTypeMappingMaxAggregateOutputType | null
  }

  type GetBloodTypeMappingGroupByPayload<T extends BloodTypeMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BloodTypeMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BloodTypeMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BloodTypeMappingGroupByOutputType[P]>
            : GetScalarType<T[P], BloodTypeMappingGroupByOutputType[P]>
        }
      >
    >


  export type BloodTypeMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    A_P?: boolean
    A_N?: boolean
    B_P?: boolean
    B_N?: boolean
    O_P?: boolean
    O_N?: boolean
    AB_P?: boolean
    AB_N?: boolean
    serviceID?: boolean
    BloodBankService?: boolean | BloodBankServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bloodTypeMapping"]>

  export type BloodTypeMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    A_P?: boolean
    A_N?: boolean
    B_P?: boolean
    B_N?: boolean
    O_P?: boolean
    O_N?: boolean
    AB_P?: boolean
    AB_N?: boolean
    serviceID?: boolean
    BloodBankService?: boolean | BloodBankServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bloodTypeMapping"]>

  export type BloodTypeMappingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    A_P?: boolean
    A_N?: boolean
    B_P?: boolean
    B_N?: boolean
    O_P?: boolean
    O_N?: boolean
    AB_P?: boolean
    AB_N?: boolean
    serviceID?: boolean
    BloodBankService?: boolean | BloodBankServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bloodTypeMapping"]>

  export type BloodTypeMappingSelectScalar = {
    A_P?: boolean
    A_N?: boolean
    B_P?: boolean
    B_N?: boolean
    O_P?: boolean
    O_N?: boolean
    AB_P?: boolean
    AB_N?: boolean
    serviceID?: boolean
  }

  export type BloodTypeMappingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"A_P" | "A_N" | "B_P" | "B_N" | "O_P" | "O_N" | "AB_P" | "AB_N" | "serviceID", ExtArgs["result"]["bloodTypeMapping"]>
  export type BloodTypeMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BloodBankService?: boolean | BloodBankServiceDefaultArgs<ExtArgs>
  }
  export type BloodTypeMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BloodBankService?: boolean | BloodBankServiceDefaultArgs<ExtArgs>
  }
  export type BloodTypeMappingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BloodBankService?: boolean | BloodBankServiceDefaultArgs<ExtArgs>
  }

  export type $BloodTypeMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BloodTypeMapping"
    objects: {
      BloodBankService: Prisma.$BloodBankServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      A_P: boolean
      A_N: boolean
      B_P: boolean
      B_N: boolean
      O_P: boolean
      O_N: boolean
      AB_P: boolean
      AB_N: boolean
      serviceID: string
    }, ExtArgs["result"]["bloodTypeMapping"]>
    composites: {}
  }

  type BloodTypeMappingGetPayload<S extends boolean | null | undefined | BloodTypeMappingDefaultArgs> = $Result.GetResult<Prisma.$BloodTypeMappingPayload, S>

  type BloodTypeMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BloodTypeMappingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BloodTypeMappingCountAggregateInputType | true
    }

  export interface BloodTypeMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BloodTypeMapping'], meta: { name: 'BloodTypeMapping' } }
    /**
     * Find zero or one BloodTypeMapping that matches the filter.
     * @param {BloodTypeMappingFindUniqueArgs} args - Arguments to find a BloodTypeMapping
     * @example
     * // Get one BloodTypeMapping
     * const bloodTypeMapping = await prisma.bloodTypeMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BloodTypeMappingFindUniqueArgs>(args: SelectSubset<T, BloodTypeMappingFindUniqueArgs<ExtArgs>>): Prisma__BloodTypeMappingClient<$Result.GetResult<Prisma.$BloodTypeMappingPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BloodTypeMapping that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BloodTypeMappingFindUniqueOrThrowArgs} args - Arguments to find a BloodTypeMapping
     * @example
     * // Get one BloodTypeMapping
     * const bloodTypeMapping = await prisma.bloodTypeMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BloodTypeMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, BloodTypeMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BloodTypeMappingClient<$Result.GetResult<Prisma.$BloodTypeMappingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BloodTypeMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloodTypeMappingFindFirstArgs} args - Arguments to find a BloodTypeMapping
     * @example
     * // Get one BloodTypeMapping
     * const bloodTypeMapping = await prisma.bloodTypeMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BloodTypeMappingFindFirstArgs>(args?: SelectSubset<T, BloodTypeMappingFindFirstArgs<ExtArgs>>): Prisma__BloodTypeMappingClient<$Result.GetResult<Prisma.$BloodTypeMappingPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BloodTypeMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloodTypeMappingFindFirstOrThrowArgs} args - Arguments to find a BloodTypeMapping
     * @example
     * // Get one BloodTypeMapping
     * const bloodTypeMapping = await prisma.bloodTypeMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BloodTypeMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, BloodTypeMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BloodTypeMappingClient<$Result.GetResult<Prisma.$BloodTypeMappingPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BloodTypeMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloodTypeMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BloodTypeMappings
     * const bloodTypeMappings = await prisma.bloodTypeMapping.findMany()
     * 
     * // Get first 10 BloodTypeMappings
     * const bloodTypeMappings = await prisma.bloodTypeMapping.findMany({ take: 10 })
     * 
     * // Only select the `A_P`
     * const bloodTypeMappingWithA_POnly = await prisma.bloodTypeMapping.findMany({ select: { A_P: true } })
     * 
     */
    findMany<T extends BloodTypeMappingFindManyArgs>(args?: SelectSubset<T, BloodTypeMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BloodTypeMappingPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BloodTypeMapping.
     * @param {BloodTypeMappingCreateArgs} args - Arguments to create a BloodTypeMapping.
     * @example
     * // Create one BloodTypeMapping
     * const BloodTypeMapping = await prisma.bloodTypeMapping.create({
     *   data: {
     *     // ... data to create a BloodTypeMapping
     *   }
     * })
     * 
     */
    create<T extends BloodTypeMappingCreateArgs>(args: SelectSubset<T, BloodTypeMappingCreateArgs<ExtArgs>>): Prisma__BloodTypeMappingClient<$Result.GetResult<Prisma.$BloodTypeMappingPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BloodTypeMappings.
     * @param {BloodTypeMappingCreateManyArgs} args - Arguments to create many BloodTypeMappings.
     * @example
     * // Create many BloodTypeMappings
     * const bloodTypeMapping = await prisma.bloodTypeMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BloodTypeMappingCreateManyArgs>(args?: SelectSubset<T, BloodTypeMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BloodTypeMappings and returns the data saved in the database.
     * @param {BloodTypeMappingCreateManyAndReturnArgs} args - Arguments to create many BloodTypeMappings.
     * @example
     * // Create many BloodTypeMappings
     * const bloodTypeMapping = await prisma.bloodTypeMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BloodTypeMappings and only return the `A_P`
     * const bloodTypeMappingWithA_POnly = await prisma.bloodTypeMapping.createManyAndReturn({
     *   select: { A_P: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BloodTypeMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, BloodTypeMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BloodTypeMappingPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a BloodTypeMapping.
     * @param {BloodTypeMappingDeleteArgs} args - Arguments to delete one BloodTypeMapping.
     * @example
     * // Delete one BloodTypeMapping
     * const BloodTypeMapping = await prisma.bloodTypeMapping.delete({
     *   where: {
     *     // ... filter to delete one BloodTypeMapping
     *   }
     * })
     * 
     */
    delete<T extends BloodTypeMappingDeleteArgs>(args: SelectSubset<T, BloodTypeMappingDeleteArgs<ExtArgs>>): Prisma__BloodTypeMappingClient<$Result.GetResult<Prisma.$BloodTypeMappingPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BloodTypeMapping.
     * @param {BloodTypeMappingUpdateArgs} args - Arguments to update one BloodTypeMapping.
     * @example
     * // Update one BloodTypeMapping
     * const bloodTypeMapping = await prisma.bloodTypeMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BloodTypeMappingUpdateArgs>(args: SelectSubset<T, BloodTypeMappingUpdateArgs<ExtArgs>>): Prisma__BloodTypeMappingClient<$Result.GetResult<Prisma.$BloodTypeMappingPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BloodTypeMappings.
     * @param {BloodTypeMappingDeleteManyArgs} args - Arguments to filter BloodTypeMappings to delete.
     * @example
     * // Delete a few BloodTypeMappings
     * const { count } = await prisma.bloodTypeMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BloodTypeMappingDeleteManyArgs>(args?: SelectSubset<T, BloodTypeMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BloodTypeMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloodTypeMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BloodTypeMappings
     * const bloodTypeMapping = await prisma.bloodTypeMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BloodTypeMappingUpdateManyArgs>(args: SelectSubset<T, BloodTypeMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BloodTypeMappings and returns the data updated in the database.
     * @param {BloodTypeMappingUpdateManyAndReturnArgs} args - Arguments to update many BloodTypeMappings.
     * @example
     * // Update many BloodTypeMappings
     * const bloodTypeMapping = await prisma.bloodTypeMapping.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BloodTypeMappings and only return the `A_P`
     * const bloodTypeMappingWithA_POnly = await prisma.bloodTypeMapping.updateManyAndReturn({
     *   select: { A_P: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BloodTypeMappingUpdateManyAndReturnArgs>(args: SelectSubset<T, BloodTypeMappingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BloodTypeMappingPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one BloodTypeMapping.
     * @param {BloodTypeMappingUpsertArgs} args - Arguments to update or create a BloodTypeMapping.
     * @example
     * // Update or create a BloodTypeMapping
     * const bloodTypeMapping = await prisma.bloodTypeMapping.upsert({
     *   create: {
     *     // ... data to create a BloodTypeMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BloodTypeMapping we want to update
     *   }
     * })
     */
    upsert<T extends BloodTypeMappingUpsertArgs>(args: SelectSubset<T, BloodTypeMappingUpsertArgs<ExtArgs>>): Prisma__BloodTypeMappingClient<$Result.GetResult<Prisma.$BloodTypeMappingPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BloodTypeMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloodTypeMappingCountArgs} args - Arguments to filter BloodTypeMappings to count.
     * @example
     * // Count the number of BloodTypeMappings
     * const count = await prisma.bloodTypeMapping.count({
     *   where: {
     *     // ... the filter for the BloodTypeMappings we want to count
     *   }
     * })
    **/
    count<T extends BloodTypeMappingCountArgs>(
      args?: Subset<T, BloodTypeMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BloodTypeMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BloodTypeMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloodTypeMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BloodTypeMappingAggregateArgs>(args: Subset<T, BloodTypeMappingAggregateArgs>): Prisma.PrismaPromise<GetBloodTypeMappingAggregateType<T>>

    /**
     * Group by BloodTypeMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloodTypeMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BloodTypeMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BloodTypeMappingGroupByArgs['orderBy'] }
        : { orderBy?: BloodTypeMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BloodTypeMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBloodTypeMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BloodTypeMapping model
   */
  readonly fields: BloodTypeMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BloodTypeMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BloodTypeMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BloodBankService<T extends BloodBankServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BloodBankServiceDefaultArgs<ExtArgs>>): Prisma__BloodBankServiceClient<$Result.GetResult<Prisma.$BloodBankServicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BloodTypeMapping model
   */ 
  interface BloodTypeMappingFieldRefs {
    readonly A_P: FieldRef<"BloodTypeMapping", 'Boolean'>
    readonly A_N: FieldRef<"BloodTypeMapping", 'Boolean'>
    readonly B_P: FieldRef<"BloodTypeMapping", 'Boolean'>
    readonly B_N: FieldRef<"BloodTypeMapping", 'Boolean'>
    readonly O_P: FieldRef<"BloodTypeMapping", 'Boolean'>
    readonly O_N: FieldRef<"BloodTypeMapping", 'Boolean'>
    readonly AB_P: FieldRef<"BloodTypeMapping", 'Boolean'>
    readonly AB_N: FieldRef<"BloodTypeMapping", 'Boolean'>
    readonly serviceID: FieldRef<"BloodTypeMapping", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BloodTypeMapping findUnique
   */
  export type BloodTypeMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodTypeMapping
     */
    select?: BloodTypeMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BloodTypeMapping
     */
    omit?: BloodTypeMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodTypeMappingInclude<ExtArgs> | null
    /**
     * Filter, which BloodTypeMapping to fetch.
     */
    where: BloodTypeMappingWhereUniqueInput
  }

  /**
   * BloodTypeMapping findUniqueOrThrow
   */
  export type BloodTypeMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodTypeMapping
     */
    select?: BloodTypeMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BloodTypeMapping
     */
    omit?: BloodTypeMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodTypeMappingInclude<ExtArgs> | null
    /**
     * Filter, which BloodTypeMapping to fetch.
     */
    where: BloodTypeMappingWhereUniqueInput
  }

  /**
   * BloodTypeMapping findFirst
   */
  export type BloodTypeMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodTypeMapping
     */
    select?: BloodTypeMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BloodTypeMapping
     */
    omit?: BloodTypeMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodTypeMappingInclude<ExtArgs> | null
    /**
     * Filter, which BloodTypeMapping to fetch.
     */
    where?: BloodTypeMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BloodTypeMappings to fetch.
     */
    orderBy?: BloodTypeMappingOrderByWithRelationInput | BloodTypeMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BloodTypeMappings.
     */
    cursor?: BloodTypeMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BloodTypeMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BloodTypeMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BloodTypeMappings.
     */
    distinct?: BloodTypeMappingScalarFieldEnum | BloodTypeMappingScalarFieldEnum[]
  }

  /**
   * BloodTypeMapping findFirstOrThrow
   */
  export type BloodTypeMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodTypeMapping
     */
    select?: BloodTypeMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BloodTypeMapping
     */
    omit?: BloodTypeMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodTypeMappingInclude<ExtArgs> | null
    /**
     * Filter, which BloodTypeMapping to fetch.
     */
    where?: BloodTypeMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BloodTypeMappings to fetch.
     */
    orderBy?: BloodTypeMappingOrderByWithRelationInput | BloodTypeMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BloodTypeMappings.
     */
    cursor?: BloodTypeMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BloodTypeMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BloodTypeMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BloodTypeMappings.
     */
    distinct?: BloodTypeMappingScalarFieldEnum | BloodTypeMappingScalarFieldEnum[]
  }

  /**
   * BloodTypeMapping findMany
   */
  export type BloodTypeMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodTypeMapping
     */
    select?: BloodTypeMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BloodTypeMapping
     */
    omit?: BloodTypeMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodTypeMappingInclude<ExtArgs> | null
    /**
     * Filter, which BloodTypeMappings to fetch.
     */
    where?: BloodTypeMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BloodTypeMappings to fetch.
     */
    orderBy?: BloodTypeMappingOrderByWithRelationInput | BloodTypeMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BloodTypeMappings.
     */
    cursor?: BloodTypeMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BloodTypeMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BloodTypeMappings.
     */
    skip?: number
    distinct?: BloodTypeMappingScalarFieldEnum | BloodTypeMappingScalarFieldEnum[]
  }

  /**
   * BloodTypeMapping create
   */
  export type BloodTypeMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodTypeMapping
     */
    select?: BloodTypeMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BloodTypeMapping
     */
    omit?: BloodTypeMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodTypeMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a BloodTypeMapping.
     */
    data: XOR<BloodTypeMappingCreateInput, BloodTypeMappingUncheckedCreateInput>
  }

  /**
   * BloodTypeMapping createMany
   */
  export type BloodTypeMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BloodTypeMappings.
     */
    data: BloodTypeMappingCreateManyInput | BloodTypeMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BloodTypeMapping createManyAndReturn
   */
  export type BloodTypeMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodTypeMapping
     */
    select?: BloodTypeMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BloodTypeMapping
     */
    omit?: BloodTypeMappingOmit<ExtArgs> | null
    /**
     * The data used to create many BloodTypeMappings.
     */
    data: BloodTypeMappingCreateManyInput | BloodTypeMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodTypeMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BloodTypeMapping update
   */
  export type BloodTypeMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodTypeMapping
     */
    select?: BloodTypeMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BloodTypeMapping
     */
    omit?: BloodTypeMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodTypeMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a BloodTypeMapping.
     */
    data: XOR<BloodTypeMappingUpdateInput, BloodTypeMappingUncheckedUpdateInput>
    /**
     * Choose, which BloodTypeMapping to update.
     */
    where: BloodTypeMappingWhereUniqueInput
  }

  /**
   * BloodTypeMapping updateMany
   */
  export type BloodTypeMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BloodTypeMappings.
     */
    data: XOR<BloodTypeMappingUpdateManyMutationInput, BloodTypeMappingUncheckedUpdateManyInput>
    /**
     * Filter which BloodTypeMappings to update
     */
    where?: BloodTypeMappingWhereInput
    /**
     * Limit how many BloodTypeMappings to update.
     */
    limit?: number
  }

  /**
   * BloodTypeMapping updateManyAndReturn
   */
  export type BloodTypeMappingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodTypeMapping
     */
    select?: BloodTypeMappingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BloodTypeMapping
     */
    omit?: BloodTypeMappingOmit<ExtArgs> | null
    /**
     * The data used to update BloodTypeMappings.
     */
    data: XOR<BloodTypeMappingUpdateManyMutationInput, BloodTypeMappingUncheckedUpdateManyInput>
    /**
     * Filter which BloodTypeMappings to update
     */
    where?: BloodTypeMappingWhereInput
    /**
     * Limit how many BloodTypeMappings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodTypeMappingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BloodTypeMapping upsert
   */
  export type BloodTypeMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodTypeMapping
     */
    select?: BloodTypeMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BloodTypeMapping
     */
    omit?: BloodTypeMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodTypeMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the BloodTypeMapping to update in case it exists.
     */
    where: BloodTypeMappingWhereUniqueInput
    /**
     * In case the BloodTypeMapping found by the `where` argument doesn't exist, create a new BloodTypeMapping with this data.
     */
    create: XOR<BloodTypeMappingCreateInput, BloodTypeMappingUncheckedCreateInput>
    /**
     * In case the BloodTypeMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BloodTypeMappingUpdateInput, BloodTypeMappingUncheckedUpdateInput>
  }

  /**
   * BloodTypeMapping delete
   */
  export type BloodTypeMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodTypeMapping
     */
    select?: BloodTypeMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BloodTypeMapping
     */
    omit?: BloodTypeMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodTypeMappingInclude<ExtArgs> | null
    /**
     * Filter which BloodTypeMapping to delete.
     */
    where: BloodTypeMappingWhereUniqueInput
  }

  /**
   * BloodTypeMapping deleteMany
   */
  export type BloodTypeMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BloodTypeMappings to delete
     */
    where?: BloodTypeMappingWhereInput
    /**
     * Limit how many BloodTypeMappings to delete.
     */
    limit?: number
  }

  /**
   * BloodTypeMapping without action
   */
  export type BloodTypeMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodTypeMapping
     */
    select?: BloodTypeMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BloodTypeMapping
     */
    omit?: BloodTypeMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodTypeMappingInclude<ExtArgs> | null
  }


  /**
   * Model BloodBankService
   */

  export type AggregateBloodBankService = {
    _count: BloodBankServiceCountAggregateOutputType | null
    _avg: BloodBankServiceAvgAggregateOutputType | null
    _sum: BloodBankServiceSumAggregateOutputType | null
    _min: BloodBankServiceMinAggregateOutputType | null
    _max: BloodBankServiceMaxAggregateOutputType | null
  }

  export type BloodBankServiceAvgAggregateOutputType = {
    basePricePerUnit: number | null
    turnaroundTimeD: number | null
    turnaroundTimeH: number | null
  }

  export type BloodBankServiceSumAggregateOutputType = {
    basePricePerUnit: number | null
    turnaroundTimeD: number | null
    turnaroundTimeH: number | null
  }

  export type BloodBankServiceMinAggregateOutputType = {
    openingTime: Date | null
    closingTime: Date | null
    basePricePerUnit: number | null
    turnaroundTimeD: number | null
    turnaroundTimeH: number | null
    serviceID: string | null
  }

  export type BloodBankServiceMaxAggregateOutputType = {
    openingTime: Date | null
    closingTime: Date | null
    basePricePerUnit: number | null
    turnaroundTimeD: number | null
    turnaroundTimeH: number | null
    serviceID: string | null
  }

  export type BloodBankServiceCountAggregateOutputType = {
    openingTime: number
    closingTime: number
    basePricePerUnit: number
    turnaroundTimeD: number
    turnaroundTimeH: number
    serviceID: number
    _all: number
  }


  export type BloodBankServiceAvgAggregateInputType = {
    basePricePerUnit?: true
    turnaroundTimeD?: true
    turnaroundTimeH?: true
  }

  export type BloodBankServiceSumAggregateInputType = {
    basePricePerUnit?: true
    turnaroundTimeD?: true
    turnaroundTimeH?: true
  }

  export type BloodBankServiceMinAggregateInputType = {
    openingTime?: true
    closingTime?: true
    basePricePerUnit?: true
    turnaroundTimeD?: true
    turnaroundTimeH?: true
    serviceID?: true
  }

  export type BloodBankServiceMaxAggregateInputType = {
    openingTime?: true
    closingTime?: true
    basePricePerUnit?: true
    turnaroundTimeD?: true
    turnaroundTimeH?: true
    serviceID?: true
  }

  export type BloodBankServiceCountAggregateInputType = {
    openingTime?: true
    closingTime?: true
    basePricePerUnit?: true
    turnaroundTimeD?: true
    turnaroundTimeH?: true
    serviceID?: true
    _all?: true
  }

  export type BloodBankServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BloodBankService to aggregate.
     */
    where?: BloodBankServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BloodBankServices to fetch.
     */
    orderBy?: BloodBankServiceOrderByWithRelationInput | BloodBankServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BloodBankServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BloodBankServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BloodBankServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BloodBankServices
    **/
    _count?: true | BloodBankServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BloodBankServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BloodBankServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BloodBankServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BloodBankServiceMaxAggregateInputType
  }

  export type GetBloodBankServiceAggregateType<T extends BloodBankServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateBloodBankService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBloodBankService[P]>
      : GetScalarType<T[P], AggregateBloodBankService[P]>
  }




  export type BloodBankServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BloodBankServiceWhereInput
    orderBy?: BloodBankServiceOrderByWithAggregationInput | BloodBankServiceOrderByWithAggregationInput[]
    by: BloodBankServiceScalarFieldEnum[] | BloodBankServiceScalarFieldEnum
    having?: BloodBankServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BloodBankServiceCountAggregateInputType | true
    _avg?: BloodBankServiceAvgAggregateInputType
    _sum?: BloodBankServiceSumAggregateInputType
    _min?: BloodBankServiceMinAggregateInputType
    _max?: BloodBankServiceMaxAggregateInputType
  }

  export type BloodBankServiceGroupByOutputType = {
    openingTime: Date | null
    closingTime: Date | null
    basePricePerUnit: number
    turnaroundTimeD: number
    turnaroundTimeH: number
    serviceID: string
    _count: BloodBankServiceCountAggregateOutputType | null
    _avg: BloodBankServiceAvgAggregateOutputType | null
    _sum: BloodBankServiceSumAggregateOutputType | null
    _min: BloodBankServiceMinAggregateOutputType | null
    _max: BloodBankServiceMaxAggregateOutputType | null
  }

  type GetBloodBankServiceGroupByPayload<T extends BloodBankServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BloodBankServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BloodBankServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BloodBankServiceGroupByOutputType[P]>
            : GetScalarType<T[P], BloodBankServiceGroupByOutputType[P]>
        }
      >
    >


  export type BloodBankServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    openingTime?: boolean
    closingTime?: boolean
    basePricePerUnit?: boolean
    turnaroundTimeD?: boolean
    turnaroundTimeH?: boolean
    serviceID?: boolean
    bloodTypeAvailability?: boolean | BloodBankService$bloodTypeAvailabilityArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bloodBankService"]>

  export type BloodBankServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    openingTime?: boolean
    closingTime?: boolean
    basePricePerUnit?: boolean
    turnaroundTimeD?: boolean
    turnaroundTimeH?: boolean
    serviceID?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bloodBankService"]>

  export type BloodBankServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    openingTime?: boolean
    closingTime?: boolean
    basePricePerUnit?: boolean
    turnaroundTimeD?: boolean
    turnaroundTimeH?: boolean
    serviceID?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bloodBankService"]>

  export type BloodBankServiceSelectScalar = {
    openingTime?: boolean
    closingTime?: boolean
    basePricePerUnit?: boolean
    turnaroundTimeD?: boolean
    turnaroundTimeH?: boolean
    serviceID?: boolean
  }

  export type BloodBankServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"openingTime" | "closingTime" | "basePricePerUnit" | "turnaroundTimeD" | "turnaroundTimeH" | "serviceID", ExtArgs["result"]["bloodBankService"]>
  export type BloodBankServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bloodTypeAvailability?: boolean | BloodBankService$bloodTypeAvailabilityArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type BloodBankServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type BloodBankServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $BloodBankServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BloodBankService"
    objects: {
      bloodTypeAvailability: Prisma.$BloodTypeMappingPayload<ExtArgs> | null
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      openingTime: Date | null
      closingTime: Date | null
      basePricePerUnit: number
      turnaroundTimeD: number
      turnaroundTimeH: number
      serviceID: string
    }, ExtArgs["result"]["bloodBankService"]>
    composites: {}
  }

  type BloodBankServiceGetPayload<S extends boolean | null | undefined | BloodBankServiceDefaultArgs> = $Result.GetResult<Prisma.$BloodBankServicePayload, S>

  type BloodBankServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BloodBankServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BloodBankServiceCountAggregateInputType | true
    }

  export interface BloodBankServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BloodBankService'], meta: { name: 'BloodBankService' } }
    /**
     * Find zero or one BloodBankService that matches the filter.
     * @param {BloodBankServiceFindUniqueArgs} args - Arguments to find a BloodBankService
     * @example
     * // Get one BloodBankService
     * const bloodBankService = await prisma.bloodBankService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BloodBankServiceFindUniqueArgs>(args: SelectSubset<T, BloodBankServiceFindUniqueArgs<ExtArgs>>): Prisma__BloodBankServiceClient<$Result.GetResult<Prisma.$BloodBankServicePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BloodBankService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BloodBankServiceFindUniqueOrThrowArgs} args - Arguments to find a BloodBankService
     * @example
     * // Get one BloodBankService
     * const bloodBankService = await prisma.bloodBankService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BloodBankServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, BloodBankServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BloodBankServiceClient<$Result.GetResult<Prisma.$BloodBankServicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BloodBankService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloodBankServiceFindFirstArgs} args - Arguments to find a BloodBankService
     * @example
     * // Get one BloodBankService
     * const bloodBankService = await prisma.bloodBankService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BloodBankServiceFindFirstArgs>(args?: SelectSubset<T, BloodBankServiceFindFirstArgs<ExtArgs>>): Prisma__BloodBankServiceClient<$Result.GetResult<Prisma.$BloodBankServicePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BloodBankService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloodBankServiceFindFirstOrThrowArgs} args - Arguments to find a BloodBankService
     * @example
     * // Get one BloodBankService
     * const bloodBankService = await prisma.bloodBankService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BloodBankServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, BloodBankServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__BloodBankServiceClient<$Result.GetResult<Prisma.$BloodBankServicePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BloodBankServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloodBankServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BloodBankServices
     * const bloodBankServices = await prisma.bloodBankService.findMany()
     * 
     * // Get first 10 BloodBankServices
     * const bloodBankServices = await prisma.bloodBankService.findMany({ take: 10 })
     * 
     * // Only select the `openingTime`
     * const bloodBankServiceWithOpeningTimeOnly = await prisma.bloodBankService.findMany({ select: { openingTime: true } })
     * 
     */
    findMany<T extends BloodBankServiceFindManyArgs>(args?: SelectSubset<T, BloodBankServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BloodBankServicePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BloodBankService.
     * @param {BloodBankServiceCreateArgs} args - Arguments to create a BloodBankService.
     * @example
     * // Create one BloodBankService
     * const BloodBankService = await prisma.bloodBankService.create({
     *   data: {
     *     // ... data to create a BloodBankService
     *   }
     * })
     * 
     */
    create<T extends BloodBankServiceCreateArgs>(args: SelectSubset<T, BloodBankServiceCreateArgs<ExtArgs>>): Prisma__BloodBankServiceClient<$Result.GetResult<Prisma.$BloodBankServicePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BloodBankServices.
     * @param {BloodBankServiceCreateManyArgs} args - Arguments to create many BloodBankServices.
     * @example
     * // Create many BloodBankServices
     * const bloodBankService = await prisma.bloodBankService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BloodBankServiceCreateManyArgs>(args?: SelectSubset<T, BloodBankServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BloodBankServices and returns the data saved in the database.
     * @param {BloodBankServiceCreateManyAndReturnArgs} args - Arguments to create many BloodBankServices.
     * @example
     * // Create many BloodBankServices
     * const bloodBankService = await prisma.bloodBankService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BloodBankServices and only return the `openingTime`
     * const bloodBankServiceWithOpeningTimeOnly = await prisma.bloodBankService.createManyAndReturn({
     *   select: { openingTime: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BloodBankServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, BloodBankServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BloodBankServicePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a BloodBankService.
     * @param {BloodBankServiceDeleteArgs} args - Arguments to delete one BloodBankService.
     * @example
     * // Delete one BloodBankService
     * const BloodBankService = await prisma.bloodBankService.delete({
     *   where: {
     *     // ... filter to delete one BloodBankService
     *   }
     * })
     * 
     */
    delete<T extends BloodBankServiceDeleteArgs>(args: SelectSubset<T, BloodBankServiceDeleteArgs<ExtArgs>>): Prisma__BloodBankServiceClient<$Result.GetResult<Prisma.$BloodBankServicePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BloodBankService.
     * @param {BloodBankServiceUpdateArgs} args - Arguments to update one BloodBankService.
     * @example
     * // Update one BloodBankService
     * const bloodBankService = await prisma.bloodBankService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BloodBankServiceUpdateArgs>(args: SelectSubset<T, BloodBankServiceUpdateArgs<ExtArgs>>): Prisma__BloodBankServiceClient<$Result.GetResult<Prisma.$BloodBankServicePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BloodBankServices.
     * @param {BloodBankServiceDeleteManyArgs} args - Arguments to filter BloodBankServices to delete.
     * @example
     * // Delete a few BloodBankServices
     * const { count } = await prisma.bloodBankService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BloodBankServiceDeleteManyArgs>(args?: SelectSubset<T, BloodBankServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BloodBankServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloodBankServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BloodBankServices
     * const bloodBankService = await prisma.bloodBankService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BloodBankServiceUpdateManyArgs>(args: SelectSubset<T, BloodBankServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BloodBankServices and returns the data updated in the database.
     * @param {BloodBankServiceUpdateManyAndReturnArgs} args - Arguments to update many BloodBankServices.
     * @example
     * // Update many BloodBankServices
     * const bloodBankService = await prisma.bloodBankService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BloodBankServices and only return the `openingTime`
     * const bloodBankServiceWithOpeningTimeOnly = await prisma.bloodBankService.updateManyAndReturn({
     *   select: { openingTime: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BloodBankServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, BloodBankServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BloodBankServicePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one BloodBankService.
     * @param {BloodBankServiceUpsertArgs} args - Arguments to update or create a BloodBankService.
     * @example
     * // Update or create a BloodBankService
     * const bloodBankService = await prisma.bloodBankService.upsert({
     *   create: {
     *     // ... data to create a BloodBankService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BloodBankService we want to update
     *   }
     * })
     */
    upsert<T extends BloodBankServiceUpsertArgs>(args: SelectSubset<T, BloodBankServiceUpsertArgs<ExtArgs>>): Prisma__BloodBankServiceClient<$Result.GetResult<Prisma.$BloodBankServicePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BloodBankServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloodBankServiceCountArgs} args - Arguments to filter BloodBankServices to count.
     * @example
     * // Count the number of BloodBankServices
     * const count = await prisma.bloodBankService.count({
     *   where: {
     *     // ... the filter for the BloodBankServices we want to count
     *   }
     * })
    **/
    count<T extends BloodBankServiceCountArgs>(
      args?: Subset<T, BloodBankServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BloodBankServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BloodBankService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloodBankServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BloodBankServiceAggregateArgs>(args: Subset<T, BloodBankServiceAggregateArgs>): Prisma.PrismaPromise<GetBloodBankServiceAggregateType<T>>

    /**
     * Group by BloodBankService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BloodBankServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BloodBankServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BloodBankServiceGroupByArgs['orderBy'] }
        : { orderBy?: BloodBankServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BloodBankServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBloodBankServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BloodBankService model
   */
  readonly fields: BloodBankServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BloodBankService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BloodBankServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bloodTypeAvailability<T extends BloodBankService$bloodTypeAvailabilityArgs<ExtArgs> = {}>(args?: Subset<T, BloodBankService$bloodTypeAvailabilityArgs<ExtArgs>>): Prisma__BloodTypeMappingClient<$Result.GetResult<Prisma.$BloodTypeMappingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BloodBankService model
   */ 
  interface BloodBankServiceFieldRefs {
    readonly openingTime: FieldRef<"BloodBankService", 'DateTime'>
    readonly closingTime: FieldRef<"BloodBankService", 'DateTime'>
    readonly basePricePerUnit: FieldRef<"BloodBankService", 'Float'>
    readonly turnaroundTimeD: FieldRef<"BloodBankService", 'Int'>
    readonly turnaroundTimeH: FieldRef<"BloodBankService", 'Int'>
    readonly serviceID: FieldRef<"BloodBankService", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BloodBankService findUnique
   */
  export type BloodBankServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodBankService
     */
    select?: BloodBankServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BloodBankService
     */
    omit?: BloodBankServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodBankServiceInclude<ExtArgs> | null
    /**
     * Filter, which BloodBankService to fetch.
     */
    where: BloodBankServiceWhereUniqueInput
  }

  /**
   * BloodBankService findUniqueOrThrow
   */
  export type BloodBankServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodBankService
     */
    select?: BloodBankServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BloodBankService
     */
    omit?: BloodBankServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodBankServiceInclude<ExtArgs> | null
    /**
     * Filter, which BloodBankService to fetch.
     */
    where: BloodBankServiceWhereUniqueInput
  }

  /**
   * BloodBankService findFirst
   */
  export type BloodBankServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodBankService
     */
    select?: BloodBankServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BloodBankService
     */
    omit?: BloodBankServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodBankServiceInclude<ExtArgs> | null
    /**
     * Filter, which BloodBankService to fetch.
     */
    where?: BloodBankServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BloodBankServices to fetch.
     */
    orderBy?: BloodBankServiceOrderByWithRelationInput | BloodBankServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BloodBankServices.
     */
    cursor?: BloodBankServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BloodBankServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BloodBankServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BloodBankServices.
     */
    distinct?: BloodBankServiceScalarFieldEnum | BloodBankServiceScalarFieldEnum[]
  }

  /**
   * BloodBankService findFirstOrThrow
   */
  export type BloodBankServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodBankService
     */
    select?: BloodBankServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BloodBankService
     */
    omit?: BloodBankServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodBankServiceInclude<ExtArgs> | null
    /**
     * Filter, which BloodBankService to fetch.
     */
    where?: BloodBankServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BloodBankServices to fetch.
     */
    orderBy?: BloodBankServiceOrderByWithRelationInput | BloodBankServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BloodBankServices.
     */
    cursor?: BloodBankServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BloodBankServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BloodBankServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BloodBankServices.
     */
    distinct?: BloodBankServiceScalarFieldEnum | BloodBankServiceScalarFieldEnum[]
  }

  /**
   * BloodBankService findMany
   */
  export type BloodBankServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodBankService
     */
    select?: BloodBankServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BloodBankService
     */
    omit?: BloodBankServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodBankServiceInclude<ExtArgs> | null
    /**
     * Filter, which BloodBankServices to fetch.
     */
    where?: BloodBankServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BloodBankServices to fetch.
     */
    orderBy?: BloodBankServiceOrderByWithRelationInput | BloodBankServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BloodBankServices.
     */
    cursor?: BloodBankServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BloodBankServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BloodBankServices.
     */
    skip?: number
    distinct?: BloodBankServiceScalarFieldEnum | BloodBankServiceScalarFieldEnum[]
  }

  /**
   * BloodBankService create
   */
  export type BloodBankServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodBankService
     */
    select?: BloodBankServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BloodBankService
     */
    omit?: BloodBankServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodBankServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a BloodBankService.
     */
    data: XOR<BloodBankServiceCreateInput, BloodBankServiceUncheckedCreateInput>
  }

  /**
   * BloodBankService createMany
   */
  export type BloodBankServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BloodBankServices.
     */
    data: BloodBankServiceCreateManyInput | BloodBankServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BloodBankService createManyAndReturn
   */
  export type BloodBankServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodBankService
     */
    select?: BloodBankServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BloodBankService
     */
    omit?: BloodBankServiceOmit<ExtArgs> | null
    /**
     * The data used to create many BloodBankServices.
     */
    data: BloodBankServiceCreateManyInput | BloodBankServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodBankServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BloodBankService update
   */
  export type BloodBankServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodBankService
     */
    select?: BloodBankServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BloodBankService
     */
    omit?: BloodBankServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodBankServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a BloodBankService.
     */
    data: XOR<BloodBankServiceUpdateInput, BloodBankServiceUncheckedUpdateInput>
    /**
     * Choose, which BloodBankService to update.
     */
    where: BloodBankServiceWhereUniqueInput
  }

  /**
   * BloodBankService updateMany
   */
  export type BloodBankServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BloodBankServices.
     */
    data: XOR<BloodBankServiceUpdateManyMutationInput, BloodBankServiceUncheckedUpdateManyInput>
    /**
     * Filter which BloodBankServices to update
     */
    where?: BloodBankServiceWhereInput
    /**
     * Limit how many BloodBankServices to update.
     */
    limit?: number
  }

  /**
   * BloodBankService updateManyAndReturn
   */
  export type BloodBankServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodBankService
     */
    select?: BloodBankServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BloodBankService
     */
    omit?: BloodBankServiceOmit<ExtArgs> | null
    /**
     * The data used to update BloodBankServices.
     */
    data: XOR<BloodBankServiceUpdateManyMutationInput, BloodBankServiceUncheckedUpdateManyInput>
    /**
     * Filter which BloodBankServices to update
     */
    where?: BloodBankServiceWhereInput
    /**
     * Limit how many BloodBankServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodBankServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BloodBankService upsert
   */
  export type BloodBankServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodBankService
     */
    select?: BloodBankServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BloodBankService
     */
    omit?: BloodBankServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodBankServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the BloodBankService to update in case it exists.
     */
    where: BloodBankServiceWhereUniqueInput
    /**
     * In case the BloodBankService found by the `where` argument doesn't exist, create a new BloodBankService with this data.
     */
    create: XOR<BloodBankServiceCreateInput, BloodBankServiceUncheckedCreateInput>
    /**
     * In case the BloodBankService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BloodBankServiceUpdateInput, BloodBankServiceUncheckedUpdateInput>
  }

  /**
   * BloodBankService delete
   */
  export type BloodBankServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodBankService
     */
    select?: BloodBankServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BloodBankService
     */
    omit?: BloodBankServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodBankServiceInclude<ExtArgs> | null
    /**
     * Filter which BloodBankService to delete.
     */
    where: BloodBankServiceWhereUniqueInput
  }

  /**
   * BloodBankService deleteMany
   */
  export type BloodBankServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BloodBankServices to delete
     */
    where?: BloodBankServiceWhereInput
    /**
     * Limit how many BloodBankServices to delete.
     */
    limit?: number
  }

  /**
   * BloodBankService.bloodTypeAvailability
   */
  export type BloodBankService$bloodTypeAvailabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodTypeMapping
     */
    select?: BloodTypeMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BloodTypeMapping
     */
    omit?: BloodTypeMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodTypeMappingInclude<ExtArgs> | null
    where?: BloodTypeMappingWhereInput
  }

  /**
   * BloodBankService without action
   */
  export type BloodBankServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BloodBankService
     */
    select?: BloodBankServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BloodBankService
     */
    omit?: BloodBankServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BloodBankServiceInclude<ExtArgs> | null
  }


  /**
   * Model ERService
   */

  export type AggregateERService = {
    _count: ERServiceCountAggregateOutputType | null
    _avg: ERServiceAvgAggregateOutputType | null
    _sum: ERServiceSumAggregateOutputType | null
    _min: ERServiceMinAggregateOutputType | null
    _max: ERServiceMaxAggregateOutputType | null
  }

  export type ERServiceAvgAggregateOutputType = {
    availableBeds: number | null
    nonUrgentPatients: number | null
    nonUrgentQueueLength: number | null
    urgentPatients: number | null
    urgentQueueLength: number | null
    criticalPatients: number | null
    criticalQueueLength: number | null
  }

  export type ERServiceSumAggregateOutputType = {
    availableBeds: number | null
    nonUrgentPatients: number | null
    nonUrgentQueueLength: number | null
    urgentPatients: number | null
    urgentQueueLength: number | null
    criticalPatients: number | null
    criticalQueueLength: number | null
  }

  export type ERServiceMinAggregateOutputType = {
    openingTime: Date | null
    closingTime: Date | null
    load: $Enums.Load | null
    availableBeds: number | null
    nonUrgentPatients: number | null
    nonUrgentQueueLength: number | null
    urgentPatients: number | null
    urgentQueueLength: number | null
    criticalPatients: number | null
    criticalQueueLength: number | null
    serviceID: string | null
  }

  export type ERServiceMaxAggregateOutputType = {
    openingTime: Date | null
    closingTime: Date | null
    load: $Enums.Load | null
    availableBeds: number | null
    nonUrgentPatients: number | null
    nonUrgentQueueLength: number | null
    urgentPatients: number | null
    urgentQueueLength: number | null
    criticalPatients: number | null
    criticalQueueLength: number | null
    serviceID: string | null
  }

  export type ERServiceCountAggregateOutputType = {
    openingTime: number
    closingTime: number
    load: number
    availableBeds: number
    nonUrgentPatients: number
    nonUrgentQueueLength: number
    urgentPatients: number
    urgentQueueLength: number
    criticalPatients: number
    criticalQueueLength: number
    serviceID: number
    _all: number
  }


  export type ERServiceAvgAggregateInputType = {
    availableBeds?: true
    nonUrgentPatients?: true
    nonUrgentQueueLength?: true
    urgentPatients?: true
    urgentQueueLength?: true
    criticalPatients?: true
    criticalQueueLength?: true
  }

  export type ERServiceSumAggregateInputType = {
    availableBeds?: true
    nonUrgentPatients?: true
    nonUrgentQueueLength?: true
    urgentPatients?: true
    urgentQueueLength?: true
    criticalPatients?: true
    criticalQueueLength?: true
  }

  export type ERServiceMinAggregateInputType = {
    openingTime?: true
    closingTime?: true
    load?: true
    availableBeds?: true
    nonUrgentPatients?: true
    nonUrgentQueueLength?: true
    urgentPatients?: true
    urgentQueueLength?: true
    criticalPatients?: true
    criticalQueueLength?: true
    serviceID?: true
  }

  export type ERServiceMaxAggregateInputType = {
    openingTime?: true
    closingTime?: true
    load?: true
    availableBeds?: true
    nonUrgentPatients?: true
    nonUrgentQueueLength?: true
    urgentPatients?: true
    urgentQueueLength?: true
    criticalPatients?: true
    criticalQueueLength?: true
    serviceID?: true
  }

  export type ERServiceCountAggregateInputType = {
    openingTime?: true
    closingTime?: true
    load?: true
    availableBeds?: true
    nonUrgentPatients?: true
    nonUrgentQueueLength?: true
    urgentPatients?: true
    urgentQueueLength?: true
    criticalPatients?: true
    criticalQueueLength?: true
    serviceID?: true
    _all?: true
  }

  export type ERServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ERService to aggregate.
     */
    where?: ERServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ERServices to fetch.
     */
    orderBy?: ERServiceOrderByWithRelationInput | ERServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ERServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ERServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ERServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ERServices
    **/
    _count?: true | ERServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ERServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ERServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ERServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ERServiceMaxAggregateInputType
  }

  export type GetERServiceAggregateType<T extends ERServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateERService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateERService[P]>
      : GetScalarType<T[P], AggregateERService[P]>
  }




  export type ERServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ERServiceWhereInput
    orderBy?: ERServiceOrderByWithAggregationInput | ERServiceOrderByWithAggregationInput[]
    by: ERServiceScalarFieldEnum[] | ERServiceScalarFieldEnum
    having?: ERServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ERServiceCountAggregateInputType | true
    _avg?: ERServiceAvgAggregateInputType
    _sum?: ERServiceSumAggregateInputType
    _min?: ERServiceMinAggregateInputType
    _max?: ERServiceMaxAggregateInputType
  }

  export type ERServiceGroupByOutputType = {
    openingTime: Date | null
    closingTime: Date | null
    load: $Enums.Load
    availableBeds: number
    nonUrgentPatients: number
    nonUrgentQueueLength: number
    urgentPatients: number
    urgentQueueLength: number
    criticalPatients: number
    criticalQueueLength: number
    serviceID: string
    _count: ERServiceCountAggregateOutputType | null
    _avg: ERServiceAvgAggregateOutputType | null
    _sum: ERServiceSumAggregateOutputType | null
    _min: ERServiceMinAggregateOutputType | null
    _max: ERServiceMaxAggregateOutputType | null
  }

  type GetERServiceGroupByPayload<T extends ERServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ERServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ERServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ERServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ERServiceGroupByOutputType[P]>
        }
      >
    >


  export type ERServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    openingTime?: boolean
    closingTime?: boolean
    load?: boolean
    availableBeds?: boolean
    nonUrgentPatients?: boolean
    nonUrgentQueueLength?: boolean
    urgentPatients?: boolean
    urgentQueueLength?: boolean
    criticalPatients?: boolean
    criticalQueueLength?: boolean
    serviceID?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eRService"]>

  export type ERServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    openingTime?: boolean
    closingTime?: boolean
    load?: boolean
    availableBeds?: boolean
    nonUrgentPatients?: boolean
    nonUrgentQueueLength?: boolean
    urgentPatients?: boolean
    urgentQueueLength?: boolean
    criticalPatients?: boolean
    criticalQueueLength?: boolean
    serviceID?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eRService"]>

  export type ERServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    openingTime?: boolean
    closingTime?: boolean
    load?: boolean
    availableBeds?: boolean
    nonUrgentPatients?: boolean
    nonUrgentQueueLength?: boolean
    urgentPatients?: boolean
    urgentQueueLength?: boolean
    criticalPatients?: boolean
    criticalQueueLength?: boolean
    serviceID?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eRService"]>

  export type ERServiceSelectScalar = {
    openingTime?: boolean
    closingTime?: boolean
    load?: boolean
    availableBeds?: boolean
    nonUrgentPatients?: boolean
    nonUrgentQueueLength?: boolean
    urgentPatients?: boolean
    urgentQueueLength?: boolean
    criticalPatients?: boolean
    criticalQueueLength?: boolean
    serviceID?: boolean
  }

  export type ERServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"openingTime" | "closingTime" | "load" | "availableBeds" | "nonUrgentPatients" | "nonUrgentQueueLength" | "urgentPatients" | "urgentQueueLength" | "criticalPatients" | "criticalQueueLength" | "serviceID", ExtArgs["result"]["eRService"]>
  export type ERServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type ERServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type ERServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $ERServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ERService"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      openingTime: Date | null
      closingTime: Date | null
      load: $Enums.Load
      availableBeds: number
      nonUrgentPatients: number
      nonUrgentQueueLength: number
      urgentPatients: number
      urgentQueueLength: number
      criticalPatients: number
      criticalQueueLength: number
      serviceID: string
    }, ExtArgs["result"]["eRService"]>
    composites: {}
  }

  type ERServiceGetPayload<S extends boolean | null | undefined | ERServiceDefaultArgs> = $Result.GetResult<Prisma.$ERServicePayload, S>

  type ERServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ERServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ERServiceCountAggregateInputType | true
    }

  export interface ERServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ERService'], meta: { name: 'ERService' } }
    /**
     * Find zero or one ERService that matches the filter.
     * @param {ERServiceFindUniqueArgs} args - Arguments to find a ERService
     * @example
     * // Get one ERService
     * const eRService = await prisma.eRService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ERServiceFindUniqueArgs>(args: SelectSubset<T, ERServiceFindUniqueArgs<ExtArgs>>): Prisma__ERServiceClient<$Result.GetResult<Prisma.$ERServicePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ERService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ERServiceFindUniqueOrThrowArgs} args - Arguments to find a ERService
     * @example
     * // Get one ERService
     * const eRService = await prisma.eRService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ERServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ERServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ERServiceClient<$Result.GetResult<Prisma.$ERServicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ERService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ERServiceFindFirstArgs} args - Arguments to find a ERService
     * @example
     * // Get one ERService
     * const eRService = await prisma.eRService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ERServiceFindFirstArgs>(args?: SelectSubset<T, ERServiceFindFirstArgs<ExtArgs>>): Prisma__ERServiceClient<$Result.GetResult<Prisma.$ERServicePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ERService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ERServiceFindFirstOrThrowArgs} args - Arguments to find a ERService
     * @example
     * // Get one ERService
     * const eRService = await prisma.eRService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ERServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ERServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ERServiceClient<$Result.GetResult<Prisma.$ERServicePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ERServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ERServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ERServices
     * const eRServices = await prisma.eRService.findMany()
     * 
     * // Get first 10 ERServices
     * const eRServices = await prisma.eRService.findMany({ take: 10 })
     * 
     * // Only select the `openingTime`
     * const eRServiceWithOpeningTimeOnly = await prisma.eRService.findMany({ select: { openingTime: true } })
     * 
     */
    findMany<T extends ERServiceFindManyArgs>(args?: SelectSubset<T, ERServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ERServicePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ERService.
     * @param {ERServiceCreateArgs} args - Arguments to create a ERService.
     * @example
     * // Create one ERService
     * const ERService = await prisma.eRService.create({
     *   data: {
     *     // ... data to create a ERService
     *   }
     * })
     * 
     */
    create<T extends ERServiceCreateArgs>(args: SelectSubset<T, ERServiceCreateArgs<ExtArgs>>): Prisma__ERServiceClient<$Result.GetResult<Prisma.$ERServicePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ERServices.
     * @param {ERServiceCreateManyArgs} args - Arguments to create many ERServices.
     * @example
     * // Create many ERServices
     * const eRService = await prisma.eRService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ERServiceCreateManyArgs>(args?: SelectSubset<T, ERServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ERServices and returns the data saved in the database.
     * @param {ERServiceCreateManyAndReturnArgs} args - Arguments to create many ERServices.
     * @example
     * // Create many ERServices
     * const eRService = await prisma.eRService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ERServices and only return the `openingTime`
     * const eRServiceWithOpeningTimeOnly = await prisma.eRService.createManyAndReturn({
     *   select: { openingTime: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ERServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ERServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ERServicePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ERService.
     * @param {ERServiceDeleteArgs} args - Arguments to delete one ERService.
     * @example
     * // Delete one ERService
     * const ERService = await prisma.eRService.delete({
     *   where: {
     *     // ... filter to delete one ERService
     *   }
     * })
     * 
     */
    delete<T extends ERServiceDeleteArgs>(args: SelectSubset<T, ERServiceDeleteArgs<ExtArgs>>): Prisma__ERServiceClient<$Result.GetResult<Prisma.$ERServicePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ERService.
     * @param {ERServiceUpdateArgs} args - Arguments to update one ERService.
     * @example
     * // Update one ERService
     * const eRService = await prisma.eRService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ERServiceUpdateArgs>(args: SelectSubset<T, ERServiceUpdateArgs<ExtArgs>>): Prisma__ERServiceClient<$Result.GetResult<Prisma.$ERServicePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ERServices.
     * @param {ERServiceDeleteManyArgs} args - Arguments to filter ERServices to delete.
     * @example
     * // Delete a few ERServices
     * const { count } = await prisma.eRService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ERServiceDeleteManyArgs>(args?: SelectSubset<T, ERServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ERServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ERServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ERServices
     * const eRService = await prisma.eRService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ERServiceUpdateManyArgs>(args: SelectSubset<T, ERServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ERServices and returns the data updated in the database.
     * @param {ERServiceUpdateManyAndReturnArgs} args - Arguments to update many ERServices.
     * @example
     * // Update many ERServices
     * const eRService = await prisma.eRService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ERServices and only return the `openingTime`
     * const eRServiceWithOpeningTimeOnly = await prisma.eRService.updateManyAndReturn({
     *   select: { openingTime: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ERServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ERServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ERServicePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ERService.
     * @param {ERServiceUpsertArgs} args - Arguments to update or create a ERService.
     * @example
     * // Update or create a ERService
     * const eRService = await prisma.eRService.upsert({
     *   create: {
     *     // ... data to create a ERService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ERService we want to update
     *   }
     * })
     */
    upsert<T extends ERServiceUpsertArgs>(args: SelectSubset<T, ERServiceUpsertArgs<ExtArgs>>): Prisma__ERServiceClient<$Result.GetResult<Prisma.$ERServicePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ERServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ERServiceCountArgs} args - Arguments to filter ERServices to count.
     * @example
     * // Count the number of ERServices
     * const count = await prisma.eRService.count({
     *   where: {
     *     // ... the filter for the ERServices we want to count
     *   }
     * })
    **/
    count<T extends ERServiceCountArgs>(
      args?: Subset<T, ERServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ERServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ERService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ERServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ERServiceAggregateArgs>(args: Subset<T, ERServiceAggregateArgs>): Prisma.PrismaPromise<GetERServiceAggregateType<T>>

    /**
     * Group by ERService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ERServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ERServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ERServiceGroupByArgs['orderBy'] }
        : { orderBy?: ERServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ERServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetERServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ERService model
   */
  readonly fields: ERServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ERService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ERServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ERService model
   */ 
  interface ERServiceFieldRefs {
    readonly openingTime: FieldRef<"ERService", 'DateTime'>
    readonly closingTime: FieldRef<"ERService", 'DateTime'>
    readonly load: FieldRef<"ERService", 'Load'>
    readonly availableBeds: FieldRef<"ERService", 'Int'>
    readonly nonUrgentPatients: FieldRef<"ERService", 'Int'>
    readonly nonUrgentQueueLength: FieldRef<"ERService", 'Int'>
    readonly urgentPatients: FieldRef<"ERService", 'Int'>
    readonly urgentQueueLength: FieldRef<"ERService", 'Int'>
    readonly criticalPatients: FieldRef<"ERService", 'Int'>
    readonly criticalQueueLength: FieldRef<"ERService", 'Int'>
    readonly serviceID: FieldRef<"ERService", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ERService findUnique
   */
  export type ERServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ERService
     */
    select?: ERServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ERService
     */
    omit?: ERServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ERServiceInclude<ExtArgs> | null
    /**
     * Filter, which ERService to fetch.
     */
    where: ERServiceWhereUniqueInput
  }

  /**
   * ERService findUniqueOrThrow
   */
  export type ERServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ERService
     */
    select?: ERServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ERService
     */
    omit?: ERServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ERServiceInclude<ExtArgs> | null
    /**
     * Filter, which ERService to fetch.
     */
    where: ERServiceWhereUniqueInput
  }

  /**
   * ERService findFirst
   */
  export type ERServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ERService
     */
    select?: ERServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ERService
     */
    omit?: ERServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ERServiceInclude<ExtArgs> | null
    /**
     * Filter, which ERService to fetch.
     */
    where?: ERServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ERServices to fetch.
     */
    orderBy?: ERServiceOrderByWithRelationInput | ERServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ERServices.
     */
    cursor?: ERServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ERServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ERServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ERServices.
     */
    distinct?: ERServiceScalarFieldEnum | ERServiceScalarFieldEnum[]
  }

  /**
   * ERService findFirstOrThrow
   */
  export type ERServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ERService
     */
    select?: ERServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ERService
     */
    omit?: ERServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ERServiceInclude<ExtArgs> | null
    /**
     * Filter, which ERService to fetch.
     */
    where?: ERServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ERServices to fetch.
     */
    orderBy?: ERServiceOrderByWithRelationInput | ERServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ERServices.
     */
    cursor?: ERServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ERServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ERServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ERServices.
     */
    distinct?: ERServiceScalarFieldEnum | ERServiceScalarFieldEnum[]
  }

  /**
   * ERService findMany
   */
  export type ERServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ERService
     */
    select?: ERServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ERService
     */
    omit?: ERServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ERServiceInclude<ExtArgs> | null
    /**
     * Filter, which ERServices to fetch.
     */
    where?: ERServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ERServices to fetch.
     */
    orderBy?: ERServiceOrderByWithRelationInput | ERServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ERServices.
     */
    cursor?: ERServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ERServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ERServices.
     */
    skip?: number
    distinct?: ERServiceScalarFieldEnum | ERServiceScalarFieldEnum[]
  }

  /**
   * ERService create
   */
  export type ERServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ERService
     */
    select?: ERServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ERService
     */
    omit?: ERServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ERServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a ERService.
     */
    data: XOR<ERServiceCreateInput, ERServiceUncheckedCreateInput>
  }

  /**
   * ERService createMany
   */
  export type ERServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ERServices.
     */
    data: ERServiceCreateManyInput | ERServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ERService createManyAndReturn
   */
  export type ERServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ERService
     */
    select?: ERServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ERService
     */
    omit?: ERServiceOmit<ExtArgs> | null
    /**
     * The data used to create many ERServices.
     */
    data: ERServiceCreateManyInput | ERServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ERServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ERService update
   */
  export type ERServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ERService
     */
    select?: ERServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ERService
     */
    omit?: ERServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ERServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a ERService.
     */
    data: XOR<ERServiceUpdateInput, ERServiceUncheckedUpdateInput>
    /**
     * Choose, which ERService to update.
     */
    where: ERServiceWhereUniqueInput
  }

  /**
   * ERService updateMany
   */
  export type ERServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ERServices.
     */
    data: XOR<ERServiceUpdateManyMutationInput, ERServiceUncheckedUpdateManyInput>
    /**
     * Filter which ERServices to update
     */
    where?: ERServiceWhereInput
    /**
     * Limit how many ERServices to update.
     */
    limit?: number
  }

  /**
   * ERService updateManyAndReturn
   */
  export type ERServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ERService
     */
    select?: ERServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ERService
     */
    omit?: ERServiceOmit<ExtArgs> | null
    /**
     * The data used to update ERServices.
     */
    data: XOR<ERServiceUpdateManyMutationInput, ERServiceUncheckedUpdateManyInput>
    /**
     * Filter which ERServices to update
     */
    where?: ERServiceWhereInput
    /**
     * Limit how many ERServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ERServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ERService upsert
   */
  export type ERServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ERService
     */
    select?: ERServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ERService
     */
    omit?: ERServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ERServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the ERService to update in case it exists.
     */
    where: ERServiceWhereUniqueInput
    /**
     * In case the ERService found by the `where` argument doesn't exist, create a new ERService with this data.
     */
    create: XOR<ERServiceCreateInput, ERServiceUncheckedCreateInput>
    /**
     * In case the ERService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ERServiceUpdateInput, ERServiceUncheckedUpdateInput>
  }

  /**
   * ERService delete
   */
  export type ERServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ERService
     */
    select?: ERServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ERService
     */
    omit?: ERServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ERServiceInclude<ExtArgs> | null
    /**
     * Filter which ERService to delete.
     */
    where: ERServiceWhereUniqueInput
  }

  /**
   * ERService deleteMany
   */
  export type ERServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ERServices to delete
     */
    where?: ERServiceWhereInput
    /**
     * Limit how many ERServices to delete.
     */
    limit?: number
  }

  /**
   * ERService without action
   */
  export type ERServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ERService
     */
    select?: ERServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ERService
     */
    omit?: ERServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ERServiceInclude<ExtArgs> | null
  }


  /**
   * Model ICUService
   */

  export type AggregateICUService = {
    _count: ICUServiceCountAggregateOutputType | null
    _avg: ICUServiceAvgAggregateOutputType | null
    _sum: ICUServiceSumAggregateOutputType | null
    _min: ICUServiceMinAggregateOutputType | null
    _max: ICUServiceMaxAggregateOutputType | null
  }

  export type ICUServiceAvgAggregateOutputType = {
    baseRate: number | null
    availableBeds: number | null
  }

  export type ICUServiceSumAggregateOutputType = {
    baseRate: number | null
    availableBeds: number | null
  }

  export type ICUServiceMinAggregateOutputType = {
    openingTime: Date | null
    closingTime: Date | null
    load: $Enums.Load | null
    baseRate: number | null
    availableBeds: number | null
    cardiacSupport: boolean | null
    neurologicalSupport: boolean | null
    renalSupport: boolean | null
    respiratorySupport: boolean | null
    serviceID: string | null
  }

  export type ICUServiceMaxAggregateOutputType = {
    openingTime: Date | null
    closingTime: Date | null
    load: $Enums.Load | null
    baseRate: number | null
    availableBeds: number | null
    cardiacSupport: boolean | null
    neurologicalSupport: boolean | null
    renalSupport: boolean | null
    respiratorySupport: boolean | null
    serviceID: string | null
  }

  export type ICUServiceCountAggregateOutputType = {
    openingTime: number
    closingTime: number
    load: number
    baseRate: number
    availableBeds: number
    cardiacSupport: number
    neurologicalSupport: number
    renalSupport: number
    respiratorySupport: number
    serviceID: number
    _all: number
  }


  export type ICUServiceAvgAggregateInputType = {
    baseRate?: true
    availableBeds?: true
  }

  export type ICUServiceSumAggregateInputType = {
    baseRate?: true
    availableBeds?: true
  }

  export type ICUServiceMinAggregateInputType = {
    openingTime?: true
    closingTime?: true
    load?: true
    baseRate?: true
    availableBeds?: true
    cardiacSupport?: true
    neurologicalSupport?: true
    renalSupport?: true
    respiratorySupport?: true
    serviceID?: true
  }

  export type ICUServiceMaxAggregateInputType = {
    openingTime?: true
    closingTime?: true
    load?: true
    baseRate?: true
    availableBeds?: true
    cardiacSupport?: true
    neurologicalSupport?: true
    renalSupport?: true
    respiratorySupport?: true
    serviceID?: true
  }

  export type ICUServiceCountAggregateInputType = {
    openingTime?: true
    closingTime?: true
    load?: true
    baseRate?: true
    availableBeds?: true
    cardiacSupport?: true
    neurologicalSupport?: true
    renalSupport?: true
    respiratorySupport?: true
    serviceID?: true
    _all?: true
  }

  export type ICUServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ICUService to aggregate.
     */
    where?: ICUServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ICUServices to fetch.
     */
    orderBy?: ICUServiceOrderByWithRelationInput | ICUServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ICUServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ICUServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ICUServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ICUServices
    **/
    _count?: true | ICUServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ICUServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ICUServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ICUServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ICUServiceMaxAggregateInputType
  }

  export type GetICUServiceAggregateType<T extends ICUServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateICUService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateICUService[P]>
      : GetScalarType<T[P], AggregateICUService[P]>
  }




  export type ICUServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ICUServiceWhereInput
    orderBy?: ICUServiceOrderByWithAggregationInput | ICUServiceOrderByWithAggregationInput[]
    by: ICUServiceScalarFieldEnum[] | ICUServiceScalarFieldEnum
    having?: ICUServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ICUServiceCountAggregateInputType | true
    _avg?: ICUServiceAvgAggregateInputType
    _sum?: ICUServiceSumAggregateInputType
    _min?: ICUServiceMinAggregateInputType
    _max?: ICUServiceMaxAggregateInputType
  }

  export type ICUServiceGroupByOutputType = {
    openingTime: Date | null
    closingTime: Date | null
    load: $Enums.Load
    baseRate: number
    availableBeds: number
    cardiacSupport: boolean
    neurologicalSupport: boolean
    renalSupport: boolean
    respiratorySupport: boolean
    serviceID: string
    _count: ICUServiceCountAggregateOutputType | null
    _avg: ICUServiceAvgAggregateOutputType | null
    _sum: ICUServiceSumAggregateOutputType | null
    _min: ICUServiceMinAggregateOutputType | null
    _max: ICUServiceMaxAggregateOutputType | null
  }

  type GetICUServiceGroupByPayload<T extends ICUServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ICUServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ICUServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ICUServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ICUServiceGroupByOutputType[P]>
        }
      >
    >


  export type ICUServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    openingTime?: boolean
    closingTime?: boolean
    load?: boolean
    baseRate?: boolean
    availableBeds?: boolean
    cardiacSupport?: boolean
    neurologicalSupport?: boolean
    renalSupport?: boolean
    respiratorySupport?: boolean
    serviceID?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["iCUService"]>

  export type ICUServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    openingTime?: boolean
    closingTime?: boolean
    load?: boolean
    baseRate?: boolean
    availableBeds?: boolean
    cardiacSupport?: boolean
    neurologicalSupport?: boolean
    renalSupport?: boolean
    respiratorySupport?: boolean
    serviceID?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["iCUService"]>

  export type ICUServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    openingTime?: boolean
    closingTime?: boolean
    load?: boolean
    baseRate?: boolean
    availableBeds?: boolean
    cardiacSupport?: boolean
    neurologicalSupport?: boolean
    renalSupport?: boolean
    respiratorySupport?: boolean
    serviceID?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["iCUService"]>

  export type ICUServiceSelectScalar = {
    openingTime?: boolean
    closingTime?: boolean
    load?: boolean
    baseRate?: boolean
    availableBeds?: boolean
    cardiacSupport?: boolean
    neurologicalSupport?: boolean
    renalSupport?: boolean
    respiratorySupport?: boolean
    serviceID?: boolean
  }

  export type ICUServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"openingTime" | "closingTime" | "load" | "baseRate" | "availableBeds" | "cardiacSupport" | "neurologicalSupport" | "renalSupport" | "respiratorySupport" | "serviceID", ExtArgs["result"]["iCUService"]>
  export type ICUServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type ICUServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type ICUServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $ICUServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ICUService"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      openingTime: Date | null
      closingTime: Date | null
      load: $Enums.Load
      baseRate: number
      availableBeds: number
      cardiacSupport: boolean
      neurologicalSupport: boolean
      renalSupport: boolean
      respiratorySupport: boolean
      serviceID: string
    }, ExtArgs["result"]["iCUService"]>
    composites: {}
  }

  type ICUServiceGetPayload<S extends boolean | null | undefined | ICUServiceDefaultArgs> = $Result.GetResult<Prisma.$ICUServicePayload, S>

  type ICUServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ICUServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ICUServiceCountAggregateInputType | true
    }

  export interface ICUServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ICUService'], meta: { name: 'ICUService' } }
    /**
     * Find zero or one ICUService that matches the filter.
     * @param {ICUServiceFindUniqueArgs} args - Arguments to find a ICUService
     * @example
     * // Get one ICUService
     * const iCUService = await prisma.iCUService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ICUServiceFindUniqueArgs>(args: SelectSubset<T, ICUServiceFindUniqueArgs<ExtArgs>>): Prisma__ICUServiceClient<$Result.GetResult<Prisma.$ICUServicePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ICUService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ICUServiceFindUniqueOrThrowArgs} args - Arguments to find a ICUService
     * @example
     * // Get one ICUService
     * const iCUService = await prisma.iCUService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ICUServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ICUServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ICUServiceClient<$Result.GetResult<Prisma.$ICUServicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ICUService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ICUServiceFindFirstArgs} args - Arguments to find a ICUService
     * @example
     * // Get one ICUService
     * const iCUService = await prisma.iCUService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ICUServiceFindFirstArgs>(args?: SelectSubset<T, ICUServiceFindFirstArgs<ExtArgs>>): Prisma__ICUServiceClient<$Result.GetResult<Prisma.$ICUServicePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ICUService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ICUServiceFindFirstOrThrowArgs} args - Arguments to find a ICUService
     * @example
     * // Get one ICUService
     * const iCUService = await prisma.iCUService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ICUServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ICUServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ICUServiceClient<$Result.GetResult<Prisma.$ICUServicePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ICUServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ICUServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ICUServices
     * const iCUServices = await prisma.iCUService.findMany()
     * 
     * // Get first 10 ICUServices
     * const iCUServices = await prisma.iCUService.findMany({ take: 10 })
     * 
     * // Only select the `openingTime`
     * const iCUServiceWithOpeningTimeOnly = await prisma.iCUService.findMany({ select: { openingTime: true } })
     * 
     */
    findMany<T extends ICUServiceFindManyArgs>(args?: SelectSubset<T, ICUServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ICUServicePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ICUService.
     * @param {ICUServiceCreateArgs} args - Arguments to create a ICUService.
     * @example
     * // Create one ICUService
     * const ICUService = await prisma.iCUService.create({
     *   data: {
     *     // ... data to create a ICUService
     *   }
     * })
     * 
     */
    create<T extends ICUServiceCreateArgs>(args: SelectSubset<T, ICUServiceCreateArgs<ExtArgs>>): Prisma__ICUServiceClient<$Result.GetResult<Prisma.$ICUServicePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ICUServices.
     * @param {ICUServiceCreateManyArgs} args - Arguments to create many ICUServices.
     * @example
     * // Create many ICUServices
     * const iCUService = await prisma.iCUService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ICUServiceCreateManyArgs>(args?: SelectSubset<T, ICUServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ICUServices and returns the data saved in the database.
     * @param {ICUServiceCreateManyAndReturnArgs} args - Arguments to create many ICUServices.
     * @example
     * // Create many ICUServices
     * const iCUService = await prisma.iCUService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ICUServices and only return the `openingTime`
     * const iCUServiceWithOpeningTimeOnly = await prisma.iCUService.createManyAndReturn({
     *   select: { openingTime: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ICUServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ICUServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ICUServicePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ICUService.
     * @param {ICUServiceDeleteArgs} args - Arguments to delete one ICUService.
     * @example
     * // Delete one ICUService
     * const ICUService = await prisma.iCUService.delete({
     *   where: {
     *     // ... filter to delete one ICUService
     *   }
     * })
     * 
     */
    delete<T extends ICUServiceDeleteArgs>(args: SelectSubset<T, ICUServiceDeleteArgs<ExtArgs>>): Prisma__ICUServiceClient<$Result.GetResult<Prisma.$ICUServicePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ICUService.
     * @param {ICUServiceUpdateArgs} args - Arguments to update one ICUService.
     * @example
     * // Update one ICUService
     * const iCUService = await prisma.iCUService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ICUServiceUpdateArgs>(args: SelectSubset<T, ICUServiceUpdateArgs<ExtArgs>>): Prisma__ICUServiceClient<$Result.GetResult<Prisma.$ICUServicePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ICUServices.
     * @param {ICUServiceDeleteManyArgs} args - Arguments to filter ICUServices to delete.
     * @example
     * // Delete a few ICUServices
     * const { count } = await prisma.iCUService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ICUServiceDeleteManyArgs>(args?: SelectSubset<T, ICUServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ICUServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ICUServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ICUServices
     * const iCUService = await prisma.iCUService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ICUServiceUpdateManyArgs>(args: SelectSubset<T, ICUServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ICUServices and returns the data updated in the database.
     * @param {ICUServiceUpdateManyAndReturnArgs} args - Arguments to update many ICUServices.
     * @example
     * // Update many ICUServices
     * const iCUService = await prisma.iCUService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ICUServices and only return the `openingTime`
     * const iCUServiceWithOpeningTimeOnly = await prisma.iCUService.updateManyAndReturn({
     *   select: { openingTime: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ICUServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ICUServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ICUServicePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ICUService.
     * @param {ICUServiceUpsertArgs} args - Arguments to update or create a ICUService.
     * @example
     * // Update or create a ICUService
     * const iCUService = await prisma.iCUService.upsert({
     *   create: {
     *     // ... data to create a ICUService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ICUService we want to update
     *   }
     * })
     */
    upsert<T extends ICUServiceUpsertArgs>(args: SelectSubset<T, ICUServiceUpsertArgs<ExtArgs>>): Prisma__ICUServiceClient<$Result.GetResult<Prisma.$ICUServicePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ICUServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ICUServiceCountArgs} args - Arguments to filter ICUServices to count.
     * @example
     * // Count the number of ICUServices
     * const count = await prisma.iCUService.count({
     *   where: {
     *     // ... the filter for the ICUServices we want to count
     *   }
     * })
    **/
    count<T extends ICUServiceCountArgs>(
      args?: Subset<T, ICUServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ICUServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ICUService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ICUServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ICUServiceAggregateArgs>(args: Subset<T, ICUServiceAggregateArgs>): Prisma.PrismaPromise<GetICUServiceAggregateType<T>>

    /**
     * Group by ICUService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ICUServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ICUServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ICUServiceGroupByArgs['orderBy'] }
        : { orderBy?: ICUServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ICUServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetICUServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ICUService model
   */
  readonly fields: ICUServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ICUService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ICUServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ICUService model
   */ 
  interface ICUServiceFieldRefs {
    readonly openingTime: FieldRef<"ICUService", 'DateTime'>
    readonly closingTime: FieldRef<"ICUService", 'DateTime'>
    readonly load: FieldRef<"ICUService", 'Load'>
    readonly baseRate: FieldRef<"ICUService", 'Float'>
    readonly availableBeds: FieldRef<"ICUService", 'Int'>
    readonly cardiacSupport: FieldRef<"ICUService", 'Boolean'>
    readonly neurologicalSupport: FieldRef<"ICUService", 'Boolean'>
    readonly renalSupport: FieldRef<"ICUService", 'Boolean'>
    readonly respiratorySupport: FieldRef<"ICUService", 'Boolean'>
    readonly serviceID: FieldRef<"ICUService", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ICUService findUnique
   */
  export type ICUServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICUService
     */
    select?: ICUServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ICUService
     */
    omit?: ICUServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICUServiceInclude<ExtArgs> | null
    /**
     * Filter, which ICUService to fetch.
     */
    where: ICUServiceWhereUniqueInput
  }

  /**
   * ICUService findUniqueOrThrow
   */
  export type ICUServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICUService
     */
    select?: ICUServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ICUService
     */
    omit?: ICUServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICUServiceInclude<ExtArgs> | null
    /**
     * Filter, which ICUService to fetch.
     */
    where: ICUServiceWhereUniqueInput
  }

  /**
   * ICUService findFirst
   */
  export type ICUServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICUService
     */
    select?: ICUServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ICUService
     */
    omit?: ICUServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICUServiceInclude<ExtArgs> | null
    /**
     * Filter, which ICUService to fetch.
     */
    where?: ICUServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ICUServices to fetch.
     */
    orderBy?: ICUServiceOrderByWithRelationInput | ICUServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ICUServices.
     */
    cursor?: ICUServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ICUServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ICUServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ICUServices.
     */
    distinct?: ICUServiceScalarFieldEnum | ICUServiceScalarFieldEnum[]
  }

  /**
   * ICUService findFirstOrThrow
   */
  export type ICUServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICUService
     */
    select?: ICUServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ICUService
     */
    omit?: ICUServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICUServiceInclude<ExtArgs> | null
    /**
     * Filter, which ICUService to fetch.
     */
    where?: ICUServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ICUServices to fetch.
     */
    orderBy?: ICUServiceOrderByWithRelationInput | ICUServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ICUServices.
     */
    cursor?: ICUServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ICUServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ICUServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ICUServices.
     */
    distinct?: ICUServiceScalarFieldEnum | ICUServiceScalarFieldEnum[]
  }

  /**
   * ICUService findMany
   */
  export type ICUServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICUService
     */
    select?: ICUServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ICUService
     */
    omit?: ICUServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICUServiceInclude<ExtArgs> | null
    /**
     * Filter, which ICUServices to fetch.
     */
    where?: ICUServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ICUServices to fetch.
     */
    orderBy?: ICUServiceOrderByWithRelationInput | ICUServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ICUServices.
     */
    cursor?: ICUServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ICUServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ICUServices.
     */
    skip?: number
    distinct?: ICUServiceScalarFieldEnum | ICUServiceScalarFieldEnum[]
  }

  /**
   * ICUService create
   */
  export type ICUServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICUService
     */
    select?: ICUServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ICUService
     */
    omit?: ICUServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICUServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a ICUService.
     */
    data: XOR<ICUServiceCreateInput, ICUServiceUncheckedCreateInput>
  }

  /**
   * ICUService createMany
   */
  export type ICUServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ICUServices.
     */
    data: ICUServiceCreateManyInput | ICUServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ICUService createManyAndReturn
   */
  export type ICUServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICUService
     */
    select?: ICUServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ICUService
     */
    omit?: ICUServiceOmit<ExtArgs> | null
    /**
     * The data used to create many ICUServices.
     */
    data: ICUServiceCreateManyInput | ICUServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICUServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ICUService update
   */
  export type ICUServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICUService
     */
    select?: ICUServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ICUService
     */
    omit?: ICUServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICUServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a ICUService.
     */
    data: XOR<ICUServiceUpdateInput, ICUServiceUncheckedUpdateInput>
    /**
     * Choose, which ICUService to update.
     */
    where: ICUServiceWhereUniqueInput
  }

  /**
   * ICUService updateMany
   */
  export type ICUServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ICUServices.
     */
    data: XOR<ICUServiceUpdateManyMutationInput, ICUServiceUncheckedUpdateManyInput>
    /**
     * Filter which ICUServices to update
     */
    where?: ICUServiceWhereInput
    /**
     * Limit how many ICUServices to update.
     */
    limit?: number
  }

  /**
   * ICUService updateManyAndReturn
   */
  export type ICUServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICUService
     */
    select?: ICUServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ICUService
     */
    omit?: ICUServiceOmit<ExtArgs> | null
    /**
     * The data used to update ICUServices.
     */
    data: XOR<ICUServiceUpdateManyMutationInput, ICUServiceUncheckedUpdateManyInput>
    /**
     * Filter which ICUServices to update
     */
    where?: ICUServiceWhereInput
    /**
     * Limit how many ICUServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICUServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ICUService upsert
   */
  export type ICUServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICUService
     */
    select?: ICUServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ICUService
     */
    omit?: ICUServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICUServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the ICUService to update in case it exists.
     */
    where: ICUServiceWhereUniqueInput
    /**
     * In case the ICUService found by the `where` argument doesn't exist, create a new ICUService with this data.
     */
    create: XOR<ICUServiceCreateInput, ICUServiceUncheckedCreateInput>
    /**
     * In case the ICUService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ICUServiceUpdateInput, ICUServiceUncheckedUpdateInput>
  }

  /**
   * ICUService delete
   */
  export type ICUServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICUService
     */
    select?: ICUServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ICUService
     */
    omit?: ICUServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICUServiceInclude<ExtArgs> | null
    /**
     * Filter which ICUService to delete.
     */
    where: ICUServiceWhereUniqueInput
  }

  /**
   * ICUService deleteMany
   */
  export type ICUServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ICUServices to delete
     */
    where?: ICUServiceWhereInput
    /**
     * Limit how many ICUServices to delete.
     */
    limit?: number
  }

  /**
   * ICUService without action
   */
  export type ICUServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ICUService
     */
    select?: ICUServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ICUService
     */
    omit?: ICUServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ICUServiceInclude<ExtArgs> | null
  }


  /**
   * Model OutpatientService
   */

  export type AggregateOutpatientService = {
    _count: OutpatientServiceCountAggregateOutputType | null
    _avg: OutpatientServiceAvgAggregateOutputType | null
    _sum: OutpatientServiceSumAggregateOutputType | null
    _min: OutpatientServiceMinAggregateOutputType | null
    _max: OutpatientServiceMaxAggregateOutputType | null
  }

  export type OutpatientServiceAvgAggregateOutputType = {
    basePrice: number | null
    completionTimeD: number | null
    completionTimeH: number | null
  }

  export type OutpatientServiceSumAggregateOutputType = {
    basePrice: number | null
    completionTimeD: number | null
    completionTimeH: number | null
  }

  export type OutpatientServiceMinAggregateOutputType = {
    basePrice: number | null
    completionTimeD: number | null
    completionTimeH: number | null
    isAvailable: boolean | null
    acceptsWalkIns: boolean | null
    serviceID: string | null
  }

  export type OutpatientServiceMaxAggregateOutputType = {
    basePrice: number | null
    completionTimeD: number | null
    completionTimeH: number | null
    isAvailable: boolean | null
    acceptsWalkIns: boolean | null
    serviceID: string | null
  }

  export type OutpatientServiceCountAggregateOutputType = {
    basePrice: number
    completionTimeD: number
    completionTimeH: number
    isAvailable: number
    acceptsWalkIns: number
    serviceID: number
    _all: number
  }


  export type OutpatientServiceAvgAggregateInputType = {
    basePrice?: true
    completionTimeD?: true
    completionTimeH?: true
  }

  export type OutpatientServiceSumAggregateInputType = {
    basePrice?: true
    completionTimeD?: true
    completionTimeH?: true
  }

  export type OutpatientServiceMinAggregateInputType = {
    basePrice?: true
    completionTimeD?: true
    completionTimeH?: true
    isAvailable?: true
    acceptsWalkIns?: true
    serviceID?: true
  }

  export type OutpatientServiceMaxAggregateInputType = {
    basePrice?: true
    completionTimeD?: true
    completionTimeH?: true
    isAvailable?: true
    acceptsWalkIns?: true
    serviceID?: true
  }

  export type OutpatientServiceCountAggregateInputType = {
    basePrice?: true
    completionTimeD?: true
    completionTimeH?: true
    isAvailable?: true
    acceptsWalkIns?: true
    serviceID?: true
    _all?: true
  }

  export type OutpatientServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutpatientService to aggregate.
     */
    where?: OutpatientServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutpatientServices to fetch.
     */
    orderBy?: OutpatientServiceOrderByWithRelationInput | OutpatientServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutpatientServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutpatientServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutpatientServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OutpatientServices
    **/
    _count?: true | OutpatientServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OutpatientServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OutpatientServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutpatientServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutpatientServiceMaxAggregateInputType
  }

  export type GetOutpatientServiceAggregateType<T extends OutpatientServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateOutpatientService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutpatientService[P]>
      : GetScalarType<T[P], AggregateOutpatientService[P]>
  }




  export type OutpatientServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutpatientServiceWhereInput
    orderBy?: OutpatientServiceOrderByWithAggregationInput | OutpatientServiceOrderByWithAggregationInput[]
    by: OutpatientServiceScalarFieldEnum[] | OutpatientServiceScalarFieldEnum
    having?: OutpatientServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutpatientServiceCountAggregateInputType | true
    _avg?: OutpatientServiceAvgAggregateInputType
    _sum?: OutpatientServiceSumAggregateInputType
    _min?: OutpatientServiceMinAggregateInputType
    _max?: OutpatientServiceMaxAggregateInputType
  }

  export type OutpatientServiceGroupByOutputType = {
    basePrice: number
    completionTimeD: number
    completionTimeH: number
    isAvailable: boolean
    acceptsWalkIns: boolean
    serviceID: string
    _count: OutpatientServiceCountAggregateOutputType | null
    _avg: OutpatientServiceAvgAggregateOutputType | null
    _sum: OutpatientServiceSumAggregateOutputType | null
    _min: OutpatientServiceMinAggregateOutputType | null
    _max: OutpatientServiceMaxAggregateOutputType | null
  }

  type GetOutpatientServiceGroupByPayload<T extends OutpatientServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OutpatientServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutpatientServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutpatientServiceGroupByOutputType[P]>
            : GetScalarType<T[P], OutpatientServiceGroupByOutputType[P]>
        }
      >
    >


  export type OutpatientServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    basePrice?: boolean
    completionTimeD?: boolean
    completionTimeH?: boolean
    isAvailable?: boolean
    acceptsWalkIns?: boolean
    serviceID?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outpatientService"]>

  export type OutpatientServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    basePrice?: boolean
    completionTimeD?: boolean
    completionTimeH?: boolean
    isAvailable?: boolean
    acceptsWalkIns?: boolean
    serviceID?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outpatientService"]>

  export type OutpatientServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    basePrice?: boolean
    completionTimeD?: boolean
    completionTimeH?: boolean
    isAvailable?: boolean
    acceptsWalkIns?: boolean
    serviceID?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outpatientService"]>

  export type OutpatientServiceSelectScalar = {
    basePrice?: boolean
    completionTimeD?: boolean
    completionTimeH?: boolean
    isAvailable?: boolean
    acceptsWalkIns?: boolean
    serviceID?: boolean
  }

  export type OutpatientServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"basePrice" | "completionTimeD" | "completionTimeH" | "isAvailable" | "acceptsWalkIns" | "serviceID", ExtArgs["result"]["outpatientService"]>
  export type OutpatientServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type OutpatientServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type OutpatientServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $OutpatientServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OutpatientService"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      basePrice: number
      completionTimeD: number
      completionTimeH: number
      isAvailable: boolean
      acceptsWalkIns: boolean
      serviceID: string
    }, ExtArgs["result"]["outpatientService"]>
    composites: {}
  }

  type OutpatientServiceGetPayload<S extends boolean | null | undefined | OutpatientServiceDefaultArgs> = $Result.GetResult<Prisma.$OutpatientServicePayload, S>

  type OutpatientServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OutpatientServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OutpatientServiceCountAggregateInputType | true
    }

  export interface OutpatientServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OutpatientService'], meta: { name: 'OutpatientService' } }
    /**
     * Find zero or one OutpatientService that matches the filter.
     * @param {OutpatientServiceFindUniqueArgs} args - Arguments to find a OutpatientService
     * @example
     * // Get one OutpatientService
     * const outpatientService = await prisma.outpatientService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OutpatientServiceFindUniqueArgs>(args: SelectSubset<T, OutpatientServiceFindUniqueArgs<ExtArgs>>): Prisma__OutpatientServiceClient<$Result.GetResult<Prisma.$OutpatientServicePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one OutpatientService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OutpatientServiceFindUniqueOrThrowArgs} args - Arguments to find a OutpatientService
     * @example
     * // Get one OutpatientService
     * const outpatientService = await prisma.outpatientService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OutpatientServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, OutpatientServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OutpatientServiceClient<$Result.GetResult<Prisma.$OutpatientServicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first OutpatientService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutpatientServiceFindFirstArgs} args - Arguments to find a OutpatientService
     * @example
     * // Get one OutpatientService
     * const outpatientService = await prisma.outpatientService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OutpatientServiceFindFirstArgs>(args?: SelectSubset<T, OutpatientServiceFindFirstArgs<ExtArgs>>): Prisma__OutpatientServiceClient<$Result.GetResult<Prisma.$OutpatientServicePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first OutpatientService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutpatientServiceFindFirstOrThrowArgs} args - Arguments to find a OutpatientService
     * @example
     * // Get one OutpatientService
     * const outpatientService = await prisma.outpatientService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OutpatientServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, OutpatientServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__OutpatientServiceClient<$Result.GetResult<Prisma.$OutpatientServicePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more OutpatientServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutpatientServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OutpatientServices
     * const outpatientServices = await prisma.outpatientService.findMany()
     * 
     * // Get first 10 OutpatientServices
     * const outpatientServices = await prisma.outpatientService.findMany({ take: 10 })
     * 
     * // Only select the `basePrice`
     * const outpatientServiceWithBasePriceOnly = await prisma.outpatientService.findMany({ select: { basePrice: true } })
     * 
     */
    findMany<T extends OutpatientServiceFindManyArgs>(args?: SelectSubset<T, OutpatientServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutpatientServicePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a OutpatientService.
     * @param {OutpatientServiceCreateArgs} args - Arguments to create a OutpatientService.
     * @example
     * // Create one OutpatientService
     * const OutpatientService = await prisma.outpatientService.create({
     *   data: {
     *     // ... data to create a OutpatientService
     *   }
     * })
     * 
     */
    create<T extends OutpatientServiceCreateArgs>(args: SelectSubset<T, OutpatientServiceCreateArgs<ExtArgs>>): Prisma__OutpatientServiceClient<$Result.GetResult<Prisma.$OutpatientServicePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many OutpatientServices.
     * @param {OutpatientServiceCreateManyArgs} args - Arguments to create many OutpatientServices.
     * @example
     * // Create many OutpatientServices
     * const outpatientService = await prisma.outpatientService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OutpatientServiceCreateManyArgs>(args?: SelectSubset<T, OutpatientServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OutpatientServices and returns the data saved in the database.
     * @param {OutpatientServiceCreateManyAndReturnArgs} args - Arguments to create many OutpatientServices.
     * @example
     * // Create many OutpatientServices
     * const outpatientService = await prisma.outpatientService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OutpatientServices and only return the `basePrice`
     * const outpatientServiceWithBasePriceOnly = await prisma.outpatientService.createManyAndReturn({
     *   select: { basePrice: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OutpatientServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, OutpatientServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutpatientServicePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a OutpatientService.
     * @param {OutpatientServiceDeleteArgs} args - Arguments to delete one OutpatientService.
     * @example
     * // Delete one OutpatientService
     * const OutpatientService = await prisma.outpatientService.delete({
     *   where: {
     *     // ... filter to delete one OutpatientService
     *   }
     * })
     * 
     */
    delete<T extends OutpatientServiceDeleteArgs>(args: SelectSubset<T, OutpatientServiceDeleteArgs<ExtArgs>>): Prisma__OutpatientServiceClient<$Result.GetResult<Prisma.$OutpatientServicePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one OutpatientService.
     * @param {OutpatientServiceUpdateArgs} args - Arguments to update one OutpatientService.
     * @example
     * // Update one OutpatientService
     * const outpatientService = await prisma.outpatientService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OutpatientServiceUpdateArgs>(args: SelectSubset<T, OutpatientServiceUpdateArgs<ExtArgs>>): Prisma__OutpatientServiceClient<$Result.GetResult<Prisma.$OutpatientServicePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more OutpatientServices.
     * @param {OutpatientServiceDeleteManyArgs} args - Arguments to filter OutpatientServices to delete.
     * @example
     * // Delete a few OutpatientServices
     * const { count } = await prisma.outpatientService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OutpatientServiceDeleteManyArgs>(args?: SelectSubset<T, OutpatientServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutpatientServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutpatientServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OutpatientServices
     * const outpatientService = await prisma.outpatientService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OutpatientServiceUpdateManyArgs>(args: SelectSubset<T, OutpatientServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutpatientServices and returns the data updated in the database.
     * @param {OutpatientServiceUpdateManyAndReturnArgs} args - Arguments to update many OutpatientServices.
     * @example
     * // Update many OutpatientServices
     * const outpatientService = await prisma.outpatientService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OutpatientServices and only return the `basePrice`
     * const outpatientServiceWithBasePriceOnly = await prisma.outpatientService.updateManyAndReturn({
     *   select: { basePrice: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OutpatientServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, OutpatientServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutpatientServicePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one OutpatientService.
     * @param {OutpatientServiceUpsertArgs} args - Arguments to update or create a OutpatientService.
     * @example
     * // Update or create a OutpatientService
     * const outpatientService = await prisma.outpatientService.upsert({
     *   create: {
     *     // ... data to create a OutpatientService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OutpatientService we want to update
     *   }
     * })
     */
    upsert<T extends OutpatientServiceUpsertArgs>(args: SelectSubset<T, OutpatientServiceUpsertArgs<ExtArgs>>): Prisma__OutpatientServiceClient<$Result.GetResult<Prisma.$OutpatientServicePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of OutpatientServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutpatientServiceCountArgs} args - Arguments to filter OutpatientServices to count.
     * @example
     * // Count the number of OutpatientServices
     * const count = await prisma.outpatientService.count({
     *   where: {
     *     // ... the filter for the OutpatientServices we want to count
     *   }
     * })
    **/
    count<T extends OutpatientServiceCountArgs>(
      args?: Subset<T, OutpatientServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutpatientServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OutpatientService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutpatientServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutpatientServiceAggregateArgs>(args: Subset<T, OutpatientServiceAggregateArgs>): Prisma.PrismaPromise<GetOutpatientServiceAggregateType<T>>

    /**
     * Group by OutpatientService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutpatientServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutpatientServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutpatientServiceGroupByArgs['orderBy'] }
        : { orderBy?: OutpatientServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutpatientServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutpatientServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OutpatientService model
   */
  readonly fields: OutpatientServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OutpatientService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OutpatientServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OutpatientService model
   */ 
  interface OutpatientServiceFieldRefs {
    readonly basePrice: FieldRef<"OutpatientService", 'Float'>
    readonly completionTimeD: FieldRef<"OutpatientService", 'Int'>
    readonly completionTimeH: FieldRef<"OutpatientService", 'Int'>
    readonly isAvailable: FieldRef<"OutpatientService", 'Boolean'>
    readonly acceptsWalkIns: FieldRef<"OutpatientService", 'Boolean'>
    readonly serviceID: FieldRef<"OutpatientService", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OutpatientService findUnique
   */
  export type OutpatientServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutpatientService
     */
    select?: OutpatientServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutpatientService
     */
    omit?: OutpatientServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutpatientServiceInclude<ExtArgs> | null
    /**
     * Filter, which OutpatientService to fetch.
     */
    where: OutpatientServiceWhereUniqueInput
  }

  /**
   * OutpatientService findUniqueOrThrow
   */
  export type OutpatientServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutpatientService
     */
    select?: OutpatientServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutpatientService
     */
    omit?: OutpatientServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutpatientServiceInclude<ExtArgs> | null
    /**
     * Filter, which OutpatientService to fetch.
     */
    where: OutpatientServiceWhereUniqueInput
  }

  /**
   * OutpatientService findFirst
   */
  export type OutpatientServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutpatientService
     */
    select?: OutpatientServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutpatientService
     */
    omit?: OutpatientServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutpatientServiceInclude<ExtArgs> | null
    /**
     * Filter, which OutpatientService to fetch.
     */
    where?: OutpatientServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutpatientServices to fetch.
     */
    orderBy?: OutpatientServiceOrderByWithRelationInput | OutpatientServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutpatientServices.
     */
    cursor?: OutpatientServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutpatientServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutpatientServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutpatientServices.
     */
    distinct?: OutpatientServiceScalarFieldEnum | OutpatientServiceScalarFieldEnum[]
  }

  /**
   * OutpatientService findFirstOrThrow
   */
  export type OutpatientServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutpatientService
     */
    select?: OutpatientServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutpatientService
     */
    omit?: OutpatientServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutpatientServiceInclude<ExtArgs> | null
    /**
     * Filter, which OutpatientService to fetch.
     */
    where?: OutpatientServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutpatientServices to fetch.
     */
    orderBy?: OutpatientServiceOrderByWithRelationInput | OutpatientServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutpatientServices.
     */
    cursor?: OutpatientServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutpatientServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutpatientServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutpatientServices.
     */
    distinct?: OutpatientServiceScalarFieldEnum | OutpatientServiceScalarFieldEnum[]
  }

  /**
   * OutpatientService findMany
   */
  export type OutpatientServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutpatientService
     */
    select?: OutpatientServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutpatientService
     */
    omit?: OutpatientServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutpatientServiceInclude<ExtArgs> | null
    /**
     * Filter, which OutpatientServices to fetch.
     */
    where?: OutpatientServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutpatientServices to fetch.
     */
    orderBy?: OutpatientServiceOrderByWithRelationInput | OutpatientServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OutpatientServices.
     */
    cursor?: OutpatientServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutpatientServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutpatientServices.
     */
    skip?: number
    distinct?: OutpatientServiceScalarFieldEnum | OutpatientServiceScalarFieldEnum[]
  }

  /**
   * OutpatientService create
   */
  export type OutpatientServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutpatientService
     */
    select?: OutpatientServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutpatientService
     */
    omit?: OutpatientServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutpatientServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a OutpatientService.
     */
    data: XOR<OutpatientServiceCreateInput, OutpatientServiceUncheckedCreateInput>
  }

  /**
   * OutpatientService createMany
   */
  export type OutpatientServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OutpatientServices.
     */
    data: OutpatientServiceCreateManyInput | OutpatientServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OutpatientService createManyAndReturn
   */
  export type OutpatientServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutpatientService
     */
    select?: OutpatientServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OutpatientService
     */
    omit?: OutpatientServiceOmit<ExtArgs> | null
    /**
     * The data used to create many OutpatientServices.
     */
    data: OutpatientServiceCreateManyInput | OutpatientServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutpatientServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OutpatientService update
   */
  export type OutpatientServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutpatientService
     */
    select?: OutpatientServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutpatientService
     */
    omit?: OutpatientServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutpatientServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a OutpatientService.
     */
    data: XOR<OutpatientServiceUpdateInput, OutpatientServiceUncheckedUpdateInput>
    /**
     * Choose, which OutpatientService to update.
     */
    where: OutpatientServiceWhereUniqueInput
  }

  /**
   * OutpatientService updateMany
   */
  export type OutpatientServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OutpatientServices.
     */
    data: XOR<OutpatientServiceUpdateManyMutationInput, OutpatientServiceUncheckedUpdateManyInput>
    /**
     * Filter which OutpatientServices to update
     */
    where?: OutpatientServiceWhereInput
    /**
     * Limit how many OutpatientServices to update.
     */
    limit?: number
  }

  /**
   * OutpatientService updateManyAndReturn
   */
  export type OutpatientServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutpatientService
     */
    select?: OutpatientServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OutpatientService
     */
    omit?: OutpatientServiceOmit<ExtArgs> | null
    /**
     * The data used to update OutpatientServices.
     */
    data: XOR<OutpatientServiceUpdateManyMutationInput, OutpatientServiceUncheckedUpdateManyInput>
    /**
     * Filter which OutpatientServices to update
     */
    where?: OutpatientServiceWhereInput
    /**
     * Limit how many OutpatientServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutpatientServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OutpatientService upsert
   */
  export type OutpatientServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutpatientService
     */
    select?: OutpatientServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutpatientService
     */
    omit?: OutpatientServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutpatientServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the OutpatientService to update in case it exists.
     */
    where: OutpatientServiceWhereUniqueInput
    /**
     * In case the OutpatientService found by the `where` argument doesn't exist, create a new OutpatientService with this data.
     */
    create: XOR<OutpatientServiceCreateInput, OutpatientServiceUncheckedCreateInput>
    /**
     * In case the OutpatientService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutpatientServiceUpdateInput, OutpatientServiceUncheckedUpdateInput>
  }

  /**
   * OutpatientService delete
   */
  export type OutpatientServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutpatientService
     */
    select?: OutpatientServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutpatientService
     */
    omit?: OutpatientServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutpatientServiceInclude<ExtArgs> | null
    /**
     * Filter which OutpatientService to delete.
     */
    where: OutpatientServiceWhereUniqueInput
  }

  /**
   * OutpatientService deleteMany
   */
  export type OutpatientServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutpatientServices to delete
     */
    where?: OutpatientServiceWhereInput
    /**
     * Limit how many OutpatientServices to delete.
     */
    limit?: number
  }

  /**
   * OutpatientService without action
   */
  export type OutpatientServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutpatientService
     */
    select?: OutpatientServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutpatientService
     */
    omit?: OutpatientServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutpatientServiceInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    contactID: string | null
    info: string | null
    type: $Enums.ContactType | null
    facilityID: string | null
    divisionID: string | null
    serviceID: string | null
  }

  export type ContactMaxAggregateOutputType = {
    contactID: string | null
    info: string | null
    type: $Enums.ContactType | null
    facilityID: string | null
    divisionID: string | null
    serviceID: string | null
  }

  export type ContactCountAggregateOutputType = {
    contactID: number
    info: number
    type: number
    facilityID: number
    divisionID: number
    serviceID: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    contactID?: true
    info?: true
    type?: true
    facilityID?: true
    divisionID?: true
    serviceID?: true
  }

  export type ContactMaxAggregateInputType = {
    contactID?: true
    info?: true
    type?: true
    facilityID?: true
    divisionID?: true
    serviceID?: true
  }

  export type ContactCountAggregateInputType = {
    contactID?: true
    info?: true
    type?: true
    facilityID?: true
    divisionID?: true
    serviceID?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    contactID: string
    info: string
    type: $Enums.ContactType
    facilityID: string | null
    divisionID: string | null
    serviceID: string | null
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contactID?: boolean
    info?: boolean
    type?: boolean
    facilityID?: boolean
    divisionID?: boolean
    serviceID?: boolean
    facility?: boolean | Contact$facilityArgs<ExtArgs>
    division?: boolean | Contact$divisionArgs<ExtArgs>
    service?: boolean | Contact$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contactID?: boolean
    info?: boolean
    type?: boolean
    facilityID?: boolean
    divisionID?: boolean
    serviceID?: boolean
    facility?: boolean | Contact$facilityArgs<ExtArgs>
    division?: boolean | Contact$divisionArgs<ExtArgs>
    service?: boolean | Contact$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contactID?: boolean
    info?: boolean
    type?: boolean
    facilityID?: boolean
    divisionID?: boolean
    serviceID?: boolean
    facility?: boolean | Contact$facilityArgs<ExtArgs>
    division?: boolean | Contact$divisionArgs<ExtArgs>
    service?: boolean | Contact$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    contactID?: boolean
    info?: boolean
    type?: boolean
    facilityID?: boolean
    divisionID?: boolean
    serviceID?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"contactID" | "info" | "type" | "facilityID" | "divisionID" | "serviceID", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | Contact$facilityArgs<ExtArgs>
    division?: boolean | Contact$divisionArgs<ExtArgs>
    service?: boolean | Contact$serviceArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | Contact$facilityArgs<ExtArgs>
    division?: boolean | Contact$divisionArgs<ExtArgs>
    service?: boolean | Contact$serviceArgs<ExtArgs>
  }
  export type ContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | Contact$facilityArgs<ExtArgs>
    division?: boolean | Contact$divisionArgs<ExtArgs>
    service?: boolean | Contact$serviceArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      facility: Prisma.$FacilityPayload<ExtArgs> | null
      division: Prisma.$DivisionPayload<ExtArgs> | null
      service: Prisma.$ServicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      contactID: string
      info: string
      type: $Enums.ContactType
      facilityID: string | null
      divisionID: string | null
      serviceID: string | null
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `contactID`
     * const contactWithContactIDOnly = await prisma.contact.findMany({ select: { contactID: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `contactID`
     * const contactWithContactIDOnly = await prisma.contact.createManyAndReturn({
     *   select: { contactID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `contactID`
     * const contactWithContactIDOnly = await prisma.contact.updateManyAndReturn({
     *   select: { contactID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facility<T extends Contact$facilityArgs<ExtArgs> = {}>(args?: Subset<T, Contact$facilityArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    division<T extends Contact$divisionArgs<ExtArgs> = {}>(args?: Subset<T, Contact$divisionArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    service<T extends Contact$serviceArgs<ExtArgs> = {}>(args?: Subset<T, Contact$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */ 
  interface ContactFieldRefs {
    readonly contactID: FieldRef<"Contact", 'String'>
    readonly info: FieldRef<"Contact", 'String'>
    readonly type: FieldRef<"Contact", 'ContactType'>
    readonly facilityID: FieldRef<"Contact", 'String'>
    readonly divisionID: FieldRef<"Contact", 'String'>
    readonly serviceID: FieldRef<"Contact", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact updateManyAndReturn
   */
  export type ContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact.facility
   */
  export type Contact$facilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null
    where?: FacilityWhereInput
  }

  /**
   * Contact.division
   */
  export type Contact$divisionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    where?: DivisionWhereInput
  }

  /**
   * Contact.service
   */
  export type Contact$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model UpdateLog
   */

  export type AggregateUpdateLog = {
    _count: UpdateLogCountAggregateOutputType | null
    _min: UpdateLogMinAggregateOutputType | null
    _max: UpdateLogMaxAggregateOutputType | null
  }

  export type UpdateLogMinAggregateOutputType = {
    updateLogID: string | null
    entity: string | null
    action: $Enums.Action | null
    createdAt: Date | null
    facilityID: string | null
    divisionID: string | null
    employeeID: string | null
  }

  export type UpdateLogMaxAggregateOutputType = {
    updateLogID: string | null
    entity: string | null
    action: $Enums.Action | null
    createdAt: Date | null
    facilityID: string | null
    divisionID: string | null
    employeeID: string | null
  }

  export type UpdateLogCountAggregateOutputType = {
    updateLogID: number
    entity: number
    action: number
    createdAt: number
    facilityID: number
    divisionID: number
    employeeID: number
    _all: number
  }


  export type UpdateLogMinAggregateInputType = {
    updateLogID?: true
    entity?: true
    action?: true
    createdAt?: true
    facilityID?: true
    divisionID?: true
    employeeID?: true
  }

  export type UpdateLogMaxAggregateInputType = {
    updateLogID?: true
    entity?: true
    action?: true
    createdAt?: true
    facilityID?: true
    divisionID?: true
    employeeID?: true
  }

  export type UpdateLogCountAggregateInputType = {
    updateLogID?: true
    entity?: true
    action?: true
    createdAt?: true
    facilityID?: true
    divisionID?: true
    employeeID?: true
    _all?: true
  }

  export type UpdateLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UpdateLog to aggregate.
     */
    where?: UpdateLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UpdateLogs to fetch.
     */
    orderBy?: UpdateLogOrderByWithRelationInput | UpdateLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UpdateLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UpdateLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UpdateLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UpdateLogs
    **/
    _count?: true | UpdateLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UpdateLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UpdateLogMaxAggregateInputType
  }

  export type GetUpdateLogAggregateType<T extends UpdateLogAggregateArgs> = {
        [P in keyof T & keyof AggregateUpdateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUpdateLog[P]>
      : GetScalarType<T[P], AggregateUpdateLog[P]>
  }




  export type UpdateLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UpdateLogWhereInput
    orderBy?: UpdateLogOrderByWithAggregationInput | UpdateLogOrderByWithAggregationInput[]
    by: UpdateLogScalarFieldEnum[] | UpdateLogScalarFieldEnum
    having?: UpdateLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UpdateLogCountAggregateInputType | true
    _min?: UpdateLogMinAggregateInputType
    _max?: UpdateLogMaxAggregateInputType
  }

  export type UpdateLogGroupByOutputType = {
    updateLogID: string
    entity: string
    action: $Enums.Action
    createdAt: Date
    facilityID: string
    divisionID: string | null
    employeeID: string
    _count: UpdateLogCountAggregateOutputType | null
    _min: UpdateLogMinAggregateOutputType | null
    _max: UpdateLogMaxAggregateOutputType | null
  }

  type GetUpdateLogGroupByPayload<T extends UpdateLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UpdateLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UpdateLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UpdateLogGroupByOutputType[P]>
            : GetScalarType<T[P], UpdateLogGroupByOutputType[P]>
        }
      >
    >


  export type UpdateLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    updateLogID?: boolean
    entity?: boolean
    action?: boolean
    createdAt?: boolean
    facilityID?: boolean
    divisionID?: boolean
    employeeID?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    division?: boolean | UpdateLog$divisionArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["updateLog"]>

  export type UpdateLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    updateLogID?: boolean
    entity?: boolean
    action?: boolean
    createdAt?: boolean
    facilityID?: boolean
    divisionID?: boolean
    employeeID?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    division?: boolean | UpdateLog$divisionArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["updateLog"]>

  export type UpdateLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    updateLogID?: boolean
    entity?: boolean
    action?: boolean
    createdAt?: boolean
    facilityID?: boolean
    divisionID?: boolean
    employeeID?: boolean
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    division?: boolean | UpdateLog$divisionArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["updateLog"]>

  export type UpdateLogSelectScalar = {
    updateLogID?: boolean
    entity?: boolean
    action?: boolean
    createdAt?: boolean
    facilityID?: boolean
    divisionID?: boolean
    employeeID?: boolean
  }

  export type UpdateLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"updateLogID" | "entity" | "action" | "createdAt" | "facilityID" | "divisionID" | "employeeID", ExtArgs["result"]["updateLog"]>
  export type UpdateLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    division?: boolean | UpdateLog$divisionArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type UpdateLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    division?: boolean | UpdateLog$divisionArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type UpdateLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facility?: boolean | FacilityDefaultArgs<ExtArgs>
    division?: boolean | UpdateLog$divisionArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $UpdateLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UpdateLog"
    objects: {
      facility: Prisma.$FacilityPayload<ExtArgs>
      division: Prisma.$DivisionPayload<ExtArgs> | null
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      updateLogID: string
      entity: string
      action: $Enums.Action
      createdAt: Date
      facilityID: string
      divisionID: string | null
      employeeID: string
    }, ExtArgs["result"]["updateLog"]>
    composites: {}
  }

  type UpdateLogGetPayload<S extends boolean | null | undefined | UpdateLogDefaultArgs> = $Result.GetResult<Prisma.$UpdateLogPayload, S>

  type UpdateLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UpdateLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UpdateLogCountAggregateInputType | true
    }

  export interface UpdateLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UpdateLog'], meta: { name: 'UpdateLog' } }
    /**
     * Find zero or one UpdateLog that matches the filter.
     * @param {UpdateLogFindUniqueArgs} args - Arguments to find a UpdateLog
     * @example
     * // Get one UpdateLog
     * const updateLog = await prisma.updateLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UpdateLogFindUniqueArgs>(args: SelectSubset<T, UpdateLogFindUniqueArgs<ExtArgs>>): Prisma__UpdateLogClient<$Result.GetResult<Prisma.$UpdateLogPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UpdateLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UpdateLogFindUniqueOrThrowArgs} args - Arguments to find a UpdateLog
     * @example
     * // Get one UpdateLog
     * const updateLog = await prisma.updateLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UpdateLogFindUniqueOrThrowArgs>(args: SelectSubset<T, UpdateLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UpdateLogClient<$Result.GetResult<Prisma.$UpdateLogPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UpdateLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdateLogFindFirstArgs} args - Arguments to find a UpdateLog
     * @example
     * // Get one UpdateLog
     * const updateLog = await prisma.updateLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UpdateLogFindFirstArgs>(args?: SelectSubset<T, UpdateLogFindFirstArgs<ExtArgs>>): Prisma__UpdateLogClient<$Result.GetResult<Prisma.$UpdateLogPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UpdateLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdateLogFindFirstOrThrowArgs} args - Arguments to find a UpdateLog
     * @example
     * // Get one UpdateLog
     * const updateLog = await prisma.updateLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UpdateLogFindFirstOrThrowArgs>(args?: SelectSubset<T, UpdateLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__UpdateLogClient<$Result.GetResult<Prisma.$UpdateLogPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UpdateLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdateLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UpdateLogs
     * const updateLogs = await prisma.updateLog.findMany()
     * 
     * // Get first 10 UpdateLogs
     * const updateLogs = await prisma.updateLog.findMany({ take: 10 })
     * 
     * // Only select the `updateLogID`
     * const updateLogWithUpdateLogIDOnly = await prisma.updateLog.findMany({ select: { updateLogID: true } })
     * 
     */
    findMany<T extends UpdateLogFindManyArgs>(args?: SelectSubset<T, UpdateLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpdateLogPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UpdateLog.
     * @param {UpdateLogCreateArgs} args - Arguments to create a UpdateLog.
     * @example
     * // Create one UpdateLog
     * const UpdateLog = await prisma.updateLog.create({
     *   data: {
     *     // ... data to create a UpdateLog
     *   }
     * })
     * 
     */
    create<T extends UpdateLogCreateArgs>(args: SelectSubset<T, UpdateLogCreateArgs<ExtArgs>>): Prisma__UpdateLogClient<$Result.GetResult<Prisma.$UpdateLogPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UpdateLogs.
     * @param {UpdateLogCreateManyArgs} args - Arguments to create many UpdateLogs.
     * @example
     * // Create many UpdateLogs
     * const updateLog = await prisma.updateLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UpdateLogCreateManyArgs>(args?: SelectSubset<T, UpdateLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UpdateLogs and returns the data saved in the database.
     * @param {UpdateLogCreateManyAndReturnArgs} args - Arguments to create many UpdateLogs.
     * @example
     * // Create many UpdateLogs
     * const updateLog = await prisma.updateLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UpdateLogs and only return the `updateLogID`
     * const updateLogWithUpdateLogIDOnly = await prisma.updateLog.createManyAndReturn({
     *   select: { updateLogID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UpdateLogCreateManyAndReturnArgs>(args?: SelectSubset<T, UpdateLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpdateLogPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a UpdateLog.
     * @param {UpdateLogDeleteArgs} args - Arguments to delete one UpdateLog.
     * @example
     * // Delete one UpdateLog
     * const UpdateLog = await prisma.updateLog.delete({
     *   where: {
     *     // ... filter to delete one UpdateLog
     *   }
     * })
     * 
     */
    delete<T extends UpdateLogDeleteArgs>(args: SelectSubset<T, UpdateLogDeleteArgs<ExtArgs>>): Prisma__UpdateLogClient<$Result.GetResult<Prisma.$UpdateLogPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UpdateLog.
     * @param {UpdateLogUpdateArgs} args - Arguments to update one UpdateLog.
     * @example
     * // Update one UpdateLog
     * const updateLog = await prisma.updateLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UpdateLogUpdateArgs>(args: SelectSubset<T, UpdateLogUpdateArgs<ExtArgs>>): Prisma__UpdateLogClient<$Result.GetResult<Prisma.$UpdateLogPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UpdateLogs.
     * @param {UpdateLogDeleteManyArgs} args - Arguments to filter UpdateLogs to delete.
     * @example
     * // Delete a few UpdateLogs
     * const { count } = await prisma.updateLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UpdateLogDeleteManyArgs>(args?: SelectSubset<T, UpdateLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UpdateLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdateLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UpdateLogs
     * const updateLog = await prisma.updateLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UpdateLogUpdateManyArgs>(args: SelectSubset<T, UpdateLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UpdateLogs and returns the data updated in the database.
     * @param {UpdateLogUpdateManyAndReturnArgs} args - Arguments to update many UpdateLogs.
     * @example
     * // Update many UpdateLogs
     * const updateLog = await prisma.updateLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UpdateLogs and only return the `updateLogID`
     * const updateLogWithUpdateLogIDOnly = await prisma.updateLog.updateManyAndReturn({
     *   select: { updateLogID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UpdateLogUpdateManyAndReturnArgs>(args: SelectSubset<T, UpdateLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpdateLogPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one UpdateLog.
     * @param {UpdateLogUpsertArgs} args - Arguments to update or create a UpdateLog.
     * @example
     * // Update or create a UpdateLog
     * const updateLog = await prisma.updateLog.upsert({
     *   create: {
     *     // ... data to create a UpdateLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UpdateLog we want to update
     *   }
     * })
     */
    upsert<T extends UpdateLogUpsertArgs>(args: SelectSubset<T, UpdateLogUpsertArgs<ExtArgs>>): Prisma__UpdateLogClient<$Result.GetResult<Prisma.$UpdateLogPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UpdateLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdateLogCountArgs} args - Arguments to filter UpdateLogs to count.
     * @example
     * // Count the number of UpdateLogs
     * const count = await prisma.updateLog.count({
     *   where: {
     *     // ... the filter for the UpdateLogs we want to count
     *   }
     * })
    **/
    count<T extends UpdateLogCountArgs>(
      args?: Subset<T, UpdateLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UpdateLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UpdateLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdateLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UpdateLogAggregateArgs>(args: Subset<T, UpdateLogAggregateArgs>): Prisma.PrismaPromise<GetUpdateLogAggregateType<T>>

    /**
     * Group by UpdateLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdateLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UpdateLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UpdateLogGroupByArgs['orderBy'] }
        : { orderBy?: UpdateLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UpdateLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUpdateLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UpdateLog model
   */
  readonly fields: UpdateLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UpdateLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UpdateLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facility<T extends FacilityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacilityDefaultArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    division<T extends UpdateLog$divisionArgs<ExtArgs> = {}>(args?: Subset<T, UpdateLog$divisionArgs<ExtArgs>>): Prisma__DivisionClient<$Result.GetResult<Prisma.$DivisionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UpdateLog model
   */ 
  interface UpdateLogFieldRefs {
    readonly updateLogID: FieldRef<"UpdateLog", 'String'>
    readonly entity: FieldRef<"UpdateLog", 'String'>
    readonly action: FieldRef<"UpdateLog", 'Action'>
    readonly createdAt: FieldRef<"UpdateLog", 'DateTime'>
    readonly facilityID: FieldRef<"UpdateLog", 'String'>
    readonly divisionID: FieldRef<"UpdateLog", 'String'>
    readonly employeeID: FieldRef<"UpdateLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UpdateLog findUnique
   */
  export type UpdateLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateLog
     */
    select?: UpdateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateLog
     */
    omit?: UpdateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateLogInclude<ExtArgs> | null
    /**
     * Filter, which UpdateLog to fetch.
     */
    where: UpdateLogWhereUniqueInput
  }

  /**
   * UpdateLog findUniqueOrThrow
   */
  export type UpdateLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateLog
     */
    select?: UpdateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateLog
     */
    omit?: UpdateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateLogInclude<ExtArgs> | null
    /**
     * Filter, which UpdateLog to fetch.
     */
    where: UpdateLogWhereUniqueInput
  }

  /**
   * UpdateLog findFirst
   */
  export type UpdateLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateLog
     */
    select?: UpdateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateLog
     */
    omit?: UpdateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateLogInclude<ExtArgs> | null
    /**
     * Filter, which UpdateLog to fetch.
     */
    where?: UpdateLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UpdateLogs to fetch.
     */
    orderBy?: UpdateLogOrderByWithRelationInput | UpdateLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UpdateLogs.
     */
    cursor?: UpdateLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UpdateLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UpdateLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UpdateLogs.
     */
    distinct?: UpdateLogScalarFieldEnum | UpdateLogScalarFieldEnum[]
  }

  /**
   * UpdateLog findFirstOrThrow
   */
  export type UpdateLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateLog
     */
    select?: UpdateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateLog
     */
    omit?: UpdateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateLogInclude<ExtArgs> | null
    /**
     * Filter, which UpdateLog to fetch.
     */
    where?: UpdateLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UpdateLogs to fetch.
     */
    orderBy?: UpdateLogOrderByWithRelationInput | UpdateLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UpdateLogs.
     */
    cursor?: UpdateLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UpdateLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UpdateLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UpdateLogs.
     */
    distinct?: UpdateLogScalarFieldEnum | UpdateLogScalarFieldEnum[]
  }

  /**
   * UpdateLog findMany
   */
  export type UpdateLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateLog
     */
    select?: UpdateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateLog
     */
    omit?: UpdateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateLogInclude<ExtArgs> | null
    /**
     * Filter, which UpdateLogs to fetch.
     */
    where?: UpdateLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UpdateLogs to fetch.
     */
    orderBy?: UpdateLogOrderByWithRelationInput | UpdateLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UpdateLogs.
     */
    cursor?: UpdateLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UpdateLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UpdateLogs.
     */
    skip?: number
    distinct?: UpdateLogScalarFieldEnum | UpdateLogScalarFieldEnum[]
  }

  /**
   * UpdateLog create
   */
  export type UpdateLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateLog
     */
    select?: UpdateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateLog
     */
    omit?: UpdateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateLogInclude<ExtArgs> | null
    /**
     * The data needed to create a UpdateLog.
     */
    data: XOR<UpdateLogCreateInput, UpdateLogUncheckedCreateInput>
  }

  /**
   * UpdateLog createMany
   */
  export type UpdateLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UpdateLogs.
     */
    data: UpdateLogCreateManyInput | UpdateLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UpdateLog createManyAndReturn
   */
  export type UpdateLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateLog
     */
    select?: UpdateLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateLog
     */
    omit?: UpdateLogOmit<ExtArgs> | null
    /**
     * The data used to create many UpdateLogs.
     */
    data: UpdateLogCreateManyInput | UpdateLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UpdateLog update
   */
  export type UpdateLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateLog
     */
    select?: UpdateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateLog
     */
    omit?: UpdateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateLogInclude<ExtArgs> | null
    /**
     * The data needed to update a UpdateLog.
     */
    data: XOR<UpdateLogUpdateInput, UpdateLogUncheckedUpdateInput>
    /**
     * Choose, which UpdateLog to update.
     */
    where: UpdateLogWhereUniqueInput
  }

  /**
   * UpdateLog updateMany
   */
  export type UpdateLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UpdateLogs.
     */
    data: XOR<UpdateLogUpdateManyMutationInput, UpdateLogUncheckedUpdateManyInput>
    /**
     * Filter which UpdateLogs to update
     */
    where?: UpdateLogWhereInput
    /**
     * Limit how many UpdateLogs to update.
     */
    limit?: number
  }

  /**
   * UpdateLog updateManyAndReturn
   */
  export type UpdateLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateLog
     */
    select?: UpdateLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateLog
     */
    omit?: UpdateLogOmit<ExtArgs> | null
    /**
     * The data used to update UpdateLogs.
     */
    data: XOR<UpdateLogUpdateManyMutationInput, UpdateLogUncheckedUpdateManyInput>
    /**
     * Filter which UpdateLogs to update
     */
    where?: UpdateLogWhereInput
    /**
     * Limit how many UpdateLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UpdateLog upsert
   */
  export type UpdateLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateLog
     */
    select?: UpdateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateLog
     */
    omit?: UpdateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateLogInclude<ExtArgs> | null
    /**
     * The filter to search for the UpdateLog to update in case it exists.
     */
    where: UpdateLogWhereUniqueInput
    /**
     * In case the UpdateLog found by the `where` argument doesn't exist, create a new UpdateLog with this data.
     */
    create: XOR<UpdateLogCreateInput, UpdateLogUncheckedCreateInput>
    /**
     * In case the UpdateLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UpdateLogUpdateInput, UpdateLogUncheckedUpdateInput>
  }

  /**
   * UpdateLog delete
   */
  export type UpdateLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateLog
     */
    select?: UpdateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateLog
     */
    omit?: UpdateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateLogInclude<ExtArgs> | null
    /**
     * Filter which UpdateLog to delete.
     */
    where: UpdateLogWhereUniqueInput
  }

  /**
   * UpdateLog deleteMany
   */
  export type UpdateLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UpdateLogs to delete
     */
    where?: UpdateLogWhereInput
    /**
     * Limit how many UpdateLogs to delete.
     */
    limit?: number
  }

  /**
   * UpdateLog.division
   */
  export type UpdateLog$divisionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Division
     */
    select?: DivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Division
     */
    omit?: DivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DivisionInclude<ExtArgs> | null
    where?: DivisionWhereInput
  }

  /**
   * UpdateLog without action
   */
  export type UpdateLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UpdateLog
     */
    select?: UpdateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UpdateLog
     */
    omit?: UpdateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const RegionScalarFieldEnum: {
    regionID: 'regionID',
    name: 'name',
    id: 'id'
  };

  export type RegionScalarFieldEnum = (typeof RegionScalarFieldEnum)[keyof typeof RegionScalarFieldEnum]


  export const POrCScalarFieldEnum: {
    pOrCID: 'pOrCID',
    name: 'name',
    id: 'id',
    regionID: 'regionID'
  };

  export type POrCScalarFieldEnum = (typeof POrCScalarFieldEnum)[keyof typeof POrCScalarFieldEnum]


  export const COrMScalarFieldEnum: {
    cOrMID: 'cOrMID',
    name: 'name',
    id: 'id',
    pOrCID: 'pOrCID'
  };

  export type COrMScalarFieldEnum = (typeof COrMScalarFieldEnum)[keyof typeof COrMScalarFieldEnum]


  export const BrgyScalarFieldEnum: {
    brgyID: 'brgyID',
    name: 'name',
    id: 'id',
    cOrMID: 'cOrMID'
  };

  export type BrgyScalarFieldEnum = (typeof BrgyScalarFieldEnum)[keyof typeof BrgyScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    regionID: 'regionID',
    pOrCID: 'pOrCID',
    cOrMID: 'cOrMID',
    brgyID: 'brgyID',
    street: 'street',
    facilityID: 'facilityID'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const FacilityScalarFieldEnum: {
    facilityID: 'facilityID',
    name: 'name',
    photo: 'photo',
    openingTime: 'openingTime',
    closingTime: 'closingTime',
    facilityType: 'facilityType',
    ownership: 'ownership',
    bookingSystem: 'bookingSystem',
    acceptedProviders: 'acceptedProviders',
    updatedAt: 'updatedAt'
  };

  export type FacilityScalarFieldEnum = (typeof FacilityScalarFieldEnum)[keyof typeof FacilityScalarFieldEnum]


  export const DivisionScalarFieldEnum: {
    divisionID: 'divisionID',
    name: 'name',
    openingTime: 'openingTime',
    closingTime: 'closingTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    facilityID: 'facilityID'
  };

  export type DivisionScalarFieldEnum = (typeof DivisionScalarFieldEnum)[keyof typeof DivisionScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    employeeID: 'employeeID',
    password: 'password',
    role: 'role',
    fname: 'fname',
    mname: 'mname',
    lname: 'lname',
    photo: 'photo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    facilityID: 'facilityID'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    sessionID: 'sessionID',
    expiresAt: 'expiresAt',
    employeeID: 'employeeID'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    serviceID: 'serviceID',
    type: 'type',
    keywords: 'keywords',
    note: 'note',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    facilityID: 'facilityID',
    divisionID: 'divisionID'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const AmbulanceServiceScalarFieldEnum: {
    openingTime: 'openingTime',
    closingTime: 'closingTime',
    availability: 'availability',
    baseRate: 'baseRate',
    minCoverageRadius: 'minCoverageRadius',
    mileageRate: 'mileageRate',
    maxCoverageRadius: 'maxCoverageRadius',
    serviceID: 'serviceID'
  };

  export type AmbulanceServiceScalarFieldEnum = (typeof AmbulanceServiceScalarFieldEnum)[keyof typeof AmbulanceServiceScalarFieldEnum]


  export const BloodTypeMappingScalarFieldEnum: {
    A_P: 'A_P',
    A_N: 'A_N',
    B_P: 'B_P',
    B_N: 'B_N',
    O_P: 'O_P',
    O_N: 'O_N',
    AB_P: 'AB_P',
    AB_N: 'AB_N',
    serviceID: 'serviceID'
  };

  export type BloodTypeMappingScalarFieldEnum = (typeof BloodTypeMappingScalarFieldEnum)[keyof typeof BloodTypeMappingScalarFieldEnum]


  export const BloodBankServiceScalarFieldEnum: {
    openingTime: 'openingTime',
    closingTime: 'closingTime',
    basePricePerUnit: 'basePricePerUnit',
    turnaroundTimeD: 'turnaroundTimeD',
    turnaroundTimeH: 'turnaroundTimeH',
    serviceID: 'serviceID'
  };

  export type BloodBankServiceScalarFieldEnum = (typeof BloodBankServiceScalarFieldEnum)[keyof typeof BloodBankServiceScalarFieldEnum]


  export const ERServiceScalarFieldEnum: {
    openingTime: 'openingTime',
    closingTime: 'closingTime',
    load: 'load',
    availableBeds: 'availableBeds',
    nonUrgentPatients: 'nonUrgentPatients',
    nonUrgentQueueLength: 'nonUrgentQueueLength',
    urgentPatients: 'urgentPatients',
    urgentQueueLength: 'urgentQueueLength',
    criticalPatients: 'criticalPatients',
    criticalQueueLength: 'criticalQueueLength',
    serviceID: 'serviceID'
  };

  export type ERServiceScalarFieldEnum = (typeof ERServiceScalarFieldEnum)[keyof typeof ERServiceScalarFieldEnum]


  export const ICUServiceScalarFieldEnum: {
    openingTime: 'openingTime',
    closingTime: 'closingTime',
    load: 'load',
    baseRate: 'baseRate',
    availableBeds: 'availableBeds',
    cardiacSupport: 'cardiacSupport',
    neurologicalSupport: 'neurologicalSupport',
    renalSupport: 'renalSupport',
    respiratorySupport: 'respiratorySupport',
    serviceID: 'serviceID'
  };

  export type ICUServiceScalarFieldEnum = (typeof ICUServiceScalarFieldEnum)[keyof typeof ICUServiceScalarFieldEnum]


  export const OutpatientServiceScalarFieldEnum: {
    basePrice: 'basePrice',
    completionTimeD: 'completionTimeD',
    completionTimeH: 'completionTimeH',
    isAvailable: 'isAvailable',
    acceptsWalkIns: 'acceptsWalkIns',
    serviceID: 'serviceID'
  };

  export type OutpatientServiceScalarFieldEnum = (typeof OutpatientServiceScalarFieldEnum)[keyof typeof OutpatientServiceScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    contactID: 'contactID',
    info: 'info',
    type: 'type',
    facilityID: 'facilityID',
    divisionID: 'divisionID',
    serviceID: 'serviceID'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const UpdateLogScalarFieldEnum: {
    updateLogID: 'updateLogID',
    entity: 'entity',
    action: 'action',
    createdAt: 'createdAt',
    facilityID: 'facilityID',
    divisionID: 'divisionID',
    employeeID: 'employeeID'
  };

  export type UpdateLogScalarFieldEnum = (typeof UpdateLogScalarFieldEnum)[keyof typeof UpdateLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'FacilityType'
   */
  export type EnumFacilityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FacilityType'>
    


  /**
   * Reference to a field of type 'FacilityType[]'
   */
  export type ListEnumFacilityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FacilityType[]'>
    


  /**
   * Reference to a field of type 'Ownership'
   */
  export type EnumOwnershipFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Ownership'>
    


  /**
   * Reference to a field of type 'Ownership[]'
   */
  export type ListEnumOwnershipFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Ownership[]'>
    


  /**
   * Reference to a field of type 'Provider[]'
   */
  export type ListEnumProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Provider[]'>
    


  /**
   * Reference to a field of type 'Provider'
   */
  export type EnumProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Provider'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Availability'
   */
  export type EnumAvailabilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Availability'>
    


  /**
   * Reference to a field of type 'Availability[]'
   */
  export type ListEnumAvailabilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Availability[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Load'
   */
  export type EnumLoadFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Load'>
    


  /**
   * Reference to a field of type 'Load[]'
   */
  export type ListEnumLoadFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Load[]'>
    


  /**
   * Reference to a field of type 'ContactType'
   */
  export type EnumContactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactType'>
    


  /**
   * Reference to a field of type 'ContactType[]'
   */
  export type ListEnumContactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactType[]'>
    


  /**
   * Reference to a field of type 'Action'
   */
  export type EnumActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Action'>
    


  /**
   * Reference to a field of type 'Action[]'
   */
  export type ListEnumActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Action[]'>
    
  /**
   * Deep Input Types
   */


  export type RegionWhereInput = {
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    regionID?: IntFilter<"Region"> | number
    name?: StringFilter<"Region"> | string
    id?: IntFilter<"Region"> | number
    pOrCs?: POrCListRelationFilter
    addresses?: AddressListRelationFilter
  }

  export type RegionOrderByWithRelationInput = {
    regionID?: SortOrder
    name?: SortOrder
    id?: SortOrder
    pOrCs?: POrCOrderByRelationAggregateInput
    addresses?: AddressOrderByRelationAggregateInput
  }

  export type RegionWhereUniqueInput = Prisma.AtLeast<{
    regionID?: number
    name?: string
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    id?: IntFilter<"Region"> | number
    pOrCs?: POrCListRelationFilter
    addresses?: AddressListRelationFilter
  }, "regionID" | "name">

  export type RegionOrderByWithAggregationInput = {
    regionID?: SortOrder
    name?: SortOrder
    id?: SortOrder
    _count?: RegionCountOrderByAggregateInput
    _avg?: RegionAvgOrderByAggregateInput
    _max?: RegionMaxOrderByAggregateInput
    _min?: RegionMinOrderByAggregateInput
    _sum?: RegionSumOrderByAggregateInput
  }

  export type RegionScalarWhereWithAggregatesInput = {
    AND?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    OR?: RegionScalarWhereWithAggregatesInput[]
    NOT?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    regionID?: IntWithAggregatesFilter<"Region"> | number
    name?: StringWithAggregatesFilter<"Region"> | string
    id?: IntWithAggregatesFilter<"Region"> | number
  }

  export type POrCWhereInput = {
    AND?: POrCWhereInput | POrCWhereInput[]
    OR?: POrCWhereInput[]
    NOT?: POrCWhereInput | POrCWhereInput[]
    pOrCID?: IntFilter<"POrC"> | number
    name?: StringFilter<"POrC"> | string
    id?: IntFilter<"POrC"> | number
    regionID?: IntFilter<"POrC"> | number
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
    cOrMs?: COrMListRelationFilter
    addresses?: AddressListRelationFilter
  }

  export type POrCOrderByWithRelationInput = {
    pOrCID?: SortOrder
    name?: SortOrder
    id?: SortOrder
    regionID?: SortOrder
    region?: RegionOrderByWithRelationInput
    cOrMs?: COrMOrderByRelationAggregateInput
    addresses?: AddressOrderByRelationAggregateInput
  }

  export type POrCWhereUniqueInput = Prisma.AtLeast<{
    pOrCID?: number
    name?: string
    AND?: POrCWhereInput | POrCWhereInput[]
    OR?: POrCWhereInput[]
    NOT?: POrCWhereInput | POrCWhereInput[]
    id?: IntFilter<"POrC"> | number
    regionID?: IntFilter<"POrC"> | number
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
    cOrMs?: COrMListRelationFilter
    addresses?: AddressListRelationFilter
  }, "pOrCID" | "name">

  export type POrCOrderByWithAggregationInput = {
    pOrCID?: SortOrder
    name?: SortOrder
    id?: SortOrder
    regionID?: SortOrder
    _count?: POrCCountOrderByAggregateInput
    _avg?: POrCAvgOrderByAggregateInput
    _max?: POrCMaxOrderByAggregateInput
    _min?: POrCMinOrderByAggregateInput
    _sum?: POrCSumOrderByAggregateInput
  }

  export type POrCScalarWhereWithAggregatesInput = {
    AND?: POrCScalarWhereWithAggregatesInput | POrCScalarWhereWithAggregatesInput[]
    OR?: POrCScalarWhereWithAggregatesInput[]
    NOT?: POrCScalarWhereWithAggregatesInput | POrCScalarWhereWithAggregatesInput[]
    pOrCID?: IntWithAggregatesFilter<"POrC"> | number
    name?: StringWithAggregatesFilter<"POrC"> | string
    id?: IntWithAggregatesFilter<"POrC"> | number
    regionID?: IntWithAggregatesFilter<"POrC"> | number
  }

  export type COrMWhereInput = {
    AND?: COrMWhereInput | COrMWhereInput[]
    OR?: COrMWhereInput[]
    NOT?: COrMWhereInput | COrMWhereInput[]
    cOrMID?: IntFilter<"COrM"> | number
    name?: StringFilter<"COrM"> | string
    id?: IntFilter<"COrM"> | number
    pOrCID?: IntFilter<"COrM"> | number
    pOrC?: XOR<POrCScalarRelationFilter, POrCWhereInput>
    brgys?: BrgyListRelationFilter
    addresses?: AddressListRelationFilter
  }

  export type COrMOrderByWithRelationInput = {
    cOrMID?: SortOrder
    name?: SortOrder
    id?: SortOrder
    pOrCID?: SortOrder
    pOrC?: POrCOrderByWithRelationInput
    brgys?: BrgyOrderByRelationAggregateInput
    addresses?: AddressOrderByRelationAggregateInput
  }

  export type COrMWhereUniqueInput = Prisma.AtLeast<{
    cOrMID?: number
    AND?: COrMWhereInput | COrMWhereInput[]
    OR?: COrMWhereInput[]
    NOT?: COrMWhereInput | COrMWhereInput[]
    name?: StringFilter<"COrM"> | string
    id?: IntFilter<"COrM"> | number
    pOrCID?: IntFilter<"COrM"> | number
    pOrC?: XOR<POrCScalarRelationFilter, POrCWhereInput>
    brgys?: BrgyListRelationFilter
    addresses?: AddressListRelationFilter
  }, "cOrMID">

  export type COrMOrderByWithAggregationInput = {
    cOrMID?: SortOrder
    name?: SortOrder
    id?: SortOrder
    pOrCID?: SortOrder
    _count?: COrMCountOrderByAggregateInput
    _avg?: COrMAvgOrderByAggregateInput
    _max?: COrMMaxOrderByAggregateInput
    _min?: COrMMinOrderByAggregateInput
    _sum?: COrMSumOrderByAggregateInput
  }

  export type COrMScalarWhereWithAggregatesInput = {
    AND?: COrMScalarWhereWithAggregatesInput | COrMScalarWhereWithAggregatesInput[]
    OR?: COrMScalarWhereWithAggregatesInput[]
    NOT?: COrMScalarWhereWithAggregatesInput | COrMScalarWhereWithAggregatesInput[]
    cOrMID?: IntWithAggregatesFilter<"COrM"> | number
    name?: StringWithAggregatesFilter<"COrM"> | string
    id?: IntWithAggregatesFilter<"COrM"> | number
    pOrCID?: IntWithAggregatesFilter<"COrM"> | number
  }

  export type BrgyWhereInput = {
    AND?: BrgyWhereInput | BrgyWhereInput[]
    OR?: BrgyWhereInput[]
    NOT?: BrgyWhereInput | BrgyWhereInput[]
    brgyID?: IntFilter<"Brgy"> | number
    name?: StringFilter<"Brgy"> | string
    id?: IntFilter<"Brgy"> | number
    cOrMID?: IntFilter<"Brgy"> | number
    cOrM?: XOR<COrMScalarRelationFilter, COrMWhereInput>
    addresses?: AddressListRelationFilter
  }

  export type BrgyOrderByWithRelationInput = {
    brgyID?: SortOrder
    name?: SortOrder
    id?: SortOrder
    cOrMID?: SortOrder
    cOrM?: COrMOrderByWithRelationInput
    addresses?: AddressOrderByRelationAggregateInput
  }

  export type BrgyWhereUniqueInput = Prisma.AtLeast<{
    brgyID?: number
    AND?: BrgyWhereInput | BrgyWhereInput[]
    OR?: BrgyWhereInput[]
    NOT?: BrgyWhereInput | BrgyWhereInput[]
    name?: StringFilter<"Brgy"> | string
    id?: IntFilter<"Brgy"> | number
    cOrMID?: IntFilter<"Brgy"> | number
    cOrM?: XOR<COrMScalarRelationFilter, COrMWhereInput>
    addresses?: AddressListRelationFilter
  }, "brgyID">

  export type BrgyOrderByWithAggregationInput = {
    brgyID?: SortOrder
    name?: SortOrder
    id?: SortOrder
    cOrMID?: SortOrder
    _count?: BrgyCountOrderByAggregateInput
    _avg?: BrgyAvgOrderByAggregateInput
    _max?: BrgyMaxOrderByAggregateInput
    _min?: BrgyMinOrderByAggregateInput
    _sum?: BrgySumOrderByAggregateInput
  }

  export type BrgyScalarWhereWithAggregatesInput = {
    AND?: BrgyScalarWhereWithAggregatesInput | BrgyScalarWhereWithAggregatesInput[]
    OR?: BrgyScalarWhereWithAggregatesInput[]
    NOT?: BrgyScalarWhereWithAggregatesInput | BrgyScalarWhereWithAggregatesInput[]
    brgyID?: IntWithAggregatesFilter<"Brgy"> | number
    name?: StringWithAggregatesFilter<"Brgy"> | string
    id?: IntWithAggregatesFilter<"Brgy"> | number
    cOrMID?: IntWithAggregatesFilter<"Brgy"> | number
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    regionID?: IntFilter<"Address"> | number
    pOrCID?: IntFilter<"Address"> | number
    cOrMID?: IntFilter<"Address"> | number
    brgyID?: IntFilter<"Address"> | number
    street?: StringFilter<"Address"> | string
    facilityID?: StringFilter<"Address"> | string
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
    pOrC?: XOR<POrCScalarRelationFilter, POrCWhereInput>
    cOrM?: XOR<COrMScalarRelationFilter, COrMWhereInput>
    brgy?: XOR<BrgyScalarRelationFilter, BrgyWhereInput>
    facility?: XOR<FacilityScalarRelationFilter, FacilityWhereInput>
  }

  export type AddressOrderByWithRelationInput = {
    regionID?: SortOrder
    pOrCID?: SortOrder
    cOrMID?: SortOrder
    brgyID?: SortOrder
    street?: SortOrder
    facilityID?: SortOrder
    region?: RegionOrderByWithRelationInput
    pOrC?: POrCOrderByWithRelationInput
    cOrM?: COrMOrderByWithRelationInput
    brgy?: BrgyOrderByWithRelationInput
    facility?: FacilityOrderByWithRelationInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    facilityID?: string
    regionID_pOrCID_cOrMID_brgyID_street?: AddressRegionIDPOrCIDCOrMIDBrgyIDStreetCompoundUniqueInput
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    regionID?: IntFilter<"Address"> | number
    pOrCID?: IntFilter<"Address"> | number
    cOrMID?: IntFilter<"Address"> | number
    brgyID?: IntFilter<"Address"> | number
    street?: StringFilter<"Address"> | string
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
    pOrC?: XOR<POrCScalarRelationFilter, POrCWhereInput>
    cOrM?: XOR<COrMScalarRelationFilter, COrMWhereInput>
    brgy?: XOR<BrgyScalarRelationFilter, BrgyWhereInput>
    facility?: XOR<FacilityScalarRelationFilter, FacilityWhereInput>
  }, "facilityID" | "regionID_pOrCID_cOrMID_brgyID_street">

  export type AddressOrderByWithAggregationInput = {
    regionID?: SortOrder
    pOrCID?: SortOrder
    cOrMID?: SortOrder
    brgyID?: SortOrder
    street?: SortOrder
    facilityID?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _avg?: AddressAvgOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
    _sum?: AddressSumOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    regionID?: IntWithAggregatesFilter<"Address"> | number
    pOrCID?: IntWithAggregatesFilter<"Address"> | number
    cOrMID?: IntWithAggregatesFilter<"Address"> | number
    brgyID?: IntWithAggregatesFilter<"Address"> | number
    street?: StringWithAggregatesFilter<"Address"> | string
    facilityID?: StringWithAggregatesFilter<"Address"> | string
  }

  export type FacilityWhereInput = {
    AND?: FacilityWhereInput | FacilityWhereInput[]
    OR?: FacilityWhereInput[]
    NOT?: FacilityWhereInput | FacilityWhereInput[]
    facilityID?: StringFilter<"Facility"> | string
    name?: StringFilter<"Facility"> | string
    photo?: StringFilter<"Facility"> | string
    openingTime?: DateTimeNullableFilter<"Facility"> | Date | string | null
    closingTime?: DateTimeNullableFilter<"Facility"> | Date | string | null
    facilityType?: EnumFacilityTypeFilter<"Facility"> | $Enums.FacilityType
    ownership?: EnumOwnershipFilter<"Facility"> | $Enums.Ownership
    bookingSystem?: StringNullableFilter<"Facility"> | string | null
    acceptedProviders?: EnumProviderNullableListFilter<"Facility">
    updatedAt?: DateTimeFilter<"Facility"> | Date | string
    address?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    contacts?: ContactListRelationFilter
    services?: ServiceListRelationFilter
    employees?: EmployeeListRelationFilter
    divisions?: DivisionListRelationFilter
    logs?: UpdateLogListRelationFilter
  }

  export type FacilityOrderByWithRelationInput = {
    facilityID?: SortOrder
    name?: SortOrder
    photo?: SortOrder
    openingTime?: SortOrderInput | SortOrder
    closingTime?: SortOrderInput | SortOrder
    facilityType?: SortOrder
    ownership?: SortOrder
    bookingSystem?: SortOrderInput | SortOrder
    acceptedProviders?: SortOrder
    updatedAt?: SortOrder
    address?: AddressOrderByWithRelationInput
    contacts?: ContactOrderByRelationAggregateInput
    services?: ServiceOrderByRelationAggregateInput
    employees?: EmployeeOrderByRelationAggregateInput
    divisions?: DivisionOrderByRelationAggregateInput
    logs?: UpdateLogOrderByRelationAggregateInput
  }

  export type FacilityWhereUniqueInput = Prisma.AtLeast<{
    facilityID?: string
    AND?: FacilityWhereInput | FacilityWhereInput[]
    OR?: FacilityWhereInput[]
    NOT?: FacilityWhereInput | FacilityWhereInput[]
    name?: StringFilter<"Facility"> | string
    photo?: StringFilter<"Facility"> | string
    openingTime?: DateTimeNullableFilter<"Facility"> | Date | string | null
    closingTime?: DateTimeNullableFilter<"Facility"> | Date | string | null
    facilityType?: EnumFacilityTypeFilter<"Facility"> | $Enums.FacilityType
    ownership?: EnumOwnershipFilter<"Facility"> | $Enums.Ownership
    bookingSystem?: StringNullableFilter<"Facility"> | string | null
    acceptedProviders?: EnumProviderNullableListFilter<"Facility">
    updatedAt?: DateTimeFilter<"Facility"> | Date | string
    address?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    contacts?: ContactListRelationFilter
    services?: ServiceListRelationFilter
    employees?: EmployeeListRelationFilter
    divisions?: DivisionListRelationFilter
    logs?: UpdateLogListRelationFilter
  }, "facilityID">

  export type FacilityOrderByWithAggregationInput = {
    facilityID?: SortOrder
    name?: SortOrder
    photo?: SortOrder
    openingTime?: SortOrderInput | SortOrder
    closingTime?: SortOrderInput | SortOrder
    facilityType?: SortOrder
    ownership?: SortOrder
    bookingSystem?: SortOrderInput | SortOrder
    acceptedProviders?: SortOrder
    updatedAt?: SortOrder
    _count?: FacilityCountOrderByAggregateInput
    _max?: FacilityMaxOrderByAggregateInput
    _min?: FacilityMinOrderByAggregateInput
  }

  export type FacilityScalarWhereWithAggregatesInput = {
    AND?: FacilityScalarWhereWithAggregatesInput | FacilityScalarWhereWithAggregatesInput[]
    OR?: FacilityScalarWhereWithAggregatesInput[]
    NOT?: FacilityScalarWhereWithAggregatesInput | FacilityScalarWhereWithAggregatesInput[]
    facilityID?: StringWithAggregatesFilter<"Facility"> | string
    name?: StringWithAggregatesFilter<"Facility"> | string
    photo?: StringWithAggregatesFilter<"Facility"> | string
    openingTime?: DateTimeNullableWithAggregatesFilter<"Facility"> | Date | string | null
    closingTime?: DateTimeNullableWithAggregatesFilter<"Facility"> | Date | string | null
    facilityType?: EnumFacilityTypeWithAggregatesFilter<"Facility"> | $Enums.FacilityType
    ownership?: EnumOwnershipWithAggregatesFilter<"Facility"> | $Enums.Ownership
    bookingSystem?: StringNullableWithAggregatesFilter<"Facility"> | string | null
    acceptedProviders?: EnumProviderNullableListFilter<"Facility">
    updatedAt?: DateTimeWithAggregatesFilter<"Facility"> | Date | string
  }

  export type DivisionWhereInput = {
    AND?: DivisionWhereInput | DivisionWhereInput[]
    OR?: DivisionWhereInput[]
    NOT?: DivisionWhereInput | DivisionWhereInput[]
    divisionID?: StringFilter<"Division"> | string
    name?: StringFilter<"Division"> | string
    openingTime?: DateTimeFilter<"Division"> | Date | string
    closingTime?: DateTimeFilter<"Division"> | Date | string
    createdAt?: DateTimeFilter<"Division"> | Date | string
    updatedAt?: DateTimeFilter<"Division"> | Date | string
    facilityID?: StringFilter<"Division"> | string
    contacts?: ContactListRelationFilter
    facility?: XOR<FacilityScalarRelationFilter, FacilityWhereInput>
    services?: ServiceListRelationFilter
    admins?: EmployeeListRelationFilter
    logs?: UpdateLogListRelationFilter
  }

  export type DivisionOrderByWithRelationInput = {
    divisionID?: SortOrder
    name?: SortOrder
    openingTime?: SortOrder
    closingTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facilityID?: SortOrder
    contacts?: ContactOrderByRelationAggregateInput
    facility?: FacilityOrderByWithRelationInput
    services?: ServiceOrderByRelationAggregateInput
    admins?: EmployeeOrderByRelationAggregateInput
    logs?: UpdateLogOrderByRelationAggregateInput
  }

  export type DivisionWhereUniqueInput = Prisma.AtLeast<{
    divisionID?: string
    AND?: DivisionWhereInput | DivisionWhereInput[]
    OR?: DivisionWhereInput[]
    NOT?: DivisionWhereInput | DivisionWhereInput[]
    name?: StringFilter<"Division"> | string
    openingTime?: DateTimeFilter<"Division"> | Date | string
    closingTime?: DateTimeFilter<"Division"> | Date | string
    createdAt?: DateTimeFilter<"Division"> | Date | string
    updatedAt?: DateTimeFilter<"Division"> | Date | string
    facilityID?: StringFilter<"Division"> | string
    contacts?: ContactListRelationFilter
    facility?: XOR<FacilityScalarRelationFilter, FacilityWhereInput>
    services?: ServiceListRelationFilter
    admins?: EmployeeListRelationFilter
    logs?: UpdateLogListRelationFilter
  }, "divisionID">

  export type DivisionOrderByWithAggregationInput = {
    divisionID?: SortOrder
    name?: SortOrder
    openingTime?: SortOrder
    closingTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facilityID?: SortOrder
    _count?: DivisionCountOrderByAggregateInput
    _max?: DivisionMaxOrderByAggregateInput
    _min?: DivisionMinOrderByAggregateInput
  }

  export type DivisionScalarWhereWithAggregatesInput = {
    AND?: DivisionScalarWhereWithAggregatesInput | DivisionScalarWhereWithAggregatesInput[]
    OR?: DivisionScalarWhereWithAggregatesInput[]
    NOT?: DivisionScalarWhereWithAggregatesInput | DivisionScalarWhereWithAggregatesInput[]
    divisionID?: StringWithAggregatesFilter<"Division"> | string
    name?: StringWithAggregatesFilter<"Division"> | string
    openingTime?: DateTimeWithAggregatesFilter<"Division"> | Date | string
    closingTime?: DateTimeWithAggregatesFilter<"Division"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Division"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Division"> | Date | string
    facilityID?: StringWithAggregatesFilter<"Division"> | string
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    employeeID?: StringFilter<"Employee"> | string
    password?: StringFilter<"Employee"> | string
    role?: EnumRoleFilter<"Employee"> | $Enums.Role
    fname?: StringFilter<"Employee"> | string
    mname?: StringNullableFilter<"Employee"> | string | null
    lname?: StringFilter<"Employee"> | string
    photo?: StringFilter<"Employee"> | string
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    facilityID?: StringFilter<"Employee"> | string
    sessions?: SessionListRelationFilter
    facility?: XOR<FacilityScalarRelationFilter, FacilityWhereInput>
    divisions?: DivisionListRelationFilter
    updateLog?: UpdateLogListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    employeeID?: SortOrder
    password?: SortOrder
    role?: SortOrder
    fname?: SortOrder
    mname?: SortOrderInput | SortOrder
    lname?: SortOrder
    photo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facilityID?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    facility?: FacilityOrderByWithRelationInput
    divisions?: DivisionOrderByRelationAggregateInput
    updateLog?: UpdateLogOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    employeeID?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    password?: StringFilter<"Employee"> | string
    role?: EnumRoleFilter<"Employee"> | $Enums.Role
    fname?: StringFilter<"Employee"> | string
    mname?: StringNullableFilter<"Employee"> | string | null
    lname?: StringFilter<"Employee"> | string
    photo?: StringFilter<"Employee"> | string
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    facilityID?: StringFilter<"Employee"> | string
    sessions?: SessionListRelationFilter
    facility?: XOR<FacilityScalarRelationFilter, FacilityWhereInput>
    divisions?: DivisionListRelationFilter
    updateLog?: UpdateLogListRelationFilter
  }, "employeeID">

  export type EmployeeOrderByWithAggregationInput = {
    employeeID?: SortOrder
    password?: SortOrder
    role?: SortOrder
    fname?: SortOrder
    mname?: SortOrderInput | SortOrder
    lname?: SortOrder
    photo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facilityID?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    employeeID?: StringWithAggregatesFilter<"Employee"> | string
    password?: StringWithAggregatesFilter<"Employee"> | string
    role?: EnumRoleWithAggregatesFilter<"Employee"> | $Enums.Role
    fname?: StringWithAggregatesFilter<"Employee"> | string
    mname?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    lname?: StringWithAggregatesFilter<"Employee"> | string
    photo?: StringWithAggregatesFilter<"Employee"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    facilityID?: StringWithAggregatesFilter<"Employee"> | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    sessionID?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    employeeID?: StringFilter<"Session"> | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    sessionID?: SortOrder
    expiresAt?: SortOrder
    employeeID?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    sessionID?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    employeeID?: StringFilter<"Session"> | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "sessionID">

  export type SessionOrderByWithAggregationInput = {
    sessionID?: SortOrder
    expiresAt?: SortOrder
    employeeID?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    sessionID?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    employeeID?: StringWithAggregatesFilter<"Session"> | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    serviceID?: StringFilter<"Service"> | string
    type?: StringFilter<"Service"> | string
    keywords?: StringNullableListFilter<"Service">
    note?: StringNullableFilter<"Service"> | string | null
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    facilityID?: StringFilter<"Service"> | string
    divisionID?: StringNullableFilter<"Service"> | string | null
    phoneNumbers?: ContactListRelationFilter
    facility?: XOR<FacilityScalarRelationFilter, FacilityWhereInput>
    division?: XOR<DivisionNullableScalarRelationFilter, DivisionWhereInput> | null
    ambulanceService?: XOR<AmbulanceServiceNullableScalarRelationFilter, AmbulanceServiceWhereInput> | null
    bloodBankService?: XOR<BloodBankServiceNullableScalarRelationFilter, BloodBankServiceWhereInput> | null
    erService?: XOR<ERServiceNullableScalarRelationFilter, ERServiceWhereInput> | null
    icuService?: XOR<ICUServiceNullableScalarRelationFilter, ICUServiceWhereInput> | null
    outpatientService?: XOR<OutpatientServiceNullableScalarRelationFilter, OutpatientServiceWhereInput> | null
  }

  export type ServiceOrderByWithRelationInput = {
    serviceID?: SortOrder
    type?: SortOrder
    keywords?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facilityID?: SortOrder
    divisionID?: SortOrderInput | SortOrder
    phoneNumbers?: ContactOrderByRelationAggregateInput
    facility?: FacilityOrderByWithRelationInput
    division?: DivisionOrderByWithRelationInput
    ambulanceService?: AmbulanceServiceOrderByWithRelationInput
    bloodBankService?: BloodBankServiceOrderByWithRelationInput
    erService?: ERServiceOrderByWithRelationInput
    icuService?: ICUServiceOrderByWithRelationInput
    outpatientService?: OutpatientServiceOrderByWithRelationInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    serviceID?: string
    facilityID_type?: ServiceFacilityIDTypeCompoundUniqueInput
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    type?: StringFilter<"Service"> | string
    keywords?: StringNullableListFilter<"Service">
    note?: StringNullableFilter<"Service"> | string | null
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    facilityID?: StringFilter<"Service"> | string
    divisionID?: StringNullableFilter<"Service"> | string | null
    phoneNumbers?: ContactListRelationFilter
    facility?: XOR<FacilityScalarRelationFilter, FacilityWhereInput>
    division?: XOR<DivisionNullableScalarRelationFilter, DivisionWhereInput> | null
    ambulanceService?: XOR<AmbulanceServiceNullableScalarRelationFilter, AmbulanceServiceWhereInput> | null
    bloodBankService?: XOR<BloodBankServiceNullableScalarRelationFilter, BloodBankServiceWhereInput> | null
    erService?: XOR<ERServiceNullableScalarRelationFilter, ERServiceWhereInput> | null
    icuService?: XOR<ICUServiceNullableScalarRelationFilter, ICUServiceWhereInput> | null
    outpatientService?: XOR<OutpatientServiceNullableScalarRelationFilter, OutpatientServiceWhereInput> | null
  }, "serviceID" | "facilityID_type">

  export type ServiceOrderByWithAggregationInput = {
    serviceID?: SortOrder
    type?: SortOrder
    keywords?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facilityID?: SortOrder
    divisionID?: SortOrderInput | SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    serviceID?: StringWithAggregatesFilter<"Service"> | string
    type?: StringWithAggregatesFilter<"Service"> | string
    keywords?: StringNullableListFilter<"Service">
    note?: StringNullableWithAggregatesFilter<"Service"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    facilityID?: StringWithAggregatesFilter<"Service"> | string
    divisionID?: StringNullableWithAggregatesFilter<"Service"> | string | null
  }

  export type AmbulanceServiceWhereInput = {
    AND?: AmbulanceServiceWhereInput | AmbulanceServiceWhereInput[]
    OR?: AmbulanceServiceWhereInput[]
    NOT?: AmbulanceServiceWhereInput | AmbulanceServiceWhereInput[]
    openingTime?: DateTimeNullableFilter<"AmbulanceService"> | Date | string | null
    closingTime?: DateTimeNullableFilter<"AmbulanceService"> | Date | string | null
    availability?: EnumAvailabilityFilter<"AmbulanceService"> | $Enums.Availability
    baseRate?: FloatFilter<"AmbulanceService"> | number
    minCoverageRadius?: FloatFilter<"AmbulanceService"> | number
    mileageRate?: FloatFilter<"AmbulanceService"> | number
    maxCoverageRadius?: FloatFilter<"AmbulanceService"> | number
    serviceID?: StringFilter<"AmbulanceService"> | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type AmbulanceServiceOrderByWithRelationInput = {
    openingTime?: SortOrderInput | SortOrder
    closingTime?: SortOrderInput | SortOrder
    availability?: SortOrder
    baseRate?: SortOrder
    minCoverageRadius?: SortOrder
    mileageRate?: SortOrder
    maxCoverageRadius?: SortOrder
    serviceID?: SortOrder
    service?: ServiceOrderByWithRelationInput
  }

  export type AmbulanceServiceWhereUniqueInput = Prisma.AtLeast<{
    serviceID?: string
    AND?: AmbulanceServiceWhereInput | AmbulanceServiceWhereInput[]
    OR?: AmbulanceServiceWhereInput[]
    NOT?: AmbulanceServiceWhereInput | AmbulanceServiceWhereInput[]
    openingTime?: DateTimeNullableFilter<"AmbulanceService"> | Date | string | null
    closingTime?: DateTimeNullableFilter<"AmbulanceService"> | Date | string | null
    availability?: EnumAvailabilityFilter<"AmbulanceService"> | $Enums.Availability
    baseRate?: FloatFilter<"AmbulanceService"> | number
    minCoverageRadius?: FloatFilter<"AmbulanceService"> | number
    mileageRate?: FloatFilter<"AmbulanceService"> | number
    maxCoverageRadius?: FloatFilter<"AmbulanceService"> | number
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "serviceID">

  export type AmbulanceServiceOrderByWithAggregationInput = {
    openingTime?: SortOrderInput | SortOrder
    closingTime?: SortOrderInput | SortOrder
    availability?: SortOrder
    baseRate?: SortOrder
    minCoverageRadius?: SortOrder
    mileageRate?: SortOrder
    maxCoverageRadius?: SortOrder
    serviceID?: SortOrder
    _count?: AmbulanceServiceCountOrderByAggregateInput
    _avg?: AmbulanceServiceAvgOrderByAggregateInput
    _max?: AmbulanceServiceMaxOrderByAggregateInput
    _min?: AmbulanceServiceMinOrderByAggregateInput
    _sum?: AmbulanceServiceSumOrderByAggregateInput
  }

  export type AmbulanceServiceScalarWhereWithAggregatesInput = {
    AND?: AmbulanceServiceScalarWhereWithAggregatesInput | AmbulanceServiceScalarWhereWithAggregatesInput[]
    OR?: AmbulanceServiceScalarWhereWithAggregatesInput[]
    NOT?: AmbulanceServiceScalarWhereWithAggregatesInput | AmbulanceServiceScalarWhereWithAggregatesInput[]
    openingTime?: DateTimeNullableWithAggregatesFilter<"AmbulanceService"> | Date | string | null
    closingTime?: DateTimeNullableWithAggregatesFilter<"AmbulanceService"> | Date | string | null
    availability?: EnumAvailabilityWithAggregatesFilter<"AmbulanceService"> | $Enums.Availability
    baseRate?: FloatWithAggregatesFilter<"AmbulanceService"> | number
    minCoverageRadius?: FloatWithAggregatesFilter<"AmbulanceService"> | number
    mileageRate?: FloatWithAggregatesFilter<"AmbulanceService"> | number
    maxCoverageRadius?: FloatWithAggregatesFilter<"AmbulanceService"> | number
    serviceID?: StringWithAggregatesFilter<"AmbulanceService"> | string
  }

  export type BloodTypeMappingWhereInput = {
    AND?: BloodTypeMappingWhereInput | BloodTypeMappingWhereInput[]
    OR?: BloodTypeMappingWhereInput[]
    NOT?: BloodTypeMappingWhereInput | BloodTypeMappingWhereInput[]
    A_P?: BoolFilter<"BloodTypeMapping"> | boolean
    A_N?: BoolFilter<"BloodTypeMapping"> | boolean
    B_P?: BoolFilter<"BloodTypeMapping"> | boolean
    B_N?: BoolFilter<"BloodTypeMapping"> | boolean
    O_P?: BoolFilter<"BloodTypeMapping"> | boolean
    O_N?: BoolFilter<"BloodTypeMapping"> | boolean
    AB_P?: BoolFilter<"BloodTypeMapping"> | boolean
    AB_N?: BoolFilter<"BloodTypeMapping"> | boolean
    serviceID?: StringFilter<"BloodTypeMapping"> | string
    BloodBankService?: XOR<BloodBankServiceScalarRelationFilter, BloodBankServiceWhereInput>
  }

  export type BloodTypeMappingOrderByWithRelationInput = {
    A_P?: SortOrder
    A_N?: SortOrder
    B_P?: SortOrder
    B_N?: SortOrder
    O_P?: SortOrder
    O_N?: SortOrder
    AB_P?: SortOrder
    AB_N?: SortOrder
    serviceID?: SortOrder
    BloodBankService?: BloodBankServiceOrderByWithRelationInput
  }

  export type BloodTypeMappingWhereUniqueInput = Prisma.AtLeast<{
    serviceID?: string
    AND?: BloodTypeMappingWhereInput | BloodTypeMappingWhereInput[]
    OR?: BloodTypeMappingWhereInput[]
    NOT?: BloodTypeMappingWhereInput | BloodTypeMappingWhereInput[]
    A_P?: BoolFilter<"BloodTypeMapping"> | boolean
    A_N?: BoolFilter<"BloodTypeMapping"> | boolean
    B_P?: BoolFilter<"BloodTypeMapping"> | boolean
    B_N?: BoolFilter<"BloodTypeMapping"> | boolean
    O_P?: BoolFilter<"BloodTypeMapping"> | boolean
    O_N?: BoolFilter<"BloodTypeMapping"> | boolean
    AB_P?: BoolFilter<"BloodTypeMapping"> | boolean
    AB_N?: BoolFilter<"BloodTypeMapping"> | boolean
    BloodBankService?: XOR<BloodBankServiceScalarRelationFilter, BloodBankServiceWhereInput>
  }, "serviceID">

  export type BloodTypeMappingOrderByWithAggregationInput = {
    A_P?: SortOrder
    A_N?: SortOrder
    B_P?: SortOrder
    B_N?: SortOrder
    O_P?: SortOrder
    O_N?: SortOrder
    AB_P?: SortOrder
    AB_N?: SortOrder
    serviceID?: SortOrder
    _count?: BloodTypeMappingCountOrderByAggregateInput
    _max?: BloodTypeMappingMaxOrderByAggregateInput
    _min?: BloodTypeMappingMinOrderByAggregateInput
  }

  export type BloodTypeMappingScalarWhereWithAggregatesInput = {
    AND?: BloodTypeMappingScalarWhereWithAggregatesInput | BloodTypeMappingScalarWhereWithAggregatesInput[]
    OR?: BloodTypeMappingScalarWhereWithAggregatesInput[]
    NOT?: BloodTypeMappingScalarWhereWithAggregatesInput | BloodTypeMappingScalarWhereWithAggregatesInput[]
    A_P?: BoolWithAggregatesFilter<"BloodTypeMapping"> | boolean
    A_N?: BoolWithAggregatesFilter<"BloodTypeMapping"> | boolean
    B_P?: BoolWithAggregatesFilter<"BloodTypeMapping"> | boolean
    B_N?: BoolWithAggregatesFilter<"BloodTypeMapping"> | boolean
    O_P?: BoolWithAggregatesFilter<"BloodTypeMapping"> | boolean
    O_N?: BoolWithAggregatesFilter<"BloodTypeMapping"> | boolean
    AB_P?: BoolWithAggregatesFilter<"BloodTypeMapping"> | boolean
    AB_N?: BoolWithAggregatesFilter<"BloodTypeMapping"> | boolean
    serviceID?: StringWithAggregatesFilter<"BloodTypeMapping"> | string
  }

  export type BloodBankServiceWhereInput = {
    AND?: BloodBankServiceWhereInput | BloodBankServiceWhereInput[]
    OR?: BloodBankServiceWhereInput[]
    NOT?: BloodBankServiceWhereInput | BloodBankServiceWhereInput[]
    openingTime?: DateTimeNullableFilter<"BloodBankService"> | Date | string | null
    closingTime?: DateTimeNullableFilter<"BloodBankService"> | Date | string | null
    basePricePerUnit?: FloatFilter<"BloodBankService"> | number
    turnaroundTimeD?: IntFilter<"BloodBankService"> | number
    turnaroundTimeH?: IntFilter<"BloodBankService"> | number
    serviceID?: StringFilter<"BloodBankService"> | string
    bloodTypeAvailability?: XOR<BloodTypeMappingNullableScalarRelationFilter, BloodTypeMappingWhereInput> | null
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type BloodBankServiceOrderByWithRelationInput = {
    openingTime?: SortOrderInput | SortOrder
    closingTime?: SortOrderInput | SortOrder
    basePricePerUnit?: SortOrder
    turnaroundTimeD?: SortOrder
    turnaroundTimeH?: SortOrder
    serviceID?: SortOrder
    bloodTypeAvailability?: BloodTypeMappingOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type BloodBankServiceWhereUniqueInput = Prisma.AtLeast<{
    serviceID?: string
    AND?: BloodBankServiceWhereInput | BloodBankServiceWhereInput[]
    OR?: BloodBankServiceWhereInput[]
    NOT?: BloodBankServiceWhereInput | BloodBankServiceWhereInput[]
    openingTime?: DateTimeNullableFilter<"BloodBankService"> | Date | string | null
    closingTime?: DateTimeNullableFilter<"BloodBankService"> | Date | string | null
    basePricePerUnit?: FloatFilter<"BloodBankService"> | number
    turnaroundTimeD?: IntFilter<"BloodBankService"> | number
    turnaroundTimeH?: IntFilter<"BloodBankService"> | number
    bloodTypeAvailability?: XOR<BloodTypeMappingNullableScalarRelationFilter, BloodTypeMappingWhereInput> | null
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "serviceID">

  export type BloodBankServiceOrderByWithAggregationInput = {
    openingTime?: SortOrderInput | SortOrder
    closingTime?: SortOrderInput | SortOrder
    basePricePerUnit?: SortOrder
    turnaroundTimeD?: SortOrder
    turnaroundTimeH?: SortOrder
    serviceID?: SortOrder
    _count?: BloodBankServiceCountOrderByAggregateInput
    _avg?: BloodBankServiceAvgOrderByAggregateInput
    _max?: BloodBankServiceMaxOrderByAggregateInput
    _min?: BloodBankServiceMinOrderByAggregateInput
    _sum?: BloodBankServiceSumOrderByAggregateInput
  }

  export type BloodBankServiceScalarWhereWithAggregatesInput = {
    AND?: BloodBankServiceScalarWhereWithAggregatesInput | BloodBankServiceScalarWhereWithAggregatesInput[]
    OR?: BloodBankServiceScalarWhereWithAggregatesInput[]
    NOT?: BloodBankServiceScalarWhereWithAggregatesInput | BloodBankServiceScalarWhereWithAggregatesInput[]
    openingTime?: DateTimeNullableWithAggregatesFilter<"BloodBankService"> | Date | string | null
    closingTime?: DateTimeNullableWithAggregatesFilter<"BloodBankService"> | Date | string | null
    basePricePerUnit?: FloatWithAggregatesFilter<"BloodBankService"> | number
    turnaroundTimeD?: IntWithAggregatesFilter<"BloodBankService"> | number
    turnaroundTimeH?: IntWithAggregatesFilter<"BloodBankService"> | number
    serviceID?: StringWithAggregatesFilter<"BloodBankService"> | string
  }

  export type ERServiceWhereInput = {
    AND?: ERServiceWhereInput | ERServiceWhereInput[]
    OR?: ERServiceWhereInput[]
    NOT?: ERServiceWhereInput | ERServiceWhereInput[]
    openingTime?: DateTimeNullableFilter<"ERService"> | Date | string | null
    closingTime?: DateTimeNullableFilter<"ERService"> | Date | string | null
    load?: EnumLoadFilter<"ERService"> | $Enums.Load
    availableBeds?: IntFilter<"ERService"> | number
    nonUrgentPatients?: IntFilter<"ERService"> | number
    nonUrgentQueueLength?: IntFilter<"ERService"> | number
    urgentPatients?: IntFilter<"ERService"> | number
    urgentQueueLength?: IntFilter<"ERService"> | number
    criticalPatients?: IntFilter<"ERService"> | number
    criticalQueueLength?: IntFilter<"ERService"> | number
    serviceID?: StringFilter<"ERService"> | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type ERServiceOrderByWithRelationInput = {
    openingTime?: SortOrderInput | SortOrder
    closingTime?: SortOrderInput | SortOrder
    load?: SortOrder
    availableBeds?: SortOrder
    nonUrgentPatients?: SortOrder
    nonUrgentQueueLength?: SortOrder
    urgentPatients?: SortOrder
    urgentQueueLength?: SortOrder
    criticalPatients?: SortOrder
    criticalQueueLength?: SortOrder
    serviceID?: SortOrder
    service?: ServiceOrderByWithRelationInput
  }

  export type ERServiceWhereUniqueInput = Prisma.AtLeast<{
    serviceID?: string
    AND?: ERServiceWhereInput | ERServiceWhereInput[]
    OR?: ERServiceWhereInput[]
    NOT?: ERServiceWhereInput | ERServiceWhereInput[]
    openingTime?: DateTimeNullableFilter<"ERService"> | Date | string | null
    closingTime?: DateTimeNullableFilter<"ERService"> | Date | string | null
    load?: EnumLoadFilter<"ERService"> | $Enums.Load
    availableBeds?: IntFilter<"ERService"> | number
    nonUrgentPatients?: IntFilter<"ERService"> | number
    nonUrgentQueueLength?: IntFilter<"ERService"> | number
    urgentPatients?: IntFilter<"ERService"> | number
    urgentQueueLength?: IntFilter<"ERService"> | number
    criticalPatients?: IntFilter<"ERService"> | number
    criticalQueueLength?: IntFilter<"ERService"> | number
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "serviceID">

  export type ERServiceOrderByWithAggregationInput = {
    openingTime?: SortOrderInput | SortOrder
    closingTime?: SortOrderInput | SortOrder
    load?: SortOrder
    availableBeds?: SortOrder
    nonUrgentPatients?: SortOrder
    nonUrgentQueueLength?: SortOrder
    urgentPatients?: SortOrder
    urgentQueueLength?: SortOrder
    criticalPatients?: SortOrder
    criticalQueueLength?: SortOrder
    serviceID?: SortOrder
    _count?: ERServiceCountOrderByAggregateInput
    _avg?: ERServiceAvgOrderByAggregateInput
    _max?: ERServiceMaxOrderByAggregateInput
    _min?: ERServiceMinOrderByAggregateInput
    _sum?: ERServiceSumOrderByAggregateInput
  }

  export type ERServiceScalarWhereWithAggregatesInput = {
    AND?: ERServiceScalarWhereWithAggregatesInput | ERServiceScalarWhereWithAggregatesInput[]
    OR?: ERServiceScalarWhereWithAggregatesInput[]
    NOT?: ERServiceScalarWhereWithAggregatesInput | ERServiceScalarWhereWithAggregatesInput[]
    openingTime?: DateTimeNullableWithAggregatesFilter<"ERService"> | Date | string | null
    closingTime?: DateTimeNullableWithAggregatesFilter<"ERService"> | Date | string | null
    load?: EnumLoadWithAggregatesFilter<"ERService"> | $Enums.Load
    availableBeds?: IntWithAggregatesFilter<"ERService"> | number
    nonUrgentPatients?: IntWithAggregatesFilter<"ERService"> | number
    nonUrgentQueueLength?: IntWithAggregatesFilter<"ERService"> | number
    urgentPatients?: IntWithAggregatesFilter<"ERService"> | number
    urgentQueueLength?: IntWithAggregatesFilter<"ERService"> | number
    criticalPatients?: IntWithAggregatesFilter<"ERService"> | number
    criticalQueueLength?: IntWithAggregatesFilter<"ERService"> | number
    serviceID?: StringWithAggregatesFilter<"ERService"> | string
  }

  export type ICUServiceWhereInput = {
    AND?: ICUServiceWhereInput | ICUServiceWhereInput[]
    OR?: ICUServiceWhereInput[]
    NOT?: ICUServiceWhereInput | ICUServiceWhereInput[]
    openingTime?: DateTimeNullableFilter<"ICUService"> | Date | string | null
    closingTime?: DateTimeNullableFilter<"ICUService"> | Date | string | null
    load?: EnumLoadFilter<"ICUService"> | $Enums.Load
    baseRate?: FloatFilter<"ICUService"> | number
    availableBeds?: IntFilter<"ICUService"> | number
    cardiacSupport?: BoolFilter<"ICUService"> | boolean
    neurologicalSupport?: BoolFilter<"ICUService"> | boolean
    renalSupport?: BoolFilter<"ICUService"> | boolean
    respiratorySupport?: BoolFilter<"ICUService"> | boolean
    serviceID?: StringFilter<"ICUService"> | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type ICUServiceOrderByWithRelationInput = {
    openingTime?: SortOrderInput | SortOrder
    closingTime?: SortOrderInput | SortOrder
    load?: SortOrder
    baseRate?: SortOrder
    availableBeds?: SortOrder
    cardiacSupport?: SortOrder
    neurologicalSupport?: SortOrder
    renalSupport?: SortOrder
    respiratorySupport?: SortOrder
    serviceID?: SortOrder
    service?: ServiceOrderByWithRelationInput
  }

  export type ICUServiceWhereUniqueInput = Prisma.AtLeast<{
    serviceID?: string
    AND?: ICUServiceWhereInput | ICUServiceWhereInput[]
    OR?: ICUServiceWhereInput[]
    NOT?: ICUServiceWhereInput | ICUServiceWhereInput[]
    openingTime?: DateTimeNullableFilter<"ICUService"> | Date | string | null
    closingTime?: DateTimeNullableFilter<"ICUService"> | Date | string | null
    load?: EnumLoadFilter<"ICUService"> | $Enums.Load
    baseRate?: FloatFilter<"ICUService"> | number
    availableBeds?: IntFilter<"ICUService"> | number
    cardiacSupport?: BoolFilter<"ICUService"> | boolean
    neurologicalSupport?: BoolFilter<"ICUService"> | boolean
    renalSupport?: BoolFilter<"ICUService"> | boolean
    respiratorySupport?: BoolFilter<"ICUService"> | boolean
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "serviceID">

  export type ICUServiceOrderByWithAggregationInput = {
    openingTime?: SortOrderInput | SortOrder
    closingTime?: SortOrderInput | SortOrder
    load?: SortOrder
    baseRate?: SortOrder
    availableBeds?: SortOrder
    cardiacSupport?: SortOrder
    neurologicalSupport?: SortOrder
    renalSupport?: SortOrder
    respiratorySupport?: SortOrder
    serviceID?: SortOrder
    _count?: ICUServiceCountOrderByAggregateInput
    _avg?: ICUServiceAvgOrderByAggregateInput
    _max?: ICUServiceMaxOrderByAggregateInput
    _min?: ICUServiceMinOrderByAggregateInput
    _sum?: ICUServiceSumOrderByAggregateInput
  }

  export type ICUServiceScalarWhereWithAggregatesInput = {
    AND?: ICUServiceScalarWhereWithAggregatesInput | ICUServiceScalarWhereWithAggregatesInput[]
    OR?: ICUServiceScalarWhereWithAggregatesInput[]
    NOT?: ICUServiceScalarWhereWithAggregatesInput | ICUServiceScalarWhereWithAggregatesInput[]
    openingTime?: DateTimeNullableWithAggregatesFilter<"ICUService"> | Date | string | null
    closingTime?: DateTimeNullableWithAggregatesFilter<"ICUService"> | Date | string | null
    load?: EnumLoadWithAggregatesFilter<"ICUService"> | $Enums.Load
    baseRate?: FloatWithAggregatesFilter<"ICUService"> | number
    availableBeds?: IntWithAggregatesFilter<"ICUService"> | number
    cardiacSupport?: BoolWithAggregatesFilter<"ICUService"> | boolean
    neurologicalSupport?: BoolWithAggregatesFilter<"ICUService"> | boolean
    renalSupport?: BoolWithAggregatesFilter<"ICUService"> | boolean
    respiratorySupport?: BoolWithAggregatesFilter<"ICUService"> | boolean
    serviceID?: StringWithAggregatesFilter<"ICUService"> | string
  }

  export type OutpatientServiceWhereInput = {
    AND?: OutpatientServiceWhereInput | OutpatientServiceWhereInput[]
    OR?: OutpatientServiceWhereInput[]
    NOT?: OutpatientServiceWhereInput | OutpatientServiceWhereInput[]
    basePrice?: FloatFilter<"OutpatientService"> | number
    completionTimeD?: IntFilter<"OutpatientService"> | number
    completionTimeH?: IntFilter<"OutpatientService"> | number
    isAvailable?: BoolFilter<"OutpatientService"> | boolean
    acceptsWalkIns?: BoolFilter<"OutpatientService"> | boolean
    serviceID?: StringFilter<"OutpatientService"> | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type OutpatientServiceOrderByWithRelationInput = {
    basePrice?: SortOrder
    completionTimeD?: SortOrder
    completionTimeH?: SortOrder
    isAvailable?: SortOrder
    acceptsWalkIns?: SortOrder
    serviceID?: SortOrder
    service?: ServiceOrderByWithRelationInput
  }

  export type OutpatientServiceWhereUniqueInput = Prisma.AtLeast<{
    serviceID?: string
    AND?: OutpatientServiceWhereInput | OutpatientServiceWhereInput[]
    OR?: OutpatientServiceWhereInput[]
    NOT?: OutpatientServiceWhereInput | OutpatientServiceWhereInput[]
    basePrice?: FloatFilter<"OutpatientService"> | number
    completionTimeD?: IntFilter<"OutpatientService"> | number
    completionTimeH?: IntFilter<"OutpatientService"> | number
    isAvailable?: BoolFilter<"OutpatientService"> | boolean
    acceptsWalkIns?: BoolFilter<"OutpatientService"> | boolean
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "serviceID">

  export type OutpatientServiceOrderByWithAggregationInput = {
    basePrice?: SortOrder
    completionTimeD?: SortOrder
    completionTimeH?: SortOrder
    isAvailable?: SortOrder
    acceptsWalkIns?: SortOrder
    serviceID?: SortOrder
    _count?: OutpatientServiceCountOrderByAggregateInput
    _avg?: OutpatientServiceAvgOrderByAggregateInput
    _max?: OutpatientServiceMaxOrderByAggregateInput
    _min?: OutpatientServiceMinOrderByAggregateInput
    _sum?: OutpatientServiceSumOrderByAggregateInput
  }

  export type OutpatientServiceScalarWhereWithAggregatesInput = {
    AND?: OutpatientServiceScalarWhereWithAggregatesInput | OutpatientServiceScalarWhereWithAggregatesInput[]
    OR?: OutpatientServiceScalarWhereWithAggregatesInput[]
    NOT?: OutpatientServiceScalarWhereWithAggregatesInput | OutpatientServiceScalarWhereWithAggregatesInput[]
    basePrice?: FloatWithAggregatesFilter<"OutpatientService"> | number
    completionTimeD?: IntWithAggregatesFilter<"OutpatientService"> | number
    completionTimeH?: IntWithAggregatesFilter<"OutpatientService"> | number
    isAvailable?: BoolWithAggregatesFilter<"OutpatientService"> | boolean
    acceptsWalkIns?: BoolWithAggregatesFilter<"OutpatientService"> | boolean
    serviceID?: StringWithAggregatesFilter<"OutpatientService"> | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    contactID?: StringFilter<"Contact"> | string
    info?: StringFilter<"Contact"> | string
    type?: EnumContactTypeFilter<"Contact"> | $Enums.ContactType
    facilityID?: StringNullableFilter<"Contact"> | string | null
    divisionID?: StringNullableFilter<"Contact"> | string | null
    serviceID?: StringNullableFilter<"Contact"> | string | null
    facility?: XOR<FacilityNullableScalarRelationFilter, FacilityWhereInput> | null
    division?: XOR<DivisionNullableScalarRelationFilter, DivisionWhereInput> | null
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
  }

  export type ContactOrderByWithRelationInput = {
    contactID?: SortOrder
    info?: SortOrder
    type?: SortOrder
    facilityID?: SortOrderInput | SortOrder
    divisionID?: SortOrderInput | SortOrder
    serviceID?: SortOrderInput | SortOrder
    facility?: FacilityOrderByWithRelationInput
    division?: DivisionOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    contactID?: string
    info?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    type?: EnumContactTypeFilter<"Contact"> | $Enums.ContactType
    facilityID?: StringNullableFilter<"Contact"> | string | null
    divisionID?: StringNullableFilter<"Contact"> | string | null
    serviceID?: StringNullableFilter<"Contact"> | string | null
    facility?: XOR<FacilityNullableScalarRelationFilter, FacilityWhereInput> | null
    division?: XOR<DivisionNullableScalarRelationFilter, DivisionWhereInput> | null
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
  }, "contactID" | "info">

  export type ContactOrderByWithAggregationInput = {
    contactID?: SortOrder
    info?: SortOrder
    type?: SortOrder
    facilityID?: SortOrderInput | SortOrder
    divisionID?: SortOrderInput | SortOrder
    serviceID?: SortOrderInput | SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    contactID?: StringWithAggregatesFilter<"Contact"> | string
    info?: StringWithAggregatesFilter<"Contact"> | string
    type?: EnumContactTypeWithAggregatesFilter<"Contact"> | $Enums.ContactType
    facilityID?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    divisionID?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    serviceID?: StringNullableWithAggregatesFilter<"Contact"> | string | null
  }

  export type UpdateLogWhereInput = {
    AND?: UpdateLogWhereInput | UpdateLogWhereInput[]
    OR?: UpdateLogWhereInput[]
    NOT?: UpdateLogWhereInput | UpdateLogWhereInput[]
    updateLogID?: StringFilter<"UpdateLog"> | string
    entity?: StringFilter<"UpdateLog"> | string
    action?: EnumActionFilter<"UpdateLog"> | $Enums.Action
    createdAt?: DateTimeFilter<"UpdateLog"> | Date | string
    facilityID?: StringFilter<"UpdateLog"> | string
    divisionID?: StringNullableFilter<"UpdateLog"> | string | null
    employeeID?: StringFilter<"UpdateLog"> | string
    facility?: XOR<FacilityScalarRelationFilter, FacilityWhereInput>
    division?: XOR<DivisionNullableScalarRelationFilter, DivisionWhereInput> | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type UpdateLogOrderByWithRelationInput = {
    updateLogID?: SortOrder
    entity?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    facilityID?: SortOrder
    divisionID?: SortOrderInput | SortOrder
    employeeID?: SortOrder
    facility?: FacilityOrderByWithRelationInput
    division?: DivisionOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
  }

  export type UpdateLogWhereUniqueInput = Prisma.AtLeast<{
    updateLogID?: string
    AND?: UpdateLogWhereInput | UpdateLogWhereInput[]
    OR?: UpdateLogWhereInput[]
    NOT?: UpdateLogWhereInput | UpdateLogWhereInput[]
    entity?: StringFilter<"UpdateLog"> | string
    action?: EnumActionFilter<"UpdateLog"> | $Enums.Action
    createdAt?: DateTimeFilter<"UpdateLog"> | Date | string
    facilityID?: StringFilter<"UpdateLog"> | string
    divisionID?: StringNullableFilter<"UpdateLog"> | string | null
    employeeID?: StringFilter<"UpdateLog"> | string
    facility?: XOR<FacilityScalarRelationFilter, FacilityWhereInput>
    division?: XOR<DivisionNullableScalarRelationFilter, DivisionWhereInput> | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "updateLogID">

  export type UpdateLogOrderByWithAggregationInput = {
    updateLogID?: SortOrder
    entity?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    facilityID?: SortOrder
    divisionID?: SortOrderInput | SortOrder
    employeeID?: SortOrder
    _count?: UpdateLogCountOrderByAggregateInput
    _max?: UpdateLogMaxOrderByAggregateInput
    _min?: UpdateLogMinOrderByAggregateInput
  }

  export type UpdateLogScalarWhereWithAggregatesInput = {
    AND?: UpdateLogScalarWhereWithAggregatesInput | UpdateLogScalarWhereWithAggregatesInput[]
    OR?: UpdateLogScalarWhereWithAggregatesInput[]
    NOT?: UpdateLogScalarWhereWithAggregatesInput | UpdateLogScalarWhereWithAggregatesInput[]
    updateLogID?: StringWithAggregatesFilter<"UpdateLog"> | string
    entity?: StringWithAggregatesFilter<"UpdateLog"> | string
    action?: EnumActionWithAggregatesFilter<"UpdateLog"> | $Enums.Action
    createdAt?: DateTimeWithAggregatesFilter<"UpdateLog"> | Date | string
    facilityID?: StringWithAggregatesFilter<"UpdateLog"> | string
    divisionID?: StringNullableWithAggregatesFilter<"UpdateLog"> | string | null
    employeeID?: StringWithAggregatesFilter<"UpdateLog"> | string
  }

  export type RegionCreateInput = {
    regionID: number
    name: string
    id?: number
    pOrCs?: POrCCreateNestedManyWithoutRegionInput
    addresses?: AddressCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateInput = {
    regionID: number
    name: string
    id?: number
    pOrCs?: POrCUncheckedCreateNestedManyWithoutRegionInput
    addresses?: AddressUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionUpdateInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    pOrCs?: POrCUpdateManyWithoutRegionNestedInput
    addresses?: AddressUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    pOrCs?: POrCUncheckedUpdateManyWithoutRegionNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type RegionCreateManyInput = {
    regionID: number
    name: string
    id?: number
  }

  export type RegionUpdateManyMutationInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
  }

  export type RegionUncheckedUpdateManyInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
  }

  export type POrCCreateInput = {
    pOrCID: number
    name: string
    id?: number
    region: RegionCreateNestedOneWithoutPOrCsInput
    cOrMs?: COrMCreateNestedManyWithoutPOrCInput
    addresses?: AddressCreateNestedManyWithoutPOrCInput
  }

  export type POrCUncheckedCreateInput = {
    pOrCID: number
    name: string
    id?: number
    regionID: number
    cOrMs?: COrMUncheckedCreateNestedManyWithoutPOrCInput
    addresses?: AddressUncheckedCreateNestedManyWithoutPOrCInput
  }

  export type POrCUpdateInput = {
    pOrCID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    region?: RegionUpdateOneRequiredWithoutPOrCsNestedInput
    cOrMs?: COrMUpdateManyWithoutPOrCNestedInput
    addresses?: AddressUpdateManyWithoutPOrCNestedInput
  }

  export type POrCUncheckedUpdateInput = {
    pOrCID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    regionID?: IntFieldUpdateOperationsInput | number
    cOrMs?: COrMUncheckedUpdateManyWithoutPOrCNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutPOrCNestedInput
  }

  export type POrCCreateManyInput = {
    pOrCID: number
    name: string
    id?: number
    regionID: number
  }

  export type POrCUpdateManyMutationInput = {
    pOrCID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
  }

  export type POrCUncheckedUpdateManyInput = {
    pOrCID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    regionID?: IntFieldUpdateOperationsInput | number
  }

  export type COrMCreateInput = {
    cOrMID: number
    name: string
    id?: number
    pOrC: POrCCreateNestedOneWithoutCOrMsInput
    brgys?: BrgyCreateNestedManyWithoutCOrMInput
    addresses?: AddressCreateNestedManyWithoutCOrMInput
  }

  export type COrMUncheckedCreateInput = {
    cOrMID: number
    name: string
    id?: number
    pOrCID: number
    brgys?: BrgyUncheckedCreateNestedManyWithoutCOrMInput
    addresses?: AddressUncheckedCreateNestedManyWithoutCOrMInput
  }

  export type COrMUpdateInput = {
    cOrMID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    pOrC?: POrCUpdateOneRequiredWithoutCOrMsNestedInput
    brgys?: BrgyUpdateManyWithoutCOrMNestedInput
    addresses?: AddressUpdateManyWithoutCOrMNestedInput
  }

  export type COrMUncheckedUpdateInput = {
    cOrMID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    pOrCID?: IntFieldUpdateOperationsInput | number
    brgys?: BrgyUncheckedUpdateManyWithoutCOrMNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutCOrMNestedInput
  }

  export type COrMCreateManyInput = {
    cOrMID: number
    name: string
    id?: number
    pOrCID: number
  }

  export type COrMUpdateManyMutationInput = {
    cOrMID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
  }

  export type COrMUncheckedUpdateManyInput = {
    cOrMID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    pOrCID?: IntFieldUpdateOperationsInput | number
  }

  export type BrgyCreateInput = {
    brgyID: number
    name: string
    id?: number
    cOrM: COrMCreateNestedOneWithoutBrgysInput
    addresses?: AddressCreateNestedManyWithoutBrgyInput
  }

  export type BrgyUncheckedCreateInput = {
    brgyID: number
    name: string
    id?: number
    cOrMID: number
    addresses?: AddressUncheckedCreateNestedManyWithoutBrgyInput
  }

  export type BrgyUpdateInput = {
    brgyID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    cOrM?: COrMUpdateOneRequiredWithoutBrgysNestedInput
    addresses?: AddressUpdateManyWithoutBrgyNestedInput
  }

  export type BrgyUncheckedUpdateInput = {
    brgyID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    cOrMID?: IntFieldUpdateOperationsInput | number
    addresses?: AddressUncheckedUpdateManyWithoutBrgyNestedInput
  }

  export type BrgyCreateManyInput = {
    brgyID: number
    name: string
    id?: number
    cOrMID: number
  }

  export type BrgyUpdateManyMutationInput = {
    brgyID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
  }

  export type BrgyUncheckedUpdateManyInput = {
    brgyID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    cOrMID?: IntFieldUpdateOperationsInput | number
  }

  export type AddressCreateInput = {
    street: string
    region: RegionCreateNestedOneWithoutAddressesInput
    pOrC: POrCCreateNestedOneWithoutAddressesInput
    cOrM: COrMCreateNestedOneWithoutAddressesInput
    brgy: BrgyCreateNestedOneWithoutAddressesInput
    facility: FacilityCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    regionID: number
    pOrCID: number
    cOrMID: number
    brgyID: number
    street: string
    facilityID: string
  }

  export type AddressUpdateInput = {
    street?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutAddressesNestedInput
    pOrC?: POrCUpdateOneRequiredWithoutAddressesNestedInput
    cOrM?: COrMUpdateOneRequiredWithoutAddressesNestedInput
    brgy?: BrgyUpdateOneRequiredWithoutAddressesNestedInput
    facility?: FacilityUpdateOneRequiredWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    pOrCID?: IntFieldUpdateOperationsInput | number
    cOrMID?: IntFieldUpdateOperationsInput | number
    brgyID?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    facilityID?: StringFieldUpdateOperationsInput | string
  }

  export type AddressCreateManyInput = {
    regionID: number
    pOrCID: number
    cOrMID: number
    brgyID: number
    street: string
    facilityID: string
  }

  export type AddressUpdateManyMutationInput = {
    street?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateManyInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    pOrCID?: IntFieldUpdateOperationsInput | number
    cOrMID?: IntFieldUpdateOperationsInput | number
    brgyID?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    facilityID?: StringFieldUpdateOperationsInput | string
  }

  export type FacilityCreateInput = {
    facilityID?: string
    name: string
    photo: string
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    facilityType: $Enums.FacilityType
    ownership: $Enums.Ownership
    bookingSystem?: string | null
    acceptedProviders?: FacilityCreateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: Date | string
    address?: AddressCreateNestedOneWithoutFacilityInput
    contacts?: ContactCreateNestedManyWithoutFacilityInput
    services?: ServiceCreateNestedManyWithoutFacilityInput
    employees?: EmployeeCreateNestedManyWithoutFacilityInput
    divisions?: DivisionCreateNestedManyWithoutFacilityInput
    logs?: UpdateLogCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateInput = {
    facilityID?: string
    name: string
    photo: string
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    facilityType: $Enums.FacilityType
    ownership: $Enums.Ownership
    bookingSystem?: string | null
    acceptedProviders?: FacilityCreateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: Date | string
    address?: AddressUncheckedCreateNestedOneWithoutFacilityInput
    contacts?: ContactUncheckedCreateNestedManyWithoutFacilityInput
    services?: ServiceUncheckedCreateNestedManyWithoutFacilityInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutFacilityInput
    divisions?: DivisionUncheckedCreateNestedManyWithoutFacilityInput
    logs?: UpdateLogUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUpdateInput = {
    facilityID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityType?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    ownership?: EnumOwnershipFieldUpdateOperationsInput | $Enums.Ownership
    bookingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedProviders?: FacilityUpdateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateOneWithoutFacilityNestedInput
    contacts?: ContactUpdateManyWithoutFacilityNestedInput
    services?: ServiceUpdateManyWithoutFacilityNestedInput
    employees?: EmployeeUpdateManyWithoutFacilityNestedInput
    divisions?: DivisionUpdateManyWithoutFacilityNestedInput
    logs?: UpdateLogUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateInput = {
    facilityID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityType?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    ownership?: EnumOwnershipFieldUpdateOperationsInput | $Enums.Ownership
    bookingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedProviders?: FacilityUpdateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUncheckedUpdateOneWithoutFacilityNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutFacilityNestedInput
    services?: ServiceUncheckedUpdateManyWithoutFacilityNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutFacilityNestedInput
    divisions?: DivisionUncheckedUpdateManyWithoutFacilityNestedInput
    logs?: UpdateLogUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityCreateManyInput = {
    facilityID?: string
    name: string
    photo: string
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    facilityType: $Enums.FacilityType
    ownership: $Enums.Ownership
    bookingSystem?: string | null
    acceptedProviders?: FacilityCreateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: Date | string
  }

  export type FacilityUpdateManyMutationInput = {
    facilityID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityType?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    ownership?: EnumOwnershipFieldUpdateOperationsInput | $Enums.Ownership
    bookingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedProviders?: FacilityUpdateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityUncheckedUpdateManyInput = {
    facilityID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityType?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    ownership?: EnumOwnershipFieldUpdateOperationsInput | $Enums.Ownership
    bookingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedProviders?: FacilityUpdateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DivisionCreateInput = {
    divisionID?: string
    name: string
    openingTime: Date | string
    closingTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutDivisionInput
    facility: FacilityCreateNestedOneWithoutDivisionsInput
    services?: ServiceCreateNestedManyWithoutDivisionInput
    admins?: EmployeeCreateNestedManyWithoutDivisionsInput
    logs?: UpdateLogCreateNestedManyWithoutDivisionInput
  }

  export type DivisionUncheckedCreateInput = {
    divisionID?: string
    name: string
    openingTime: Date | string
    closingTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    facilityID: string
    contacts?: ContactUncheckedCreateNestedManyWithoutDivisionInput
    services?: ServiceUncheckedCreateNestedManyWithoutDivisionInput
    admins?: EmployeeUncheckedCreateNestedManyWithoutDivisionsInput
    logs?: UpdateLogUncheckedCreateNestedManyWithoutDivisionInput
  }

  export type DivisionUpdateInput = {
    divisionID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    openingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutDivisionNestedInput
    facility?: FacilityUpdateOneRequiredWithoutDivisionsNestedInput
    services?: ServiceUpdateManyWithoutDivisionNestedInput
    admins?: EmployeeUpdateManyWithoutDivisionsNestedInput
    logs?: UpdateLogUpdateManyWithoutDivisionNestedInput
  }

  export type DivisionUncheckedUpdateInput = {
    divisionID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    openingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
    contacts?: ContactUncheckedUpdateManyWithoutDivisionNestedInput
    services?: ServiceUncheckedUpdateManyWithoutDivisionNestedInput
    admins?: EmployeeUncheckedUpdateManyWithoutDivisionsNestedInput
    logs?: UpdateLogUncheckedUpdateManyWithoutDivisionNestedInput
  }

  export type DivisionCreateManyInput = {
    divisionID?: string
    name: string
    openingTime: Date | string
    closingTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    facilityID: string
  }

  export type DivisionUpdateManyMutationInput = {
    divisionID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    openingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DivisionUncheckedUpdateManyInput = {
    divisionID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    openingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeCreateInput = {
    employeeID?: string
    password: string
    role: $Enums.Role
    fname: string
    mname?: string | null
    lname: string
    photo?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutEmployeeInput
    facility: FacilityCreateNestedOneWithoutEmployeesInput
    divisions?: DivisionCreateNestedManyWithoutAdminsInput
    updateLog?: UpdateLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    employeeID?: string
    password: string
    role: $Enums.Role
    fname: string
    mname?: string | null
    lname: string
    photo?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    facilityID: string
    sessions?: SessionUncheckedCreateNestedManyWithoutEmployeeInput
    divisions?: DivisionUncheckedCreateNestedManyWithoutAdminsInput
    updateLog?: UpdateLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    employeeID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    fname?: StringFieldUpdateOperationsInput | string
    mname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutEmployeeNestedInput
    facility?: FacilityUpdateOneRequiredWithoutEmployeesNestedInput
    divisions?: DivisionUpdateManyWithoutAdminsNestedInput
    updateLog?: UpdateLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    employeeID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    fname?: StringFieldUpdateOperationsInput | string
    mname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
    sessions?: SessionUncheckedUpdateManyWithoutEmployeeNestedInput
    divisions?: DivisionUncheckedUpdateManyWithoutAdminsNestedInput
    updateLog?: UpdateLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    employeeID?: string
    password: string
    role: $Enums.Role
    fname: string
    mname?: string | null
    lname: string
    photo?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    facilityID: string
  }

  export type EmployeeUpdateManyMutationInput = {
    employeeID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    fname?: StringFieldUpdateOperationsInput | string
    mname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    employeeID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    fname?: StringFieldUpdateOperationsInput | string
    mname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateInput = {
    sessionID: string
    expiresAt: Date | string
    employee: EmployeeCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    sessionID: string
    expiresAt: Date | string
    employeeID: string
  }

  export type SessionUpdateInput = {
    sessionID?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    sessionID?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeID?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateManyInput = {
    sessionID: string
    expiresAt: Date | string
    employeeID: string
  }

  export type SessionUpdateManyMutationInput = {
    sessionID?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    sessionID?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeID?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceCreateInput = {
    serviceID?: string
    type: string
    keywords?: ServiceCreatekeywordsInput | string[]
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumbers?: ContactCreateNestedManyWithoutServiceInput
    facility: FacilityCreateNestedOneWithoutServicesInput
    division?: DivisionCreateNestedOneWithoutServicesInput
    ambulanceService?: AmbulanceServiceCreateNestedOneWithoutServiceInput
    bloodBankService?: BloodBankServiceCreateNestedOneWithoutServiceInput
    erService?: ERServiceCreateNestedOneWithoutServiceInput
    icuService?: ICUServiceCreateNestedOneWithoutServiceInput
    outpatientService?: OutpatientServiceCreateNestedOneWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    serviceID?: string
    type: string
    keywords?: ServiceCreatekeywordsInput | string[]
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilityID: string
    divisionID?: string | null
    phoneNumbers?: ContactUncheckedCreateNestedManyWithoutServiceInput
    ambulanceService?: AmbulanceServiceUncheckedCreateNestedOneWithoutServiceInput
    bloodBankService?: BloodBankServiceUncheckedCreateNestedOneWithoutServiceInput
    erService?: ERServiceUncheckedCreateNestedOneWithoutServiceInput
    icuService?: ICUServiceUncheckedCreateNestedOneWithoutServiceInput
    outpatientService?: OutpatientServiceUncheckedCreateNestedOneWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    serviceID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ServiceUpdatekeywordsInput | string[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumbers?: ContactUpdateManyWithoutServiceNestedInput
    facility?: FacilityUpdateOneRequiredWithoutServicesNestedInput
    division?: DivisionUpdateOneWithoutServicesNestedInput
    ambulanceService?: AmbulanceServiceUpdateOneWithoutServiceNestedInput
    bloodBankService?: BloodBankServiceUpdateOneWithoutServiceNestedInput
    erService?: ERServiceUpdateOneWithoutServiceNestedInput
    icuService?: ICUServiceUpdateOneWithoutServiceNestedInput
    outpatientService?: OutpatientServiceUpdateOneWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    serviceID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ServiceUpdatekeywordsInput | string[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
    divisionID?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumbers?: ContactUncheckedUpdateManyWithoutServiceNestedInput
    ambulanceService?: AmbulanceServiceUncheckedUpdateOneWithoutServiceNestedInput
    bloodBankService?: BloodBankServiceUncheckedUpdateOneWithoutServiceNestedInput
    erService?: ERServiceUncheckedUpdateOneWithoutServiceNestedInput
    icuService?: ICUServiceUncheckedUpdateOneWithoutServiceNestedInput
    outpatientService?: OutpatientServiceUncheckedUpdateOneWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    serviceID?: string
    type: string
    keywords?: ServiceCreatekeywordsInput | string[]
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilityID: string
    divisionID?: string | null
  }

  export type ServiceUpdateManyMutationInput = {
    serviceID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ServiceUpdatekeywordsInput | string[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    serviceID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ServiceUpdatekeywordsInput | string[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
    divisionID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AmbulanceServiceCreateInput = {
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    availability?: $Enums.Availability
    baseRate: number
    minCoverageRadius: number
    mileageRate: number
    maxCoverageRadius: number
    service: ServiceCreateNestedOneWithoutAmbulanceServiceInput
  }

  export type AmbulanceServiceUncheckedCreateInput = {
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    availability?: $Enums.Availability
    baseRate: number
    minCoverageRadius: number
    mileageRate: number
    maxCoverageRadius: number
    serviceID: string
  }

  export type AmbulanceServiceUpdateInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availability?: EnumAvailabilityFieldUpdateOperationsInput | $Enums.Availability
    baseRate?: FloatFieldUpdateOperationsInput | number
    minCoverageRadius?: FloatFieldUpdateOperationsInput | number
    mileageRate?: FloatFieldUpdateOperationsInput | number
    maxCoverageRadius?: FloatFieldUpdateOperationsInput | number
    service?: ServiceUpdateOneRequiredWithoutAmbulanceServiceNestedInput
  }

  export type AmbulanceServiceUncheckedUpdateInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availability?: EnumAvailabilityFieldUpdateOperationsInput | $Enums.Availability
    baseRate?: FloatFieldUpdateOperationsInput | number
    minCoverageRadius?: FloatFieldUpdateOperationsInput | number
    mileageRate?: FloatFieldUpdateOperationsInput | number
    maxCoverageRadius?: FloatFieldUpdateOperationsInput | number
    serviceID?: StringFieldUpdateOperationsInput | string
  }

  export type AmbulanceServiceCreateManyInput = {
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    availability?: $Enums.Availability
    baseRate: number
    minCoverageRadius: number
    mileageRate: number
    maxCoverageRadius: number
    serviceID: string
  }

  export type AmbulanceServiceUpdateManyMutationInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availability?: EnumAvailabilityFieldUpdateOperationsInput | $Enums.Availability
    baseRate?: FloatFieldUpdateOperationsInput | number
    minCoverageRadius?: FloatFieldUpdateOperationsInput | number
    mileageRate?: FloatFieldUpdateOperationsInput | number
    maxCoverageRadius?: FloatFieldUpdateOperationsInput | number
  }

  export type AmbulanceServiceUncheckedUpdateManyInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availability?: EnumAvailabilityFieldUpdateOperationsInput | $Enums.Availability
    baseRate?: FloatFieldUpdateOperationsInput | number
    minCoverageRadius?: FloatFieldUpdateOperationsInput | number
    mileageRate?: FloatFieldUpdateOperationsInput | number
    maxCoverageRadius?: FloatFieldUpdateOperationsInput | number
    serviceID?: StringFieldUpdateOperationsInput | string
  }

  export type BloodTypeMappingCreateInput = {
    A_P?: boolean
    A_N?: boolean
    B_P?: boolean
    B_N?: boolean
    O_P?: boolean
    O_N?: boolean
    AB_P?: boolean
    AB_N?: boolean
    BloodBankService: BloodBankServiceCreateNestedOneWithoutBloodTypeAvailabilityInput
  }

  export type BloodTypeMappingUncheckedCreateInput = {
    A_P?: boolean
    A_N?: boolean
    B_P?: boolean
    B_N?: boolean
    O_P?: boolean
    O_N?: boolean
    AB_P?: boolean
    AB_N?: boolean
    serviceID: string
  }

  export type BloodTypeMappingUpdateInput = {
    A_P?: BoolFieldUpdateOperationsInput | boolean
    A_N?: BoolFieldUpdateOperationsInput | boolean
    B_P?: BoolFieldUpdateOperationsInput | boolean
    B_N?: BoolFieldUpdateOperationsInput | boolean
    O_P?: BoolFieldUpdateOperationsInput | boolean
    O_N?: BoolFieldUpdateOperationsInput | boolean
    AB_P?: BoolFieldUpdateOperationsInput | boolean
    AB_N?: BoolFieldUpdateOperationsInput | boolean
    BloodBankService?: BloodBankServiceUpdateOneRequiredWithoutBloodTypeAvailabilityNestedInput
  }

  export type BloodTypeMappingUncheckedUpdateInput = {
    A_P?: BoolFieldUpdateOperationsInput | boolean
    A_N?: BoolFieldUpdateOperationsInput | boolean
    B_P?: BoolFieldUpdateOperationsInput | boolean
    B_N?: BoolFieldUpdateOperationsInput | boolean
    O_P?: BoolFieldUpdateOperationsInput | boolean
    O_N?: BoolFieldUpdateOperationsInput | boolean
    AB_P?: BoolFieldUpdateOperationsInput | boolean
    AB_N?: BoolFieldUpdateOperationsInput | boolean
    serviceID?: StringFieldUpdateOperationsInput | string
  }

  export type BloodTypeMappingCreateManyInput = {
    A_P?: boolean
    A_N?: boolean
    B_P?: boolean
    B_N?: boolean
    O_P?: boolean
    O_N?: boolean
    AB_P?: boolean
    AB_N?: boolean
    serviceID: string
  }

  export type BloodTypeMappingUpdateManyMutationInput = {
    A_P?: BoolFieldUpdateOperationsInput | boolean
    A_N?: BoolFieldUpdateOperationsInput | boolean
    B_P?: BoolFieldUpdateOperationsInput | boolean
    B_N?: BoolFieldUpdateOperationsInput | boolean
    O_P?: BoolFieldUpdateOperationsInput | boolean
    O_N?: BoolFieldUpdateOperationsInput | boolean
    AB_P?: BoolFieldUpdateOperationsInput | boolean
    AB_N?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BloodTypeMappingUncheckedUpdateManyInput = {
    A_P?: BoolFieldUpdateOperationsInput | boolean
    A_N?: BoolFieldUpdateOperationsInput | boolean
    B_P?: BoolFieldUpdateOperationsInput | boolean
    B_N?: BoolFieldUpdateOperationsInput | boolean
    O_P?: BoolFieldUpdateOperationsInput | boolean
    O_N?: BoolFieldUpdateOperationsInput | boolean
    AB_P?: BoolFieldUpdateOperationsInput | boolean
    AB_N?: BoolFieldUpdateOperationsInput | boolean
    serviceID?: StringFieldUpdateOperationsInput | string
  }

  export type BloodBankServiceCreateInput = {
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    basePricePerUnit: number
    turnaroundTimeD: number
    turnaroundTimeH: number
    bloodTypeAvailability?: BloodTypeMappingCreateNestedOneWithoutBloodBankServiceInput
    service: ServiceCreateNestedOneWithoutBloodBankServiceInput
  }

  export type BloodBankServiceUncheckedCreateInput = {
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    basePricePerUnit: number
    turnaroundTimeD: number
    turnaroundTimeH: number
    serviceID: string
    bloodTypeAvailability?: BloodTypeMappingUncheckedCreateNestedOneWithoutBloodBankServiceInput
  }

  export type BloodBankServiceUpdateInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    basePricePerUnit?: FloatFieldUpdateOperationsInput | number
    turnaroundTimeD?: IntFieldUpdateOperationsInput | number
    turnaroundTimeH?: IntFieldUpdateOperationsInput | number
    bloodTypeAvailability?: BloodTypeMappingUpdateOneWithoutBloodBankServiceNestedInput
    service?: ServiceUpdateOneRequiredWithoutBloodBankServiceNestedInput
  }

  export type BloodBankServiceUncheckedUpdateInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    basePricePerUnit?: FloatFieldUpdateOperationsInput | number
    turnaroundTimeD?: IntFieldUpdateOperationsInput | number
    turnaroundTimeH?: IntFieldUpdateOperationsInput | number
    serviceID?: StringFieldUpdateOperationsInput | string
    bloodTypeAvailability?: BloodTypeMappingUncheckedUpdateOneWithoutBloodBankServiceNestedInput
  }

  export type BloodBankServiceCreateManyInput = {
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    basePricePerUnit: number
    turnaroundTimeD: number
    turnaroundTimeH: number
    serviceID: string
  }

  export type BloodBankServiceUpdateManyMutationInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    basePricePerUnit?: FloatFieldUpdateOperationsInput | number
    turnaroundTimeD?: IntFieldUpdateOperationsInput | number
    turnaroundTimeH?: IntFieldUpdateOperationsInput | number
  }

  export type BloodBankServiceUncheckedUpdateManyInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    basePricePerUnit?: FloatFieldUpdateOperationsInput | number
    turnaroundTimeD?: IntFieldUpdateOperationsInput | number
    turnaroundTimeH?: IntFieldUpdateOperationsInput | number
    serviceID?: StringFieldUpdateOperationsInput | string
  }

  export type ERServiceCreateInput = {
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    load?: $Enums.Load
    availableBeds?: number
    nonUrgentPatients?: number
    nonUrgentQueueLength?: number
    urgentPatients?: number
    urgentQueueLength?: number
    criticalPatients?: number
    criticalQueueLength?: number
    service: ServiceCreateNestedOneWithoutErServiceInput
  }

  export type ERServiceUncheckedCreateInput = {
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    load?: $Enums.Load
    availableBeds?: number
    nonUrgentPatients?: number
    nonUrgentQueueLength?: number
    urgentPatients?: number
    urgentQueueLength?: number
    criticalPatients?: number
    criticalQueueLength?: number
    serviceID: string
  }

  export type ERServiceUpdateInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    load?: EnumLoadFieldUpdateOperationsInput | $Enums.Load
    availableBeds?: IntFieldUpdateOperationsInput | number
    nonUrgentPatients?: IntFieldUpdateOperationsInput | number
    nonUrgentQueueLength?: IntFieldUpdateOperationsInput | number
    urgentPatients?: IntFieldUpdateOperationsInput | number
    urgentQueueLength?: IntFieldUpdateOperationsInput | number
    criticalPatients?: IntFieldUpdateOperationsInput | number
    criticalQueueLength?: IntFieldUpdateOperationsInput | number
    service?: ServiceUpdateOneRequiredWithoutErServiceNestedInput
  }

  export type ERServiceUncheckedUpdateInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    load?: EnumLoadFieldUpdateOperationsInput | $Enums.Load
    availableBeds?: IntFieldUpdateOperationsInput | number
    nonUrgentPatients?: IntFieldUpdateOperationsInput | number
    nonUrgentQueueLength?: IntFieldUpdateOperationsInput | number
    urgentPatients?: IntFieldUpdateOperationsInput | number
    urgentQueueLength?: IntFieldUpdateOperationsInput | number
    criticalPatients?: IntFieldUpdateOperationsInput | number
    criticalQueueLength?: IntFieldUpdateOperationsInput | number
    serviceID?: StringFieldUpdateOperationsInput | string
  }

  export type ERServiceCreateManyInput = {
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    load?: $Enums.Load
    availableBeds?: number
    nonUrgentPatients?: number
    nonUrgentQueueLength?: number
    urgentPatients?: number
    urgentQueueLength?: number
    criticalPatients?: number
    criticalQueueLength?: number
    serviceID: string
  }

  export type ERServiceUpdateManyMutationInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    load?: EnumLoadFieldUpdateOperationsInput | $Enums.Load
    availableBeds?: IntFieldUpdateOperationsInput | number
    nonUrgentPatients?: IntFieldUpdateOperationsInput | number
    nonUrgentQueueLength?: IntFieldUpdateOperationsInput | number
    urgentPatients?: IntFieldUpdateOperationsInput | number
    urgentQueueLength?: IntFieldUpdateOperationsInput | number
    criticalPatients?: IntFieldUpdateOperationsInput | number
    criticalQueueLength?: IntFieldUpdateOperationsInput | number
  }

  export type ERServiceUncheckedUpdateManyInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    load?: EnumLoadFieldUpdateOperationsInput | $Enums.Load
    availableBeds?: IntFieldUpdateOperationsInput | number
    nonUrgentPatients?: IntFieldUpdateOperationsInput | number
    nonUrgentQueueLength?: IntFieldUpdateOperationsInput | number
    urgentPatients?: IntFieldUpdateOperationsInput | number
    urgentQueueLength?: IntFieldUpdateOperationsInput | number
    criticalPatients?: IntFieldUpdateOperationsInput | number
    criticalQueueLength?: IntFieldUpdateOperationsInput | number
    serviceID?: StringFieldUpdateOperationsInput | string
  }

  export type ICUServiceCreateInput = {
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    load?: $Enums.Load
    baseRate: number
    availableBeds?: number
    cardiacSupport?: boolean
    neurologicalSupport?: boolean
    renalSupport?: boolean
    respiratorySupport?: boolean
    service: ServiceCreateNestedOneWithoutIcuServiceInput
  }

  export type ICUServiceUncheckedCreateInput = {
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    load?: $Enums.Load
    baseRate: number
    availableBeds?: number
    cardiacSupport?: boolean
    neurologicalSupport?: boolean
    renalSupport?: boolean
    respiratorySupport?: boolean
    serviceID: string
  }

  export type ICUServiceUpdateInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    load?: EnumLoadFieldUpdateOperationsInput | $Enums.Load
    baseRate?: FloatFieldUpdateOperationsInput | number
    availableBeds?: IntFieldUpdateOperationsInput | number
    cardiacSupport?: BoolFieldUpdateOperationsInput | boolean
    neurologicalSupport?: BoolFieldUpdateOperationsInput | boolean
    renalSupport?: BoolFieldUpdateOperationsInput | boolean
    respiratorySupport?: BoolFieldUpdateOperationsInput | boolean
    service?: ServiceUpdateOneRequiredWithoutIcuServiceNestedInput
  }

  export type ICUServiceUncheckedUpdateInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    load?: EnumLoadFieldUpdateOperationsInput | $Enums.Load
    baseRate?: FloatFieldUpdateOperationsInput | number
    availableBeds?: IntFieldUpdateOperationsInput | number
    cardiacSupport?: BoolFieldUpdateOperationsInput | boolean
    neurologicalSupport?: BoolFieldUpdateOperationsInput | boolean
    renalSupport?: BoolFieldUpdateOperationsInput | boolean
    respiratorySupport?: BoolFieldUpdateOperationsInput | boolean
    serviceID?: StringFieldUpdateOperationsInput | string
  }

  export type ICUServiceCreateManyInput = {
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    load?: $Enums.Load
    baseRate: number
    availableBeds?: number
    cardiacSupport?: boolean
    neurologicalSupport?: boolean
    renalSupport?: boolean
    respiratorySupport?: boolean
    serviceID: string
  }

  export type ICUServiceUpdateManyMutationInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    load?: EnumLoadFieldUpdateOperationsInput | $Enums.Load
    baseRate?: FloatFieldUpdateOperationsInput | number
    availableBeds?: IntFieldUpdateOperationsInput | number
    cardiacSupport?: BoolFieldUpdateOperationsInput | boolean
    neurologicalSupport?: BoolFieldUpdateOperationsInput | boolean
    renalSupport?: BoolFieldUpdateOperationsInput | boolean
    respiratorySupport?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ICUServiceUncheckedUpdateManyInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    load?: EnumLoadFieldUpdateOperationsInput | $Enums.Load
    baseRate?: FloatFieldUpdateOperationsInput | number
    availableBeds?: IntFieldUpdateOperationsInput | number
    cardiacSupport?: BoolFieldUpdateOperationsInput | boolean
    neurologicalSupport?: BoolFieldUpdateOperationsInput | boolean
    renalSupport?: BoolFieldUpdateOperationsInput | boolean
    respiratorySupport?: BoolFieldUpdateOperationsInput | boolean
    serviceID?: StringFieldUpdateOperationsInput | string
  }

  export type OutpatientServiceCreateInput = {
    basePrice: number
    completionTimeD: number
    completionTimeH: number
    isAvailable?: boolean
    acceptsWalkIns: boolean
    service: ServiceCreateNestedOneWithoutOutpatientServiceInput
  }

  export type OutpatientServiceUncheckedCreateInput = {
    basePrice: number
    completionTimeD: number
    completionTimeH: number
    isAvailable?: boolean
    acceptsWalkIns: boolean
    serviceID: string
  }

  export type OutpatientServiceUpdateInput = {
    basePrice?: FloatFieldUpdateOperationsInput | number
    completionTimeD?: IntFieldUpdateOperationsInput | number
    completionTimeH?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    acceptsWalkIns?: BoolFieldUpdateOperationsInput | boolean
    service?: ServiceUpdateOneRequiredWithoutOutpatientServiceNestedInput
  }

  export type OutpatientServiceUncheckedUpdateInput = {
    basePrice?: FloatFieldUpdateOperationsInput | number
    completionTimeD?: IntFieldUpdateOperationsInput | number
    completionTimeH?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    acceptsWalkIns?: BoolFieldUpdateOperationsInput | boolean
    serviceID?: StringFieldUpdateOperationsInput | string
  }

  export type OutpatientServiceCreateManyInput = {
    basePrice: number
    completionTimeD: number
    completionTimeH: number
    isAvailable?: boolean
    acceptsWalkIns: boolean
    serviceID: string
  }

  export type OutpatientServiceUpdateManyMutationInput = {
    basePrice?: FloatFieldUpdateOperationsInput | number
    completionTimeD?: IntFieldUpdateOperationsInput | number
    completionTimeH?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    acceptsWalkIns?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OutpatientServiceUncheckedUpdateManyInput = {
    basePrice?: FloatFieldUpdateOperationsInput | number
    completionTimeD?: IntFieldUpdateOperationsInput | number
    completionTimeH?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    acceptsWalkIns?: BoolFieldUpdateOperationsInput | boolean
    serviceID?: StringFieldUpdateOperationsInput | string
  }

  export type ContactCreateInput = {
    contactID?: string
    info: string
    type: $Enums.ContactType
    facility?: FacilityCreateNestedOneWithoutContactsInput
    division?: DivisionCreateNestedOneWithoutContactsInput
    service?: ServiceCreateNestedOneWithoutPhoneNumbersInput
  }

  export type ContactUncheckedCreateInput = {
    contactID?: string
    info: string
    type: $Enums.ContactType
    facilityID?: string | null
    divisionID?: string | null
    serviceID?: string | null
  }

  export type ContactUpdateInput = {
    contactID?: StringFieldUpdateOperationsInput | string
    info?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    facility?: FacilityUpdateOneWithoutContactsNestedInput
    division?: DivisionUpdateOneWithoutContactsNestedInput
    service?: ServiceUpdateOneWithoutPhoneNumbersNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    contactID?: StringFieldUpdateOperationsInput | string
    info?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    facilityID?: NullableStringFieldUpdateOperationsInput | string | null
    divisionID?: NullableStringFieldUpdateOperationsInput | string | null
    serviceID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactCreateManyInput = {
    contactID?: string
    info: string
    type: $Enums.ContactType
    facilityID?: string | null
    divisionID?: string | null
    serviceID?: string | null
  }

  export type ContactUpdateManyMutationInput = {
    contactID?: StringFieldUpdateOperationsInput | string
    info?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
  }

  export type ContactUncheckedUpdateManyInput = {
    contactID?: StringFieldUpdateOperationsInput | string
    info?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    facilityID?: NullableStringFieldUpdateOperationsInput | string | null
    divisionID?: NullableStringFieldUpdateOperationsInput | string | null
    serviceID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UpdateLogCreateInput = {
    updateLogID?: string
    entity: string
    action: $Enums.Action
    createdAt?: Date | string
    facility: FacilityCreateNestedOneWithoutLogsInput
    division?: DivisionCreateNestedOneWithoutLogsInput
    employee: EmployeeCreateNestedOneWithoutUpdateLogInput
  }

  export type UpdateLogUncheckedCreateInput = {
    updateLogID?: string
    entity: string
    action: $Enums.Action
    createdAt?: Date | string
    facilityID: string
    divisionID?: string | null
    employeeID: string
  }

  export type UpdateLogUpdateInput = {
    updateLogID?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    action?: EnumActionFieldUpdateOperationsInput | $Enums.Action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneRequiredWithoutLogsNestedInput
    division?: DivisionUpdateOneWithoutLogsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutUpdateLogNestedInput
  }

  export type UpdateLogUncheckedUpdateInput = {
    updateLogID?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    action?: EnumActionFieldUpdateOperationsInput | $Enums.Action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
    divisionID?: NullableStringFieldUpdateOperationsInput | string | null
    employeeID?: StringFieldUpdateOperationsInput | string
  }

  export type UpdateLogCreateManyInput = {
    updateLogID?: string
    entity: string
    action: $Enums.Action
    createdAt?: Date | string
    facilityID: string
    divisionID?: string | null
    employeeID: string
  }

  export type UpdateLogUpdateManyMutationInput = {
    updateLogID?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    action?: EnumActionFieldUpdateOperationsInput | $Enums.Action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UpdateLogUncheckedUpdateManyInput = {
    updateLogID?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    action?: EnumActionFieldUpdateOperationsInput | $Enums.Action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
    divisionID?: NullableStringFieldUpdateOperationsInput | string | null
    employeeID?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type POrCListRelationFilter = {
    every?: POrCWhereInput
    some?: POrCWhereInput
    none?: POrCWhereInput
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type POrCOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegionCountOrderByAggregateInput = {
    regionID?: SortOrder
    name?: SortOrder
    id?: SortOrder
  }

  export type RegionAvgOrderByAggregateInput = {
    regionID?: SortOrder
    id?: SortOrder
  }

  export type RegionMaxOrderByAggregateInput = {
    regionID?: SortOrder
    name?: SortOrder
    id?: SortOrder
  }

  export type RegionMinOrderByAggregateInput = {
    regionID?: SortOrder
    name?: SortOrder
    id?: SortOrder
  }

  export type RegionSumOrderByAggregateInput = {
    regionID?: SortOrder
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type RegionScalarRelationFilter = {
    is?: RegionWhereInput
    isNot?: RegionWhereInput
  }

  export type COrMListRelationFilter = {
    every?: COrMWhereInput
    some?: COrMWhereInput
    none?: COrMWhereInput
  }

  export type COrMOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type POrCCountOrderByAggregateInput = {
    pOrCID?: SortOrder
    name?: SortOrder
    id?: SortOrder
    regionID?: SortOrder
  }

  export type POrCAvgOrderByAggregateInput = {
    pOrCID?: SortOrder
    id?: SortOrder
    regionID?: SortOrder
  }

  export type POrCMaxOrderByAggregateInput = {
    pOrCID?: SortOrder
    name?: SortOrder
    id?: SortOrder
    regionID?: SortOrder
  }

  export type POrCMinOrderByAggregateInput = {
    pOrCID?: SortOrder
    name?: SortOrder
    id?: SortOrder
    regionID?: SortOrder
  }

  export type POrCSumOrderByAggregateInput = {
    pOrCID?: SortOrder
    id?: SortOrder
    regionID?: SortOrder
  }

  export type POrCScalarRelationFilter = {
    is?: POrCWhereInput
    isNot?: POrCWhereInput
  }

  export type BrgyListRelationFilter = {
    every?: BrgyWhereInput
    some?: BrgyWhereInput
    none?: BrgyWhereInput
  }

  export type BrgyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type COrMCountOrderByAggregateInput = {
    cOrMID?: SortOrder
    name?: SortOrder
    id?: SortOrder
    pOrCID?: SortOrder
  }

  export type COrMAvgOrderByAggregateInput = {
    cOrMID?: SortOrder
    id?: SortOrder
    pOrCID?: SortOrder
  }

  export type COrMMaxOrderByAggregateInput = {
    cOrMID?: SortOrder
    name?: SortOrder
    id?: SortOrder
    pOrCID?: SortOrder
  }

  export type COrMMinOrderByAggregateInput = {
    cOrMID?: SortOrder
    name?: SortOrder
    id?: SortOrder
    pOrCID?: SortOrder
  }

  export type COrMSumOrderByAggregateInput = {
    cOrMID?: SortOrder
    id?: SortOrder
    pOrCID?: SortOrder
  }

  export type COrMScalarRelationFilter = {
    is?: COrMWhereInput
    isNot?: COrMWhereInput
  }

  export type BrgyCountOrderByAggregateInput = {
    brgyID?: SortOrder
    name?: SortOrder
    id?: SortOrder
    cOrMID?: SortOrder
  }

  export type BrgyAvgOrderByAggregateInput = {
    brgyID?: SortOrder
    id?: SortOrder
    cOrMID?: SortOrder
  }

  export type BrgyMaxOrderByAggregateInput = {
    brgyID?: SortOrder
    name?: SortOrder
    id?: SortOrder
    cOrMID?: SortOrder
  }

  export type BrgyMinOrderByAggregateInput = {
    brgyID?: SortOrder
    name?: SortOrder
    id?: SortOrder
    cOrMID?: SortOrder
  }

  export type BrgySumOrderByAggregateInput = {
    brgyID?: SortOrder
    id?: SortOrder
    cOrMID?: SortOrder
  }

  export type BrgyScalarRelationFilter = {
    is?: BrgyWhereInput
    isNot?: BrgyWhereInput
  }

  export type FacilityScalarRelationFilter = {
    is?: FacilityWhereInput
    isNot?: FacilityWhereInput
  }

  export type AddressRegionIDPOrCIDCOrMIDBrgyIDStreetCompoundUniqueInput = {
    regionID: number
    pOrCID: number
    cOrMID: number
    brgyID: number
    street: string
  }

  export type AddressCountOrderByAggregateInput = {
    regionID?: SortOrder
    pOrCID?: SortOrder
    cOrMID?: SortOrder
    brgyID?: SortOrder
    street?: SortOrder
    facilityID?: SortOrder
  }

  export type AddressAvgOrderByAggregateInput = {
    regionID?: SortOrder
    pOrCID?: SortOrder
    cOrMID?: SortOrder
    brgyID?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    regionID?: SortOrder
    pOrCID?: SortOrder
    cOrMID?: SortOrder
    brgyID?: SortOrder
    street?: SortOrder
    facilityID?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    regionID?: SortOrder
    pOrCID?: SortOrder
    cOrMID?: SortOrder
    brgyID?: SortOrder
    street?: SortOrder
    facilityID?: SortOrder
  }

  export type AddressSumOrderByAggregateInput = {
    regionID?: SortOrder
    pOrCID?: SortOrder
    cOrMID?: SortOrder
    brgyID?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumFacilityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FacilityType | EnumFacilityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FacilityType[] | ListEnumFacilityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FacilityType[] | ListEnumFacilityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFacilityTypeFilter<$PrismaModel> | $Enums.FacilityType
  }

  export type EnumOwnershipFilter<$PrismaModel = never> = {
    equals?: $Enums.Ownership | EnumOwnershipFieldRefInput<$PrismaModel>
    in?: $Enums.Ownership[] | ListEnumOwnershipFieldRefInput<$PrismaModel>
    notIn?: $Enums.Ownership[] | ListEnumOwnershipFieldRefInput<$PrismaModel>
    not?: NestedEnumOwnershipFilter<$PrismaModel> | $Enums.Ownership
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumProviderNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel> | null
    has?: $Enums.Provider | EnumProviderFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    hasSome?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AddressNullableScalarRelationFilter = {
    is?: AddressWhereInput | null
    isNot?: AddressWhereInput | null
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type DivisionListRelationFilter = {
    every?: DivisionWhereInput
    some?: DivisionWhereInput
    none?: DivisionWhereInput
  }

  export type UpdateLogListRelationFilter = {
    every?: UpdateLogWhereInput
    some?: UpdateLogWhereInput
    none?: UpdateLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DivisionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UpdateLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacilityCountOrderByAggregateInput = {
    facilityID?: SortOrder
    name?: SortOrder
    photo?: SortOrder
    openingTime?: SortOrder
    closingTime?: SortOrder
    facilityType?: SortOrder
    ownership?: SortOrder
    bookingSystem?: SortOrder
    acceptedProviders?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacilityMaxOrderByAggregateInput = {
    facilityID?: SortOrder
    name?: SortOrder
    photo?: SortOrder
    openingTime?: SortOrder
    closingTime?: SortOrder
    facilityType?: SortOrder
    ownership?: SortOrder
    bookingSystem?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacilityMinOrderByAggregateInput = {
    facilityID?: SortOrder
    name?: SortOrder
    photo?: SortOrder
    openingTime?: SortOrder
    closingTime?: SortOrder
    facilityType?: SortOrder
    ownership?: SortOrder
    bookingSystem?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumFacilityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FacilityType | EnumFacilityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FacilityType[] | ListEnumFacilityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FacilityType[] | ListEnumFacilityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFacilityTypeWithAggregatesFilter<$PrismaModel> | $Enums.FacilityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFacilityTypeFilter<$PrismaModel>
    _max?: NestedEnumFacilityTypeFilter<$PrismaModel>
  }

  export type EnumOwnershipWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Ownership | EnumOwnershipFieldRefInput<$PrismaModel>
    in?: $Enums.Ownership[] | ListEnumOwnershipFieldRefInput<$PrismaModel>
    notIn?: $Enums.Ownership[] | ListEnumOwnershipFieldRefInput<$PrismaModel>
    not?: NestedEnumOwnershipWithAggregatesFilter<$PrismaModel> | $Enums.Ownership
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOwnershipFilter<$PrismaModel>
    _max?: NestedEnumOwnershipFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DivisionCountOrderByAggregateInput = {
    divisionID?: SortOrder
    name?: SortOrder
    openingTime?: SortOrder
    closingTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facilityID?: SortOrder
  }

  export type DivisionMaxOrderByAggregateInput = {
    divisionID?: SortOrder
    name?: SortOrder
    openingTime?: SortOrder
    closingTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facilityID?: SortOrder
  }

  export type DivisionMinOrderByAggregateInput = {
    divisionID?: SortOrder
    name?: SortOrder
    openingTime?: SortOrder
    closingTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facilityID?: SortOrder
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeCountOrderByAggregateInput = {
    employeeID?: SortOrder
    password?: SortOrder
    role?: SortOrder
    fname?: SortOrder
    mname?: SortOrder
    lname?: SortOrder
    photo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facilityID?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    employeeID?: SortOrder
    password?: SortOrder
    role?: SortOrder
    fname?: SortOrder
    mname?: SortOrder
    lname?: SortOrder
    photo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facilityID?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    employeeID?: SortOrder
    password?: SortOrder
    role?: SortOrder
    fname?: SortOrder
    mname?: SortOrder
    lname?: SortOrder
    photo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facilityID?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    sessionID?: SortOrder
    expiresAt?: SortOrder
    employeeID?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    sessionID?: SortOrder
    expiresAt?: SortOrder
    employeeID?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    sessionID?: SortOrder
    expiresAt?: SortOrder
    employeeID?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DivisionNullableScalarRelationFilter = {
    is?: DivisionWhereInput | null
    isNot?: DivisionWhereInput | null
  }

  export type AmbulanceServiceNullableScalarRelationFilter = {
    is?: AmbulanceServiceWhereInput | null
    isNot?: AmbulanceServiceWhereInput | null
  }

  export type BloodBankServiceNullableScalarRelationFilter = {
    is?: BloodBankServiceWhereInput | null
    isNot?: BloodBankServiceWhereInput | null
  }

  export type ERServiceNullableScalarRelationFilter = {
    is?: ERServiceWhereInput | null
    isNot?: ERServiceWhereInput | null
  }

  export type ICUServiceNullableScalarRelationFilter = {
    is?: ICUServiceWhereInput | null
    isNot?: ICUServiceWhereInput | null
  }

  export type OutpatientServiceNullableScalarRelationFilter = {
    is?: OutpatientServiceWhereInput | null
    isNot?: OutpatientServiceWhereInput | null
  }

  export type ServiceFacilityIDTypeCompoundUniqueInput = {
    facilityID: string
    type: string
  }

  export type ServiceCountOrderByAggregateInput = {
    serviceID?: SortOrder
    type?: SortOrder
    keywords?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facilityID?: SortOrder
    divisionID?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    serviceID?: SortOrder
    type?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facilityID?: SortOrder
    divisionID?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    serviceID?: SortOrder
    type?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    facilityID?: SortOrder
    divisionID?: SortOrder
  }

  export type EnumAvailabilityFilter<$PrismaModel = never> = {
    equals?: $Enums.Availability | EnumAvailabilityFieldRefInput<$PrismaModel>
    in?: $Enums.Availability[] | ListEnumAvailabilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Availability[] | ListEnumAvailabilityFieldRefInput<$PrismaModel>
    not?: NestedEnumAvailabilityFilter<$PrismaModel> | $Enums.Availability
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type AmbulanceServiceCountOrderByAggregateInput = {
    openingTime?: SortOrder
    closingTime?: SortOrder
    availability?: SortOrder
    baseRate?: SortOrder
    minCoverageRadius?: SortOrder
    mileageRate?: SortOrder
    maxCoverageRadius?: SortOrder
    serviceID?: SortOrder
  }

  export type AmbulanceServiceAvgOrderByAggregateInput = {
    baseRate?: SortOrder
    minCoverageRadius?: SortOrder
    mileageRate?: SortOrder
    maxCoverageRadius?: SortOrder
  }

  export type AmbulanceServiceMaxOrderByAggregateInput = {
    openingTime?: SortOrder
    closingTime?: SortOrder
    availability?: SortOrder
    baseRate?: SortOrder
    minCoverageRadius?: SortOrder
    mileageRate?: SortOrder
    maxCoverageRadius?: SortOrder
    serviceID?: SortOrder
  }

  export type AmbulanceServiceMinOrderByAggregateInput = {
    openingTime?: SortOrder
    closingTime?: SortOrder
    availability?: SortOrder
    baseRate?: SortOrder
    minCoverageRadius?: SortOrder
    mileageRate?: SortOrder
    maxCoverageRadius?: SortOrder
    serviceID?: SortOrder
  }

  export type AmbulanceServiceSumOrderByAggregateInput = {
    baseRate?: SortOrder
    minCoverageRadius?: SortOrder
    mileageRate?: SortOrder
    maxCoverageRadius?: SortOrder
  }

  export type EnumAvailabilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Availability | EnumAvailabilityFieldRefInput<$PrismaModel>
    in?: $Enums.Availability[] | ListEnumAvailabilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Availability[] | ListEnumAvailabilityFieldRefInput<$PrismaModel>
    not?: NestedEnumAvailabilityWithAggregatesFilter<$PrismaModel> | $Enums.Availability
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAvailabilityFilter<$PrismaModel>
    _max?: NestedEnumAvailabilityFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BloodBankServiceScalarRelationFilter = {
    is?: BloodBankServiceWhereInput
    isNot?: BloodBankServiceWhereInput
  }

  export type BloodTypeMappingCountOrderByAggregateInput = {
    A_P?: SortOrder
    A_N?: SortOrder
    B_P?: SortOrder
    B_N?: SortOrder
    O_P?: SortOrder
    O_N?: SortOrder
    AB_P?: SortOrder
    AB_N?: SortOrder
    serviceID?: SortOrder
  }

  export type BloodTypeMappingMaxOrderByAggregateInput = {
    A_P?: SortOrder
    A_N?: SortOrder
    B_P?: SortOrder
    B_N?: SortOrder
    O_P?: SortOrder
    O_N?: SortOrder
    AB_P?: SortOrder
    AB_N?: SortOrder
    serviceID?: SortOrder
  }

  export type BloodTypeMappingMinOrderByAggregateInput = {
    A_P?: SortOrder
    A_N?: SortOrder
    B_P?: SortOrder
    B_N?: SortOrder
    O_P?: SortOrder
    O_N?: SortOrder
    AB_P?: SortOrder
    AB_N?: SortOrder
    serviceID?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BloodTypeMappingNullableScalarRelationFilter = {
    is?: BloodTypeMappingWhereInput | null
    isNot?: BloodTypeMappingWhereInput | null
  }

  export type BloodBankServiceCountOrderByAggregateInput = {
    openingTime?: SortOrder
    closingTime?: SortOrder
    basePricePerUnit?: SortOrder
    turnaroundTimeD?: SortOrder
    turnaroundTimeH?: SortOrder
    serviceID?: SortOrder
  }

  export type BloodBankServiceAvgOrderByAggregateInput = {
    basePricePerUnit?: SortOrder
    turnaroundTimeD?: SortOrder
    turnaroundTimeH?: SortOrder
  }

  export type BloodBankServiceMaxOrderByAggregateInput = {
    openingTime?: SortOrder
    closingTime?: SortOrder
    basePricePerUnit?: SortOrder
    turnaroundTimeD?: SortOrder
    turnaroundTimeH?: SortOrder
    serviceID?: SortOrder
  }

  export type BloodBankServiceMinOrderByAggregateInput = {
    openingTime?: SortOrder
    closingTime?: SortOrder
    basePricePerUnit?: SortOrder
    turnaroundTimeD?: SortOrder
    turnaroundTimeH?: SortOrder
    serviceID?: SortOrder
  }

  export type BloodBankServiceSumOrderByAggregateInput = {
    basePricePerUnit?: SortOrder
    turnaroundTimeD?: SortOrder
    turnaroundTimeH?: SortOrder
  }

  export type EnumLoadFilter<$PrismaModel = never> = {
    equals?: $Enums.Load | EnumLoadFieldRefInput<$PrismaModel>
    in?: $Enums.Load[] | ListEnumLoadFieldRefInput<$PrismaModel>
    notIn?: $Enums.Load[] | ListEnumLoadFieldRefInput<$PrismaModel>
    not?: NestedEnumLoadFilter<$PrismaModel> | $Enums.Load
  }

  export type ERServiceCountOrderByAggregateInput = {
    openingTime?: SortOrder
    closingTime?: SortOrder
    load?: SortOrder
    availableBeds?: SortOrder
    nonUrgentPatients?: SortOrder
    nonUrgentQueueLength?: SortOrder
    urgentPatients?: SortOrder
    urgentQueueLength?: SortOrder
    criticalPatients?: SortOrder
    criticalQueueLength?: SortOrder
    serviceID?: SortOrder
  }

  export type ERServiceAvgOrderByAggregateInput = {
    availableBeds?: SortOrder
    nonUrgentPatients?: SortOrder
    nonUrgentQueueLength?: SortOrder
    urgentPatients?: SortOrder
    urgentQueueLength?: SortOrder
    criticalPatients?: SortOrder
    criticalQueueLength?: SortOrder
  }

  export type ERServiceMaxOrderByAggregateInput = {
    openingTime?: SortOrder
    closingTime?: SortOrder
    load?: SortOrder
    availableBeds?: SortOrder
    nonUrgentPatients?: SortOrder
    nonUrgentQueueLength?: SortOrder
    urgentPatients?: SortOrder
    urgentQueueLength?: SortOrder
    criticalPatients?: SortOrder
    criticalQueueLength?: SortOrder
    serviceID?: SortOrder
  }

  export type ERServiceMinOrderByAggregateInput = {
    openingTime?: SortOrder
    closingTime?: SortOrder
    load?: SortOrder
    availableBeds?: SortOrder
    nonUrgentPatients?: SortOrder
    nonUrgentQueueLength?: SortOrder
    urgentPatients?: SortOrder
    urgentQueueLength?: SortOrder
    criticalPatients?: SortOrder
    criticalQueueLength?: SortOrder
    serviceID?: SortOrder
  }

  export type ERServiceSumOrderByAggregateInput = {
    availableBeds?: SortOrder
    nonUrgentPatients?: SortOrder
    nonUrgentQueueLength?: SortOrder
    urgentPatients?: SortOrder
    urgentQueueLength?: SortOrder
    criticalPatients?: SortOrder
    criticalQueueLength?: SortOrder
  }

  export type EnumLoadWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Load | EnumLoadFieldRefInput<$PrismaModel>
    in?: $Enums.Load[] | ListEnumLoadFieldRefInput<$PrismaModel>
    notIn?: $Enums.Load[] | ListEnumLoadFieldRefInput<$PrismaModel>
    not?: NestedEnumLoadWithAggregatesFilter<$PrismaModel> | $Enums.Load
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoadFilter<$PrismaModel>
    _max?: NestedEnumLoadFilter<$PrismaModel>
  }

  export type ICUServiceCountOrderByAggregateInput = {
    openingTime?: SortOrder
    closingTime?: SortOrder
    load?: SortOrder
    baseRate?: SortOrder
    availableBeds?: SortOrder
    cardiacSupport?: SortOrder
    neurologicalSupport?: SortOrder
    renalSupport?: SortOrder
    respiratorySupport?: SortOrder
    serviceID?: SortOrder
  }

  export type ICUServiceAvgOrderByAggregateInput = {
    baseRate?: SortOrder
    availableBeds?: SortOrder
  }

  export type ICUServiceMaxOrderByAggregateInput = {
    openingTime?: SortOrder
    closingTime?: SortOrder
    load?: SortOrder
    baseRate?: SortOrder
    availableBeds?: SortOrder
    cardiacSupport?: SortOrder
    neurologicalSupport?: SortOrder
    renalSupport?: SortOrder
    respiratorySupport?: SortOrder
    serviceID?: SortOrder
  }

  export type ICUServiceMinOrderByAggregateInput = {
    openingTime?: SortOrder
    closingTime?: SortOrder
    load?: SortOrder
    baseRate?: SortOrder
    availableBeds?: SortOrder
    cardiacSupport?: SortOrder
    neurologicalSupport?: SortOrder
    renalSupport?: SortOrder
    respiratorySupport?: SortOrder
    serviceID?: SortOrder
  }

  export type ICUServiceSumOrderByAggregateInput = {
    baseRate?: SortOrder
    availableBeds?: SortOrder
  }

  export type OutpatientServiceCountOrderByAggregateInput = {
    basePrice?: SortOrder
    completionTimeD?: SortOrder
    completionTimeH?: SortOrder
    isAvailable?: SortOrder
    acceptsWalkIns?: SortOrder
    serviceID?: SortOrder
  }

  export type OutpatientServiceAvgOrderByAggregateInput = {
    basePrice?: SortOrder
    completionTimeD?: SortOrder
    completionTimeH?: SortOrder
  }

  export type OutpatientServiceMaxOrderByAggregateInput = {
    basePrice?: SortOrder
    completionTimeD?: SortOrder
    completionTimeH?: SortOrder
    isAvailable?: SortOrder
    acceptsWalkIns?: SortOrder
    serviceID?: SortOrder
  }

  export type OutpatientServiceMinOrderByAggregateInput = {
    basePrice?: SortOrder
    completionTimeD?: SortOrder
    completionTimeH?: SortOrder
    isAvailable?: SortOrder
    acceptsWalkIns?: SortOrder
    serviceID?: SortOrder
  }

  export type OutpatientServiceSumOrderByAggregateInput = {
    basePrice?: SortOrder
    completionTimeD?: SortOrder
    completionTimeH?: SortOrder
  }

  export type EnumContactTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeFilter<$PrismaModel> | $Enums.ContactType
  }

  export type FacilityNullableScalarRelationFilter = {
    is?: FacilityWhereInput | null
    isNot?: FacilityWhereInput | null
  }

  export type ServiceNullableScalarRelationFilter = {
    is?: ServiceWhereInput | null
    isNot?: ServiceWhereInput | null
  }

  export type ContactCountOrderByAggregateInput = {
    contactID?: SortOrder
    info?: SortOrder
    type?: SortOrder
    facilityID?: SortOrder
    divisionID?: SortOrder
    serviceID?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    contactID?: SortOrder
    info?: SortOrder
    type?: SortOrder
    facilityID?: SortOrder
    divisionID?: SortOrder
    serviceID?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    contactID?: SortOrder
    info?: SortOrder
    type?: SortOrder
    facilityID?: SortOrder
    divisionID?: SortOrder
    serviceID?: SortOrder
  }

  export type EnumContactTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContactType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactTypeFilter<$PrismaModel>
    _max?: NestedEnumContactTypeFilter<$PrismaModel>
  }

  export type EnumActionFilter<$PrismaModel = never> = {
    equals?: $Enums.Action | EnumActionFieldRefInput<$PrismaModel>
    in?: $Enums.Action[] | ListEnumActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Action[] | ListEnumActionFieldRefInput<$PrismaModel>
    not?: NestedEnumActionFilter<$PrismaModel> | $Enums.Action
  }

  export type UpdateLogCountOrderByAggregateInput = {
    updateLogID?: SortOrder
    entity?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    facilityID?: SortOrder
    divisionID?: SortOrder
    employeeID?: SortOrder
  }

  export type UpdateLogMaxOrderByAggregateInput = {
    updateLogID?: SortOrder
    entity?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    facilityID?: SortOrder
    divisionID?: SortOrder
    employeeID?: SortOrder
  }

  export type UpdateLogMinOrderByAggregateInput = {
    updateLogID?: SortOrder
    entity?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    facilityID?: SortOrder
    divisionID?: SortOrder
    employeeID?: SortOrder
  }

  export type EnumActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Action | EnumActionFieldRefInput<$PrismaModel>
    in?: $Enums.Action[] | ListEnumActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Action[] | ListEnumActionFieldRefInput<$PrismaModel>
    not?: NestedEnumActionWithAggregatesFilter<$PrismaModel> | $Enums.Action
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionFilter<$PrismaModel>
    _max?: NestedEnumActionFilter<$PrismaModel>
  }

  export type POrCCreateNestedManyWithoutRegionInput = {
    create?: XOR<POrCCreateWithoutRegionInput, POrCUncheckedCreateWithoutRegionInput> | POrCCreateWithoutRegionInput[] | POrCUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: POrCCreateOrConnectWithoutRegionInput | POrCCreateOrConnectWithoutRegionInput[]
    createMany?: POrCCreateManyRegionInputEnvelope
    connect?: POrCWhereUniqueInput | POrCWhereUniqueInput[]
  }

  export type AddressCreateNestedManyWithoutRegionInput = {
    create?: XOR<AddressCreateWithoutRegionInput, AddressUncheckedCreateWithoutRegionInput> | AddressCreateWithoutRegionInput[] | AddressUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutRegionInput | AddressCreateOrConnectWithoutRegionInput[]
    createMany?: AddressCreateManyRegionInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type POrCUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<POrCCreateWithoutRegionInput, POrCUncheckedCreateWithoutRegionInput> | POrCCreateWithoutRegionInput[] | POrCUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: POrCCreateOrConnectWithoutRegionInput | POrCCreateOrConnectWithoutRegionInput[]
    createMany?: POrCCreateManyRegionInputEnvelope
    connect?: POrCWhereUniqueInput | POrCWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<AddressCreateWithoutRegionInput, AddressUncheckedCreateWithoutRegionInput> | AddressCreateWithoutRegionInput[] | AddressUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutRegionInput | AddressCreateOrConnectWithoutRegionInput[]
    createMany?: AddressCreateManyRegionInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type POrCUpdateManyWithoutRegionNestedInput = {
    create?: XOR<POrCCreateWithoutRegionInput, POrCUncheckedCreateWithoutRegionInput> | POrCCreateWithoutRegionInput[] | POrCUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: POrCCreateOrConnectWithoutRegionInput | POrCCreateOrConnectWithoutRegionInput[]
    upsert?: POrCUpsertWithWhereUniqueWithoutRegionInput | POrCUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: POrCCreateManyRegionInputEnvelope
    set?: POrCWhereUniqueInput | POrCWhereUniqueInput[]
    disconnect?: POrCWhereUniqueInput | POrCWhereUniqueInput[]
    delete?: POrCWhereUniqueInput | POrCWhereUniqueInput[]
    connect?: POrCWhereUniqueInput | POrCWhereUniqueInput[]
    update?: POrCUpdateWithWhereUniqueWithoutRegionInput | POrCUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: POrCUpdateManyWithWhereWithoutRegionInput | POrCUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: POrCScalarWhereInput | POrCScalarWhereInput[]
  }

  export type AddressUpdateManyWithoutRegionNestedInput = {
    create?: XOR<AddressCreateWithoutRegionInput, AddressUncheckedCreateWithoutRegionInput> | AddressCreateWithoutRegionInput[] | AddressUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutRegionInput | AddressCreateOrConnectWithoutRegionInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutRegionInput | AddressUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: AddressCreateManyRegionInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutRegionInput | AddressUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutRegionInput | AddressUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type POrCUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<POrCCreateWithoutRegionInput, POrCUncheckedCreateWithoutRegionInput> | POrCCreateWithoutRegionInput[] | POrCUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: POrCCreateOrConnectWithoutRegionInput | POrCCreateOrConnectWithoutRegionInput[]
    upsert?: POrCUpsertWithWhereUniqueWithoutRegionInput | POrCUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: POrCCreateManyRegionInputEnvelope
    set?: POrCWhereUniqueInput | POrCWhereUniqueInput[]
    disconnect?: POrCWhereUniqueInput | POrCWhereUniqueInput[]
    delete?: POrCWhereUniqueInput | POrCWhereUniqueInput[]
    connect?: POrCWhereUniqueInput | POrCWhereUniqueInput[]
    update?: POrCUpdateWithWhereUniqueWithoutRegionInput | POrCUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: POrCUpdateManyWithWhereWithoutRegionInput | POrCUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: POrCScalarWhereInput | POrCScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<AddressCreateWithoutRegionInput, AddressUncheckedCreateWithoutRegionInput> | AddressCreateWithoutRegionInput[] | AddressUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutRegionInput | AddressCreateOrConnectWithoutRegionInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutRegionInput | AddressUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: AddressCreateManyRegionInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutRegionInput | AddressUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutRegionInput | AddressUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type RegionCreateNestedOneWithoutPOrCsInput = {
    create?: XOR<RegionCreateWithoutPOrCsInput, RegionUncheckedCreateWithoutPOrCsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutPOrCsInput
    connect?: RegionWhereUniqueInput
  }

  export type COrMCreateNestedManyWithoutPOrCInput = {
    create?: XOR<COrMCreateWithoutPOrCInput, COrMUncheckedCreateWithoutPOrCInput> | COrMCreateWithoutPOrCInput[] | COrMUncheckedCreateWithoutPOrCInput[]
    connectOrCreate?: COrMCreateOrConnectWithoutPOrCInput | COrMCreateOrConnectWithoutPOrCInput[]
    createMany?: COrMCreateManyPOrCInputEnvelope
    connect?: COrMWhereUniqueInput | COrMWhereUniqueInput[]
  }

  export type AddressCreateNestedManyWithoutPOrCInput = {
    create?: XOR<AddressCreateWithoutPOrCInput, AddressUncheckedCreateWithoutPOrCInput> | AddressCreateWithoutPOrCInput[] | AddressUncheckedCreateWithoutPOrCInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutPOrCInput | AddressCreateOrConnectWithoutPOrCInput[]
    createMany?: AddressCreateManyPOrCInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type COrMUncheckedCreateNestedManyWithoutPOrCInput = {
    create?: XOR<COrMCreateWithoutPOrCInput, COrMUncheckedCreateWithoutPOrCInput> | COrMCreateWithoutPOrCInput[] | COrMUncheckedCreateWithoutPOrCInput[]
    connectOrCreate?: COrMCreateOrConnectWithoutPOrCInput | COrMCreateOrConnectWithoutPOrCInput[]
    createMany?: COrMCreateManyPOrCInputEnvelope
    connect?: COrMWhereUniqueInput | COrMWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutPOrCInput = {
    create?: XOR<AddressCreateWithoutPOrCInput, AddressUncheckedCreateWithoutPOrCInput> | AddressCreateWithoutPOrCInput[] | AddressUncheckedCreateWithoutPOrCInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutPOrCInput | AddressCreateOrConnectWithoutPOrCInput[]
    createMany?: AddressCreateManyPOrCInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type RegionUpdateOneRequiredWithoutPOrCsNestedInput = {
    create?: XOR<RegionCreateWithoutPOrCsInput, RegionUncheckedCreateWithoutPOrCsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutPOrCsInput
    upsert?: RegionUpsertWithoutPOrCsInput
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutPOrCsInput, RegionUpdateWithoutPOrCsInput>, RegionUncheckedUpdateWithoutPOrCsInput>
  }

  export type COrMUpdateManyWithoutPOrCNestedInput = {
    create?: XOR<COrMCreateWithoutPOrCInput, COrMUncheckedCreateWithoutPOrCInput> | COrMCreateWithoutPOrCInput[] | COrMUncheckedCreateWithoutPOrCInput[]
    connectOrCreate?: COrMCreateOrConnectWithoutPOrCInput | COrMCreateOrConnectWithoutPOrCInput[]
    upsert?: COrMUpsertWithWhereUniqueWithoutPOrCInput | COrMUpsertWithWhereUniqueWithoutPOrCInput[]
    createMany?: COrMCreateManyPOrCInputEnvelope
    set?: COrMWhereUniqueInput | COrMWhereUniqueInput[]
    disconnect?: COrMWhereUniqueInput | COrMWhereUniqueInput[]
    delete?: COrMWhereUniqueInput | COrMWhereUniqueInput[]
    connect?: COrMWhereUniqueInput | COrMWhereUniqueInput[]
    update?: COrMUpdateWithWhereUniqueWithoutPOrCInput | COrMUpdateWithWhereUniqueWithoutPOrCInput[]
    updateMany?: COrMUpdateManyWithWhereWithoutPOrCInput | COrMUpdateManyWithWhereWithoutPOrCInput[]
    deleteMany?: COrMScalarWhereInput | COrMScalarWhereInput[]
  }

  export type AddressUpdateManyWithoutPOrCNestedInput = {
    create?: XOR<AddressCreateWithoutPOrCInput, AddressUncheckedCreateWithoutPOrCInput> | AddressCreateWithoutPOrCInput[] | AddressUncheckedCreateWithoutPOrCInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutPOrCInput | AddressCreateOrConnectWithoutPOrCInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutPOrCInput | AddressUpsertWithWhereUniqueWithoutPOrCInput[]
    createMany?: AddressCreateManyPOrCInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutPOrCInput | AddressUpdateWithWhereUniqueWithoutPOrCInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutPOrCInput | AddressUpdateManyWithWhereWithoutPOrCInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type COrMUncheckedUpdateManyWithoutPOrCNestedInput = {
    create?: XOR<COrMCreateWithoutPOrCInput, COrMUncheckedCreateWithoutPOrCInput> | COrMCreateWithoutPOrCInput[] | COrMUncheckedCreateWithoutPOrCInput[]
    connectOrCreate?: COrMCreateOrConnectWithoutPOrCInput | COrMCreateOrConnectWithoutPOrCInput[]
    upsert?: COrMUpsertWithWhereUniqueWithoutPOrCInput | COrMUpsertWithWhereUniqueWithoutPOrCInput[]
    createMany?: COrMCreateManyPOrCInputEnvelope
    set?: COrMWhereUniqueInput | COrMWhereUniqueInput[]
    disconnect?: COrMWhereUniqueInput | COrMWhereUniqueInput[]
    delete?: COrMWhereUniqueInput | COrMWhereUniqueInput[]
    connect?: COrMWhereUniqueInput | COrMWhereUniqueInput[]
    update?: COrMUpdateWithWhereUniqueWithoutPOrCInput | COrMUpdateWithWhereUniqueWithoutPOrCInput[]
    updateMany?: COrMUpdateManyWithWhereWithoutPOrCInput | COrMUpdateManyWithWhereWithoutPOrCInput[]
    deleteMany?: COrMScalarWhereInput | COrMScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutPOrCNestedInput = {
    create?: XOR<AddressCreateWithoutPOrCInput, AddressUncheckedCreateWithoutPOrCInput> | AddressCreateWithoutPOrCInput[] | AddressUncheckedCreateWithoutPOrCInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutPOrCInput | AddressCreateOrConnectWithoutPOrCInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutPOrCInput | AddressUpsertWithWhereUniqueWithoutPOrCInput[]
    createMany?: AddressCreateManyPOrCInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutPOrCInput | AddressUpdateWithWhereUniqueWithoutPOrCInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutPOrCInput | AddressUpdateManyWithWhereWithoutPOrCInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type POrCCreateNestedOneWithoutCOrMsInput = {
    create?: XOR<POrCCreateWithoutCOrMsInput, POrCUncheckedCreateWithoutCOrMsInput>
    connectOrCreate?: POrCCreateOrConnectWithoutCOrMsInput
    connect?: POrCWhereUniqueInput
  }

  export type BrgyCreateNestedManyWithoutCOrMInput = {
    create?: XOR<BrgyCreateWithoutCOrMInput, BrgyUncheckedCreateWithoutCOrMInput> | BrgyCreateWithoutCOrMInput[] | BrgyUncheckedCreateWithoutCOrMInput[]
    connectOrCreate?: BrgyCreateOrConnectWithoutCOrMInput | BrgyCreateOrConnectWithoutCOrMInput[]
    createMany?: BrgyCreateManyCOrMInputEnvelope
    connect?: BrgyWhereUniqueInput | BrgyWhereUniqueInput[]
  }

  export type AddressCreateNestedManyWithoutCOrMInput = {
    create?: XOR<AddressCreateWithoutCOrMInput, AddressUncheckedCreateWithoutCOrMInput> | AddressCreateWithoutCOrMInput[] | AddressUncheckedCreateWithoutCOrMInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCOrMInput | AddressCreateOrConnectWithoutCOrMInput[]
    createMany?: AddressCreateManyCOrMInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type BrgyUncheckedCreateNestedManyWithoutCOrMInput = {
    create?: XOR<BrgyCreateWithoutCOrMInput, BrgyUncheckedCreateWithoutCOrMInput> | BrgyCreateWithoutCOrMInput[] | BrgyUncheckedCreateWithoutCOrMInput[]
    connectOrCreate?: BrgyCreateOrConnectWithoutCOrMInput | BrgyCreateOrConnectWithoutCOrMInput[]
    createMany?: BrgyCreateManyCOrMInputEnvelope
    connect?: BrgyWhereUniqueInput | BrgyWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutCOrMInput = {
    create?: XOR<AddressCreateWithoutCOrMInput, AddressUncheckedCreateWithoutCOrMInput> | AddressCreateWithoutCOrMInput[] | AddressUncheckedCreateWithoutCOrMInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCOrMInput | AddressCreateOrConnectWithoutCOrMInput[]
    createMany?: AddressCreateManyCOrMInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type POrCUpdateOneRequiredWithoutCOrMsNestedInput = {
    create?: XOR<POrCCreateWithoutCOrMsInput, POrCUncheckedCreateWithoutCOrMsInput>
    connectOrCreate?: POrCCreateOrConnectWithoutCOrMsInput
    upsert?: POrCUpsertWithoutCOrMsInput
    connect?: POrCWhereUniqueInput
    update?: XOR<XOR<POrCUpdateToOneWithWhereWithoutCOrMsInput, POrCUpdateWithoutCOrMsInput>, POrCUncheckedUpdateWithoutCOrMsInput>
  }

  export type BrgyUpdateManyWithoutCOrMNestedInput = {
    create?: XOR<BrgyCreateWithoutCOrMInput, BrgyUncheckedCreateWithoutCOrMInput> | BrgyCreateWithoutCOrMInput[] | BrgyUncheckedCreateWithoutCOrMInput[]
    connectOrCreate?: BrgyCreateOrConnectWithoutCOrMInput | BrgyCreateOrConnectWithoutCOrMInput[]
    upsert?: BrgyUpsertWithWhereUniqueWithoutCOrMInput | BrgyUpsertWithWhereUniqueWithoutCOrMInput[]
    createMany?: BrgyCreateManyCOrMInputEnvelope
    set?: BrgyWhereUniqueInput | BrgyWhereUniqueInput[]
    disconnect?: BrgyWhereUniqueInput | BrgyWhereUniqueInput[]
    delete?: BrgyWhereUniqueInput | BrgyWhereUniqueInput[]
    connect?: BrgyWhereUniqueInput | BrgyWhereUniqueInput[]
    update?: BrgyUpdateWithWhereUniqueWithoutCOrMInput | BrgyUpdateWithWhereUniqueWithoutCOrMInput[]
    updateMany?: BrgyUpdateManyWithWhereWithoutCOrMInput | BrgyUpdateManyWithWhereWithoutCOrMInput[]
    deleteMany?: BrgyScalarWhereInput | BrgyScalarWhereInput[]
  }

  export type AddressUpdateManyWithoutCOrMNestedInput = {
    create?: XOR<AddressCreateWithoutCOrMInput, AddressUncheckedCreateWithoutCOrMInput> | AddressCreateWithoutCOrMInput[] | AddressUncheckedCreateWithoutCOrMInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCOrMInput | AddressCreateOrConnectWithoutCOrMInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutCOrMInput | AddressUpsertWithWhereUniqueWithoutCOrMInput[]
    createMany?: AddressCreateManyCOrMInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutCOrMInput | AddressUpdateWithWhereUniqueWithoutCOrMInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutCOrMInput | AddressUpdateManyWithWhereWithoutCOrMInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type BrgyUncheckedUpdateManyWithoutCOrMNestedInput = {
    create?: XOR<BrgyCreateWithoutCOrMInput, BrgyUncheckedCreateWithoutCOrMInput> | BrgyCreateWithoutCOrMInput[] | BrgyUncheckedCreateWithoutCOrMInput[]
    connectOrCreate?: BrgyCreateOrConnectWithoutCOrMInput | BrgyCreateOrConnectWithoutCOrMInput[]
    upsert?: BrgyUpsertWithWhereUniqueWithoutCOrMInput | BrgyUpsertWithWhereUniqueWithoutCOrMInput[]
    createMany?: BrgyCreateManyCOrMInputEnvelope
    set?: BrgyWhereUniqueInput | BrgyWhereUniqueInput[]
    disconnect?: BrgyWhereUniqueInput | BrgyWhereUniqueInput[]
    delete?: BrgyWhereUniqueInput | BrgyWhereUniqueInput[]
    connect?: BrgyWhereUniqueInput | BrgyWhereUniqueInput[]
    update?: BrgyUpdateWithWhereUniqueWithoutCOrMInput | BrgyUpdateWithWhereUniqueWithoutCOrMInput[]
    updateMany?: BrgyUpdateManyWithWhereWithoutCOrMInput | BrgyUpdateManyWithWhereWithoutCOrMInput[]
    deleteMany?: BrgyScalarWhereInput | BrgyScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutCOrMNestedInput = {
    create?: XOR<AddressCreateWithoutCOrMInput, AddressUncheckedCreateWithoutCOrMInput> | AddressCreateWithoutCOrMInput[] | AddressUncheckedCreateWithoutCOrMInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutCOrMInput | AddressCreateOrConnectWithoutCOrMInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutCOrMInput | AddressUpsertWithWhereUniqueWithoutCOrMInput[]
    createMany?: AddressCreateManyCOrMInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutCOrMInput | AddressUpdateWithWhereUniqueWithoutCOrMInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutCOrMInput | AddressUpdateManyWithWhereWithoutCOrMInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type COrMCreateNestedOneWithoutBrgysInput = {
    create?: XOR<COrMCreateWithoutBrgysInput, COrMUncheckedCreateWithoutBrgysInput>
    connectOrCreate?: COrMCreateOrConnectWithoutBrgysInput
    connect?: COrMWhereUniqueInput
  }

  export type AddressCreateNestedManyWithoutBrgyInput = {
    create?: XOR<AddressCreateWithoutBrgyInput, AddressUncheckedCreateWithoutBrgyInput> | AddressCreateWithoutBrgyInput[] | AddressUncheckedCreateWithoutBrgyInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutBrgyInput | AddressCreateOrConnectWithoutBrgyInput[]
    createMany?: AddressCreateManyBrgyInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutBrgyInput = {
    create?: XOR<AddressCreateWithoutBrgyInput, AddressUncheckedCreateWithoutBrgyInput> | AddressCreateWithoutBrgyInput[] | AddressUncheckedCreateWithoutBrgyInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutBrgyInput | AddressCreateOrConnectWithoutBrgyInput[]
    createMany?: AddressCreateManyBrgyInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type COrMUpdateOneRequiredWithoutBrgysNestedInput = {
    create?: XOR<COrMCreateWithoutBrgysInput, COrMUncheckedCreateWithoutBrgysInput>
    connectOrCreate?: COrMCreateOrConnectWithoutBrgysInput
    upsert?: COrMUpsertWithoutBrgysInput
    connect?: COrMWhereUniqueInput
    update?: XOR<XOR<COrMUpdateToOneWithWhereWithoutBrgysInput, COrMUpdateWithoutBrgysInput>, COrMUncheckedUpdateWithoutBrgysInput>
  }

  export type AddressUpdateManyWithoutBrgyNestedInput = {
    create?: XOR<AddressCreateWithoutBrgyInput, AddressUncheckedCreateWithoutBrgyInput> | AddressCreateWithoutBrgyInput[] | AddressUncheckedCreateWithoutBrgyInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutBrgyInput | AddressCreateOrConnectWithoutBrgyInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutBrgyInput | AddressUpsertWithWhereUniqueWithoutBrgyInput[]
    createMany?: AddressCreateManyBrgyInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutBrgyInput | AddressUpdateWithWhereUniqueWithoutBrgyInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutBrgyInput | AddressUpdateManyWithWhereWithoutBrgyInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutBrgyNestedInput = {
    create?: XOR<AddressCreateWithoutBrgyInput, AddressUncheckedCreateWithoutBrgyInput> | AddressCreateWithoutBrgyInput[] | AddressUncheckedCreateWithoutBrgyInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutBrgyInput | AddressCreateOrConnectWithoutBrgyInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutBrgyInput | AddressUpsertWithWhereUniqueWithoutBrgyInput[]
    createMany?: AddressCreateManyBrgyInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutBrgyInput | AddressUpdateWithWhereUniqueWithoutBrgyInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutBrgyInput | AddressUpdateManyWithWhereWithoutBrgyInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type RegionCreateNestedOneWithoutAddressesInput = {
    create?: XOR<RegionCreateWithoutAddressesInput, RegionUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: RegionCreateOrConnectWithoutAddressesInput
    connect?: RegionWhereUniqueInput
  }

  export type POrCCreateNestedOneWithoutAddressesInput = {
    create?: XOR<POrCCreateWithoutAddressesInput, POrCUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: POrCCreateOrConnectWithoutAddressesInput
    connect?: POrCWhereUniqueInput
  }

  export type COrMCreateNestedOneWithoutAddressesInput = {
    create?: XOR<COrMCreateWithoutAddressesInput, COrMUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: COrMCreateOrConnectWithoutAddressesInput
    connect?: COrMWhereUniqueInput
  }

  export type BrgyCreateNestedOneWithoutAddressesInput = {
    create?: XOR<BrgyCreateWithoutAddressesInput, BrgyUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: BrgyCreateOrConnectWithoutAddressesInput
    connect?: BrgyWhereUniqueInput
  }

  export type FacilityCreateNestedOneWithoutAddressInput = {
    create?: XOR<FacilityCreateWithoutAddressInput, FacilityUncheckedCreateWithoutAddressInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutAddressInput
    connect?: FacilityWhereUniqueInput
  }

  export type RegionUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<RegionCreateWithoutAddressesInput, RegionUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: RegionCreateOrConnectWithoutAddressesInput
    upsert?: RegionUpsertWithoutAddressesInput
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutAddressesInput, RegionUpdateWithoutAddressesInput>, RegionUncheckedUpdateWithoutAddressesInput>
  }

  export type POrCUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<POrCCreateWithoutAddressesInput, POrCUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: POrCCreateOrConnectWithoutAddressesInput
    upsert?: POrCUpsertWithoutAddressesInput
    connect?: POrCWhereUniqueInput
    update?: XOR<XOR<POrCUpdateToOneWithWhereWithoutAddressesInput, POrCUpdateWithoutAddressesInput>, POrCUncheckedUpdateWithoutAddressesInput>
  }

  export type COrMUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<COrMCreateWithoutAddressesInput, COrMUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: COrMCreateOrConnectWithoutAddressesInput
    upsert?: COrMUpsertWithoutAddressesInput
    connect?: COrMWhereUniqueInput
    update?: XOR<XOR<COrMUpdateToOneWithWhereWithoutAddressesInput, COrMUpdateWithoutAddressesInput>, COrMUncheckedUpdateWithoutAddressesInput>
  }

  export type BrgyUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<BrgyCreateWithoutAddressesInput, BrgyUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: BrgyCreateOrConnectWithoutAddressesInput
    upsert?: BrgyUpsertWithoutAddressesInput
    connect?: BrgyWhereUniqueInput
    update?: XOR<XOR<BrgyUpdateToOneWithWhereWithoutAddressesInput, BrgyUpdateWithoutAddressesInput>, BrgyUncheckedUpdateWithoutAddressesInput>
  }

  export type FacilityUpdateOneRequiredWithoutAddressNestedInput = {
    create?: XOR<FacilityCreateWithoutAddressInput, FacilityUncheckedCreateWithoutAddressInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutAddressInput
    upsert?: FacilityUpsertWithoutAddressInput
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutAddressInput, FacilityUpdateWithoutAddressInput>, FacilityUncheckedUpdateWithoutAddressInput>
  }

  export type FacilityCreateacceptedProvidersInput = {
    set: $Enums.Provider[]
  }

  export type AddressCreateNestedOneWithoutFacilityInput = {
    create?: XOR<AddressCreateWithoutFacilityInput, AddressUncheckedCreateWithoutFacilityInput>
    connectOrCreate?: AddressCreateOrConnectWithoutFacilityInput
    connect?: AddressWhereUniqueInput
  }

  export type ContactCreateNestedManyWithoutFacilityInput = {
    create?: XOR<ContactCreateWithoutFacilityInput, ContactUncheckedCreateWithoutFacilityInput> | ContactCreateWithoutFacilityInput[] | ContactUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutFacilityInput | ContactCreateOrConnectWithoutFacilityInput[]
    createMany?: ContactCreateManyFacilityInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ServiceCreateNestedManyWithoutFacilityInput = {
    create?: XOR<ServiceCreateWithoutFacilityInput, ServiceUncheckedCreateWithoutFacilityInput> | ServiceCreateWithoutFacilityInput[] | ServiceUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutFacilityInput | ServiceCreateOrConnectWithoutFacilityInput[]
    createMany?: ServiceCreateManyFacilityInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type EmployeeCreateNestedManyWithoutFacilityInput = {
    create?: XOR<EmployeeCreateWithoutFacilityInput, EmployeeUncheckedCreateWithoutFacilityInput> | EmployeeCreateWithoutFacilityInput[] | EmployeeUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutFacilityInput | EmployeeCreateOrConnectWithoutFacilityInput[]
    createMany?: EmployeeCreateManyFacilityInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type DivisionCreateNestedManyWithoutFacilityInput = {
    create?: XOR<DivisionCreateWithoutFacilityInput, DivisionUncheckedCreateWithoutFacilityInput> | DivisionCreateWithoutFacilityInput[] | DivisionUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: DivisionCreateOrConnectWithoutFacilityInput | DivisionCreateOrConnectWithoutFacilityInput[]
    createMany?: DivisionCreateManyFacilityInputEnvelope
    connect?: DivisionWhereUniqueInput | DivisionWhereUniqueInput[]
  }

  export type UpdateLogCreateNestedManyWithoutFacilityInput = {
    create?: XOR<UpdateLogCreateWithoutFacilityInput, UpdateLogUncheckedCreateWithoutFacilityInput> | UpdateLogCreateWithoutFacilityInput[] | UpdateLogUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: UpdateLogCreateOrConnectWithoutFacilityInput | UpdateLogCreateOrConnectWithoutFacilityInput[]
    createMany?: UpdateLogCreateManyFacilityInputEnvelope
    connect?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedOneWithoutFacilityInput = {
    create?: XOR<AddressCreateWithoutFacilityInput, AddressUncheckedCreateWithoutFacilityInput>
    connectOrCreate?: AddressCreateOrConnectWithoutFacilityInput
    connect?: AddressWhereUniqueInput
  }

  export type ContactUncheckedCreateNestedManyWithoutFacilityInput = {
    create?: XOR<ContactCreateWithoutFacilityInput, ContactUncheckedCreateWithoutFacilityInput> | ContactCreateWithoutFacilityInput[] | ContactUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutFacilityInput | ContactCreateOrConnectWithoutFacilityInput[]
    createMany?: ContactCreateManyFacilityInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutFacilityInput = {
    create?: XOR<ServiceCreateWithoutFacilityInput, ServiceUncheckedCreateWithoutFacilityInput> | ServiceCreateWithoutFacilityInput[] | ServiceUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutFacilityInput | ServiceCreateOrConnectWithoutFacilityInput[]
    createMany?: ServiceCreateManyFacilityInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutFacilityInput = {
    create?: XOR<EmployeeCreateWithoutFacilityInput, EmployeeUncheckedCreateWithoutFacilityInput> | EmployeeCreateWithoutFacilityInput[] | EmployeeUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutFacilityInput | EmployeeCreateOrConnectWithoutFacilityInput[]
    createMany?: EmployeeCreateManyFacilityInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type DivisionUncheckedCreateNestedManyWithoutFacilityInput = {
    create?: XOR<DivisionCreateWithoutFacilityInput, DivisionUncheckedCreateWithoutFacilityInput> | DivisionCreateWithoutFacilityInput[] | DivisionUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: DivisionCreateOrConnectWithoutFacilityInput | DivisionCreateOrConnectWithoutFacilityInput[]
    createMany?: DivisionCreateManyFacilityInputEnvelope
    connect?: DivisionWhereUniqueInput | DivisionWhereUniqueInput[]
  }

  export type UpdateLogUncheckedCreateNestedManyWithoutFacilityInput = {
    create?: XOR<UpdateLogCreateWithoutFacilityInput, UpdateLogUncheckedCreateWithoutFacilityInput> | UpdateLogCreateWithoutFacilityInput[] | UpdateLogUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: UpdateLogCreateOrConnectWithoutFacilityInput | UpdateLogCreateOrConnectWithoutFacilityInput[]
    createMany?: UpdateLogCreateManyFacilityInputEnvelope
    connect?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumFacilityTypeFieldUpdateOperationsInput = {
    set?: $Enums.FacilityType
  }

  export type EnumOwnershipFieldUpdateOperationsInput = {
    set?: $Enums.Ownership
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type FacilityUpdateacceptedProvidersInput = {
    set?: $Enums.Provider[]
    push?: $Enums.Provider | $Enums.Provider[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AddressUpdateOneWithoutFacilityNestedInput = {
    create?: XOR<AddressCreateWithoutFacilityInput, AddressUncheckedCreateWithoutFacilityInput>
    connectOrCreate?: AddressCreateOrConnectWithoutFacilityInput
    upsert?: AddressUpsertWithoutFacilityInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutFacilityInput, AddressUpdateWithoutFacilityInput>, AddressUncheckedUpdateWithoutFacilityInput>
  }

  export type ContactUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<ContactCreateWithoutFacilityInput, ContactUncheckedCreateWithoutFacilityInput> | ContactCreateWithoutFacilityInput[] | ContactUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutFacilityInput | ContactCreateOrConnectWithoutFacilityInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutFacilityInput | ContactUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: ContactCreateManyFacilityInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutFacilityInput | ContactUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutFacilityInput | ContactUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ServiceUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<ServiceCreateWithoutFacilityInput, ServiceUncheckedCreateWithoutFacilityInput> | ServiceCreateWithoutFacilityInput[] | ServiceUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutFacilityInput | ServiceCreateOrConnectWithoutFacilityInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutFacilityInput | ServiceUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: ServiceCreateManyFacilityInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutFacilityInput | ServiceUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutFacilityInput | ServiceUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type EmployeeUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<EmployeeCreateWithoutFacilityInput, EmployeeUncheckedCreateWithoutFacilityInput> | EmployeeCreateWithoutFacilityInput[] | EmployeeUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutFacilityInput | EmployeeCreateOrConnectWithoutFacilityInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutFacilityInput | EmployeeUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: EmployeeCreateManyFacilityInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutFacilityInput | EmployeeUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutFacilityInput | EmployeeUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type DivisionUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<DivisionCreateWithoutFacilityInput, DivisionUncheckedCreateWithoutFacilityInput> | DivisionCreateWithoutFacilityInput[] | DivisionUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: DivisionCreateOrConnectWithoutFacilityInput | DivisionCreateOrConnectWithoutFacilityInput[]
    upsert?: DivisionUpsertWithWhereUniqueWithoutFacilityInput | DivisionUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: DivisionCreateManyFacilityInputEnvelope
    set?: DivisionWhereUniqueInput | DivisionWhereUniqueInput[]
    disconnect?: DivisionWhereUniqueInput | DivisionWhereUniqueInput[]
    delete?: DivisionWhereUniqueInput | DivisionWhereUniqueInput[]
    connect?: DivisionWhereUniqueInput | DivisionWhereUniqueInput[]
    update?: DivisionUpdateWithWhereUniqueWithoutFacilityInput | DivisionUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: DivisionUpdateManyWithWhereWithoutFacilityInput | DivisionUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: DivisionScalarWhereInput | DivisionScalarWhereInput[]
  }

  export type UpdateLogUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<UpdateLogCreateWithoutFacilityInput, UpdateLogUncheckedCreateWithoutFacilityInput> | UpdateLogCreateWithoutFacilityInput[] | UpdateLogUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: UpdateLogCreateOrConnectWithoutFacilityInput | UpdateLogCreateOrConnectWithoutFacilityInput[]
    upsert?: UpdateLogUpsertWithWhereUniqueWithoutFacilityInput | UpdateLogUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: UpdateLogCreateManyFacilityInputEnvelope
    set?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
    disconnect?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
    delete?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
    connect?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
    update?: UpdateLogUpdateWithWhereUniqueWithoutFacilityInput | UpdateLogUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: UpdateLogUpdateManyWithWhereWithoutFacilityInput | UpdateLogUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: UpdateLogScalarWhereInput | UpdateLogScalarWhereInput[]
  }

  export type AddressUncheckedUpdateOneWithoutFacilityNestedInput = {
    create?: XOR<AddressCreateWithoutFacilityInput, AddressUncheckedCreateWithoutFacilityInput>
    connectOrCreate?: AddressCreateOrConnectWithoutFacilityInput
    upsert?: AddressUpsertWithoutFacilityInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutFacilityInput, AddressUpdateWithoutFacilityInput>, AddressUncheckedUpdateWithoutFacilityInput>
  }

  export type ContactUncheckedUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<ContactCreateWithoutFacilityInput, ContactUncheckedCreateWithoutFacilityInput> | ContactCreateWithoutFacilityInput[] | ContactUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutFacilityInput | ContactCreateOrConnectWithoutFacilityInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutFacilityInput | ContactUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: ContactCreateManyFacilityInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutFacilityInput | ContactUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutFacilityInput | ContactUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<ServiceCreateWithoutFacilityInput, ServiceUncheckedCreateWithoutFacilityInput> | ServiceCreateWithoutFacilityInput[] | ServiceUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutFacilityInput | ServiceCreateOrConnectWithoutFacilityInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutFacilityInput | ServiceUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: ServiceCreateManyFacilityInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutFacilityInput | ServiceUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutFacilityInput | ServiceUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<EmployeeCreateWithoutFacilityInput, EmployeeUncheckedCreateWithoutFacilityInput> | EmployeeCreateWithoutFacilityInput[] | EmployeeUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutFacilityInput | EmployeeCreateOrConnectWithoutFacilityInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutFacilityInput | EmployeeUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: EmployeeCreateManyFacilityInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutFacilityInput | EmployeeUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutFacilityInput | EmployeeUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type DivisionUncheckedUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<DivisionCreateWithoutFacilityInput, DivisionUncheckedCreateWithoutFacilityInput> | DivisionCreateWithoutFacilityInput[] | DivisionUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: DivisionCreateOrConnectWithoutFacilityInput | DivisionCreateOrConnectWithoutFacilityInput[]
    upsert?: DivisionUpsertWithWhereUniqueWithoutFacilityInput | DivisionUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: DivisionCreateManyFacilityInputEnvelope
    set?: DivisionWhereUniqueInput | DivisionWhereUniqueInput[]
    disconnect?: DivisionWhereUniqueInput | DivisionWhereUniqueInput[]
    delete?: DivisionWhereUniqueInput | DivisionWhereUniqueInput[]
    connect?: DivisionWhereUniqueInput | DivisionWhereUniqueInput[]
    update?: DivisionUpdateWithWhereUniqueWithoutFacilityInput | DivisionUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: DivisionUpdateManyWithWhereWithoutFacilityInput | DivisionUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: DivisionScalarWhereInput | DivisionScalarWhereInput[]
  }

  export type UpdateLogUncheckedUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<UpdateLogCreateWithoutFacilityInput, UpdateLogUncheckedCreateWithoutFacilityInput> | UpdateLogCreateWithoutFacilityInput[] | UpdateLogUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: UpdateLogCreateOrConnectWithoutFacilityInput | UpdateLogCreateOrConnectWithoutFacilityInput[]
    upsert?: UpdateLogUpsertWithWhereUniqueWithoutFacilityInput | UpdateLogUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: UpdateLogCreateManyFacilityInputEnvelope
    set?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
    disconnect?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
    delete?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
    connect?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
    update?: UpdateLogUpdateWithWhereUniqueWithoutFacilityInput | UpdateLogUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: UpdateLogUpdateManyWithWhereWithoutFacilityInput | UpdateLogUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: UpdateLogScalarWhereInput | UpdateLogScalarWhereInput[]
  }

  export type ContactCreateNestedManyWithoutDivisionInput = {
    create?: XOR<ContactCreateWithoutDivisionInput, ContactUncheckedCreateWithoutDivisionInput> | ContactCreateWithoutDivisionInput[] | ContactUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutDivisionInput | ContactCreateOrConnectWithoutDivisionInput[]
    createMany?: ContactCreateManyDivisionInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type FacilityCreateNestedOneWithoutDivisionsInput = {
    create?: XOR<FacilityCreateWithoutDivisionsInput, FacilityUncheckedCreateWithoutDivisionsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutDivisionsInput
    connect?: FacilityWhereUniqueInput
  }

  export type ServiceCreateNestedManyWithoutDivisionInput = {
    create?: XOR<ServiceCreateWithoutDivisionInput, ServiceUncheckedCreateWithoutDivisionInput> | ServiceCreateWithoutDivisionInput[] | ServiceUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutDivisionInput | ServiceCreateOrConnectWithoutDivisionInput[]
    createMany?: ServiceCreateManyDivisionInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type EmployeeCreateNestedManyWithoutDivisionsInput = {
    create?: XOR<EmployeeCreateWithoutDivisionsInput, EmployeeUncheckedCreateWithoutDivisionsInput> | EmployeeCreateWithoutDivisionsInput[] | EmployeeUncheckedCreateWithoutDivisionsInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDivisionsInput | EmployeeCreateOrConnectWithoutDivisionsInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type UpdateLogCreateNestedManyWithoutDivisionInput = {
    create?: XOR<UpdateLogCreateWithoutDivisionInput, UpdateLogUncheckedCreateWithoutDivisionInput> | UpdateLogCreateWithoutDivisionInput[] | UpdateLogUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: UpdateLogCreateOrConnectWithoutDivisionInput | UpdateLogCreateOrConnectWithoutDivisionInput[]
    createMany?: UpdateLogCreateManyDivisionInputEnvelope
    connect?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutDivisionInput = {
    create?: XOR<ContactCreateWithoutDivisionInput, ContactUncheckedCreateWithoutDivisionInput> | ContactCreateWithoutDivisionInput[] | ContactUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutDivisionInput | ContactCreateOrConnectWithoutDivisionInput[]
    createMany?: ContactCreateManyDivisionInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutDivisionInput = {
    create?: XOR<ServiceCreateWithoutDivisionInput, ServiceUncheckedCreateWithoutDivisionInput> | ServiceCreateWithoutDivisionInput[] | ServiceUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutDivisionInput | ServiceCreateOrConnectWithoutDivisionInput[]
    createMany?: ServiceCreateManyDivisionInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutDivisionsInput = {
    create?: XOR<EmployeeCreateWithoutDivisionsInput, EmployeeUncheckedCreateWithoutDivisionsInput> | EmployeeCreateWithoutDivisionsInput[] | EmployeeUncheckedCreateWithoutDivisionsInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDivisionsInput | EmployeeCreateOrConnectWithoutDivisionsInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type UpdateLogUncheckedCreateNestedManyWithoutDivisionInput = {
    create?: XOR<UpdateLogCreateWithoutDivisionInput, UpdateLogUncheckedCreateWithoutDivisionInput> | UpdateLogCreateWithoutDivisionInput[] | UpdateLogUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: UpdateLogCreateOrConnectWithoutDivisionInput | UpdateLogCreateOrConnectWithoutDivisionInput[]
    createMany?: UpdateLogCreateManyDivisionInputEnvelope
    connect?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
  }

  export type ContactUpdateManyWithoutDivisionNestedInput = {
    create?: XOR<ContactCreateWithoutDivisionInput, ContactUncheckedCreateWithoutDivisionInput> | ContactCreateWithoutDivisionInput[] | ContactUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutDivisionInput | ContactCreateOrConnectWithoutDivisionInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutDivisionInput | ContactUpsertWithWhereUniqueWithoutDivisionInput[]
    createMany?: ContactCreateManyDivisionInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutDivisionInput | ContactUpdateWithWhereUniqueWithoutDivisionInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutDivisionInput | ContactUpdateManyWithWhereWithoutDivisionInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type FacilityUpdateOneRequiredWithoutDivisionsNestedInput = {
    create?: XOR<FacilityCreateWithoutDivisionsInput, FacilityUncheckedCreateWithoutDivisionsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutDivisionsInput
    upsert?: FacilityUpsertWithoutDivisionsInput
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutDivisionsInput, FacilityUpdateWithoutDivisionsInput>, FacilityUncheckedUpdateWithoutDivisionsInput>
  }

  export type ServiceUpdateManyWithoutDivisionNestedInput = {
    create?: XOR<ServiceCreateWithoutDivisionInput, ServiceUncheckedCreateWithoutDivisionInput> | ServiceCreateWithoutDivisionInput[] | ServiceUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutDivisionInput | ServiceCreateOrConnectWithoutDivisionInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutDivisionInput | ServiceUpsertWithWhereUniqueWithoutDivisionInput[]
    createMany?: ServiceCreateManyDivisionInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutDivisionInput | ServiceUpdateWithWhereUniqueWithoutDivisionInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutDivisionInput | ServiceUpdateManyWithWhereWithoutDivisionInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type EmployeeUpdateManyWithoutDivisionsNestedInput = {
    create?: XOR<EmployeeCreateWithoutDivisionsInput, EmployeeUncheckedCreateWithoutDivisionsInput> | EmployeeCreateWithoutDivisionsInput[] | EmployeeUncheckedCreateWithoutDivisionsInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDivisionsInput | EmployeeCreateOrConnectWithoutDivisionsInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutDivisionsInput | EmployeeUpsertWithWhereUniqueWithoutDivisionsInput[]
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutDivisionsInput | EmployeeUpdateWithWhereUniqueWithoutDivisionsInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutDivisionsInput | EmployeeUpdateManyWithWhereWithoutDivisionsInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type UpdateLogUpdateManyWithoutDivisionNestedInput = {
    create?: XOR<UpdateLogCreateWithoutDivisionInput, UpdateLogUncheckedCreateWithoutDivisionInput> | UpdateLogCreateWithoutDivisionInput[] | UpdateLogUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: UpdateLogCreateOrConnectWithoutDivisionInput | UpdateLogCreateOrConnectWithoutDivisionInput[]
    upsert?: UpdateLogUpsertWithWhereUniqueWithoutDivisionInput | UpdateLogUpsertWithWhereUniqueWithoutDivisionInput[]
    createMany?: UpdateLogCreateManyDivisionInputEnvelope
    set?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
    disconnect?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
    delete?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
    connect?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
    update?: UpdateLogUpdateWithWhereUniqueWithoutDivisionInput | UpdateLogUpdateWithWhereUniqueWithoutDivisionInput[]
    updateMany?: UpdateLogUpdateManyWithWhereWithoutDivisionInput | UpdateLogUpdateManyWithWhereWithoutDivisionInput[]
    deleteMany?: UpdateLogScalarWhereInput | UpdateLogScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutDivisionNestedInput = {
    create?: XOR<ContactCreateWithoutDivisionInput, ContactUncheckedCreateWithoutDivisionInput> | ContactCreateWithoutDivisionInput[] | ContactUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutDivisionInput | ContactCreateOrConnectWithoutDivisionInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutDivisionInput | ContactUpsertWithWhereUniqueWithoutDivisionInput[]
    createMany?: ContactCreateManyDivisionInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutDivisionInput | ContactUpdateWithWhereUniqueWithoutDivisionInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutDivisionInput | ContactUpdateManyWithWhereWithoutDivisionInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutDivisionNestedInput = {
    create?: XOR<ServiceCreateWithoutDivisionInput, ServiceUncheckedCreateWithoutDivisionInput> | ServiceCreateWithoutDivisionInput[] | ServiceUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutDivisionInput | ServiceCreateOrConnectWithoutDivisionInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutDivisionInput | ServiceUpsertWithWhereUniqueWithoutDivisionInput[]
    createMany?: ServiceCreateManyDivisionInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutDivisionInput | ServiceUpdateWithWhereUniqueWithoutDivisionInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutDivisionInput | ServiceUpdateManyWithWhereWithoutDivisionInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutDivisionsNestedInput = {
    create?: XOR<EmployeeCreateWithoutDivisionsInput, EmployeeUncheckedCreateWithoutDivisionsInput> | EmployeeCreateWithoutDivisionsInput[] | EmployeeUncheckedCreateWithoutDivisionsInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDivisionsInput | EmployeeCreateOrConnectWithoutDivisionsInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutDivisionsInput | EmployeeUpsertWithWhereUniqueWithoutDivisionsInput[]
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutDivisionsInput | EmployeeUpdateWithWhereUniqueWithoutDivisionsInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutDivisionsInput | EmployeeUpdateManyWithWhereWithoutDivisionsInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type UpdateLogUncheckedUpdateManyWithoutDivisionNestedInput = {
    create?: XOR<UpdateLogCreateWithoutDivisionInput, UpdateLogUncheckedCreateWithoutDivisionInput> | UpdateLogCreateWithoutDivisionInput[] | UpdateLogUncheckedCreateWithoutDivisionInput[]
    connectOrCreate?: UpdateLogCreateOrConnectWithoutDivisionInput | UpdateLogCreateOrConnectWithoutDivisionInput[]
    upsert?: UpdateLogUpsertWithWhereUniqueWithoutDivisionInput | UpdateLogUpsertWithWhereUniqueWithoutDivisionInput[]
    createMany?: UpdateLogCreateManyDivisionInputEnvelope
    set?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
    disconnect?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
    delete?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
    connect?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
    update?: UpdateLogUpdateWithWhereUniqueWithoutDivisionInput | UpdateLogUpdateWithWhereUniqueWithoutDivisionInput[]
    updateMany?: UpdateLogUpdateManyWithWhereWithoutDivisionInput | UpdateLogUpdateManyWithWhereWithoutDivisionInput[]
    deleteMany?: UpdateLogScalarWhereInput | UpdateLogScalarWhereInput[]
  }

  export type SessionCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<SessionCreateWithoutEmployeeInput, SessionUncheckedCreateWithoutEmployeeInput> | SessionCreateWithoutEmployeeInput[] | SessionUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutEmployeeInput | SessionCreateOrConnectWithoutEmployeeInput[]
    createMany?: SessionCreateManyEmployeeInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type FacilityCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<FacilityCreateWithoutEmployeesInput, FacilityUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutEmployeesInput
    connect?: FacilityWhereUniqueInput
  }

  export type DivisionCreateNestedManyWithoutAdminsInput = {
    create?: XOR<DivisionCreateWithoutAdminsInput, DivisionUncheckedCreateWithoutAdminsInput> | DivisionCreateWithoutAdminsInput[] | DivisionUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: DivisionCreateOrConnectWithoutAdminsInput | DivisionCreateOrConnectWithoutAdminsInput[]
    connect?: DivisionWhereUniqueInput | DivisionWhereUniqueInput[]
  }

  export type UpdateLogCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<UpdateLogCreateWithoutEmployeeInput, UpdateLogUncheckedCreateWithoutEmployeeInput> | UpdateLogCreateWithoutEmployeeInput[] | UpdateLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: UpdateLogCreateOrConnectWithoutEmployeeInput | UpdateLogCreateOrConnectWithoutEmployeeInput[]
    createMany?: UpdateLogCreateManyEmployeeInputEnvelope
    connect?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<SessionCreateWithoutEmployeeInput, SessionUncheckedCreateWithoutEmployeeInput> | SessionCreateWithoutEmployeeInput[] | SessionUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutEmployeeInput | SessionCreateOrConnectWithoutEmployeeInput[]
    createMany?: SessionCreateManyEmployeeInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type DivisionUncheckedCreateNestedManyWithoutAdminsInput = {
    create?: XOR<DivisionCreateWithoutAdminsInput, DivisionUncheckedCreateWithoutAdminsInput> | DivisionCreateWithoutAdminsInput[] | DivisionUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: DivisionCreateOrConnectWithoutAdminsInput | DivisionCreateOrConnectWithoutAdminsInput[]
    connect?: DivisionWhereUniqueInput | DivisionWhereUniqueInput[]
  }

  export type UpdateLogUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<UpdateLogCreateWithoutEmployeeInput, UpdateLogUncheckedCreateWithoutEmployeeInput> | UpdateLogCreateWithoutEmployeeInput[] | UpdateLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: UpdateLogCreateOrConnectWithoutEmployeeInput | UpdateLogCreateOrConnectWithoutEmployeeInput[]
    createMany?: UpdateLogCreateManyEmployeeInputEnvelope
    connect?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type SessionUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<SessionCreateWithoutEmployeeInput, SessionUncheckedCreateWithoutEmployeeInput> | SessionCreateWithoutEmployeeInput[] | SessionUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutEmployeeInput | SessionCreateOrConnectWithoutEmployeeInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutEmployeeInput | SessionUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: SessionCreateManyEmployeeInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutEmployeeInput | SessionUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutEmployeeInput | SessionUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type FacilityUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<FacilityCreateWithoutEmployeesInput, FacilityUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutEmployeesInput
    upsert?: FacilityUpsertWithoutEmployeesInput
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutEmployeesInput, FacilityUpdateWithoutEmployeesInput>, FacilityUncheckedUpdateWithoutEmployeesInput>
  }

  export type DivisionUpdateManyWithoutAdminsNestedInput = {
    create?: XOR<DivisionCreateWithoutAdminsInput, DivisionUncheckedCreateWithoutAdminsInput> | DivisionCreateWithoutAdminsInput[] | DivisionUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: DivisionCreateOrConnectWithoutAdminsInput | DivisionCreateOrConnectWithoutAdminsInput[]
    upsert?: DivisionUpsertWithWhereUniqueWithoutAdminsInput | DivisionUpsertWithWhereUniqueWithoutAdminsInput[]
    set?: DivisionWhereUniqueInput | DivisionWhereUniqueInput[]
    disconnect?: DivisionWhereUniqueInput | DivisionWhereUniqueInput[]
    delete?: DivisionWhereUniqueInput | DivisionWhereUniqueInput[]
    connect?: DivisionWhereUniqueInput | DivisionWhereUniqueInput[]
    update?: DivisionUpdateWithWhereUniqueWithoutAdminsInput | DivisionUpdateWithWhereUniqueWithoutAdminsInput[]
    updateMany?: DivisionUpdateManyWithWhereWithoutAdminsInput | DivisionUpdateManyWithWhereWithoutAdminsInput[]
    deleteMany?: DivisionScalarWhereInput | DivisionScalarWhereInput[]
  }

  export type UpdateLogUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<UpdateLogCreateWithoutEmployeeInput, UpdateLogUncheckedCreateWithoutEmployeeInput> | UpdateLogCreateWithoutEmployeeInput[] | UpdateLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: UpdateLogCreateOrConnectWithoutEmployeeInput | UpdateLogCreateOrConnectWithoutEmployeeInput[]
    upsert?: UpdateLogUpsertWithWhereUniqueWithoutEmployeeInput | UpdateLogUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: UpdateLogCreateManyEmployeeInputEnvelope
    set?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
    disconnect?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
    delete?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
    connect?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
    update?: UpdateLogUpdateWithWhereUniqueWithoutEmployeeInput | UpdateLogUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: UpdateLogUpdateManyWithWhereWithoutEmployeeInput | UpdateLogUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: UpdateLogScalarWhereInput | UpdateLogScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<SessionCreateWithoutEmployeeInput, SessionUncheckedCreateWithoutEmployeeInput> | SessionCreateWithoutEmployeeInput[] | SessionUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutEmployeeInput | SessionCreateOrConnectWithoutEmployeeInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutEmployeeInput | SessionUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: SessionCreateManyEmployeeInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutEmployeeInput | SessionUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutEmployeeInput | SessionUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type DivisionUncheckedUpdateManyWithoutAdminsNestedInput = {
    create?: XOR<DivisionCreateWithoutAdminsInput, DivisionUncheckedCreateWithoutAdminsInput> | DivisionCreateWithoutAdminsInput[] | DivisionUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: DivisionCreateOrConnectWithoutAdminsInput | DivisionCreateOrConnectWithoutAdminsInput[]
    upsert?: DivisionUpsertWithWhereUniqueWithoutAdminsInput | DivisionUpsertWithWhereUniqueWithoutAdminsInput[]
    set?: DivisionWhereUniqueInput | DivisionWhereUniqueInput[]
    disconnect?: DivisionWhereUniqueInput | DivisionWhereUniqueInput[]
    delete?: DivisionWhereUniqueInput | DivisionWhereUniqueInput[]
    connect?: DivisionWhereUniqueInput | DivisionWhereUniqueInput[]
    update?: DivisionUpdateWithWhereUniqueWithoutAdminsInput | DivisionUpdateWithWhereUniqueWithoutAdminsInput[]
    updateMany?: DivisionUpdateManyWithWhereWithoutAdminsInput | DivisionUpdateManyWithWhereWithoutAdminsInput[]
    deleteMany?: DivisionScalarWhereInput | DivisionScalarWhereInput[]
  }

  export type UpdateLogUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<UpdateLogCreateWithoutEmployeeInput, UpdateLogUncheckedCreateWithoutEmployeeInput> | UpdateLogCreateWithoutEmployeeInput[] | UpdateLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: UpdateLogCreateOrConnectWithoutEmployeeInput | UpdateLogCreateOrConnectWithoutEmployeeInput[]
    upsert?: UpdateLogUpsertWithWhereUniqueWithoutEmployeeInput | UpdateLogUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: UpdateLogCreateManyEmployeeInputEnvelope
    set?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
    disconnect?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
    delete?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
    connect?: UpdateLogWhereUniqueInput | UpdateLogWhereUniqueInput[]
    update?: UpdateLogUpdateWithWhereUniqueWithoutEmployeeInput | UpdateLogUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: UpdateLogUpdateManyWithWhereWithoutEmployeeInput | UpdateLogUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: UpdateLogScalarWhereInput | UpdateLogScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutSessionsInput = {
    create?: XOR<EmployeeCreateWithoutSessionsInput, EmployeeUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutSessionsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<EmployeeCreateWithoutSessionsInput, EmployeeUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutSessionsInput
    upsert?: EmployeeUpsertWithoutSessionsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutSessionsInput, EmployeeUpdateWithoutSessionsInput>, EmployeeUncheckedUpdateWithoutSessionsInput>
  }

  export type ServiceCreatekeywordsInput = {
    set: string[]
  }

  export type ContactCreateNestedManyWithoutServiceInput = {
    create?: XOR<ContactCreateWithoutServiceInput, ContactUncheckedCreateWithoutServiceInput> | ContactCreateWithoutServiceInput[] | ContactUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutServiceInput | ContactCreateOrConnectWithoutServiceInput[]
    createMany?: ContactCreateManyServiceInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type FacilityCreateNestedOneWithoutServicesInput = {
    create?: XOR<FacilityCreateWithoutServicesInput, FacilityUncheckedCreateWithoutServicesInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutServicesInput
    connect?: FacilityWhereUniqueInput
  }

  export type DivisionCreateNestedOneWithoutServicesInput = {
    create?: XOR<DivisionCreateWithoutServicesInput, DivisionUncheckedCreateWithoutServicesInput>
    connectOrCreate?: DivisionCreateOrConnectWithoutServicesInput
    connect?: DivisionWhereUniqueInput
  }

  export type AmbulanceServiceCreateNestedOneWithoutServiceInput = {
    create?: XOR<AmbulanceServiceCreateWithoutServiceInput, AmbulanceServiceUncheckedCreateWithoutServiceInput>
    connectOrCreate?: AmbulanceServiceCreateOrConnectWithoutServiceInput
    connect?: AmbulanceServiceWhereUniqueInput
  }

  export type BloodBankServiceCreateNestedOneWithoutServiceInput = {
    create?: XOR<BloodBankServiceCreateWithoutServiceInput, BloodBankServiceUncheckedCreateWithoutServiceInput>
    connectOrCreate?: BloodBankServiceCreateOrConnectWithoutServiceInput
    connect?: BloodBankServiceWhereUniqueInput
  }

  export type ERServiceCreateNestedOneWithoutServiceInput = {
    create?: XOR<ERServiceCreateWithoutServiceInput, ERServiceUncheckedCreateWithoutServiceInput>
    connectOrCreate?: ERServiceCreateOrConnectWithoutServiceInput
    connect?: ERServiceWhereUniqueInput
  }

  export type ICUServiceCreateNestedOneWithoutServiceInput = {
    create?: XOR<ICUServiceCreateWithoutServiceInput, ICUServiceUncheckedCreateWithoutServiceInput>
    connectOrCreate?: ICUServiceCreateOrConnectWithoutServiceInput
    connect?: ICUServiceWhereUniqueInput
  }

  export type OutpatientServiceCreateNestedOneWithoutServiceInput = {
    create?: XOR<OutpatientServiceCreateWithoutServiceInput, OutpatientServiceUncheckedCreateWithoutServiceInput>
    connectOrCreate?: OutpatientServiceCreateOrConnectWithoutServiceInput
    connect?: OutpatientServiceWhereUniqueInput
  }

  export type ContactUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ContactCreateWithoutServiceInput, ContactUncheckedCreateWithoutServiceInput> | ContactCreateWithoutServiceInput[] | ContactUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutServiceInput | ContactCreateOrConnectWithoutServiceInput[]
    createMany?: ContactCreateManyServiceInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type AmbulanceServiceUncheckedCreateNestedOneWithoutServiceInput = {
    create?: XOR<AmbulanceServiceCreateWithoutServiceInput, AmbulanceServiceUncheckedCreateWithoutServiceInput>
    connectOrCreate?: AmbulanceServiceCreateOrConnectWithoutServiceInput
    connect?: AmbulanceServiceWhereUniqueInput
  }

  export type BloodBankServiceUncheckedCreateNestedOneWithoutServiceInput = {
    create?: XOR<BloodBankServiceCreateWithoutServiceInput, BloodBankServiceUncheckedCreateWithoutServiceInput>
    connectOrCreate?: BloodBankServiceCreateOrConnectWithoutServiceInput
    connect?: BloodBankServiceWhereUniqueInput
  }

  export type ERServiceUncheckedCreateNestedOneWithoutServiceInput = {
    create?: XOR<ERServiceCreateWithoutServiceInput, ERServiceUncheckedCreateWithoutServiceInput>
    connectOrCreate?: ERServiceCreateOrConnectWithoutServiceInput
    connect?: ERServiceWhereUniqueInput
  }

  export type ICUServiceUncheckedCreateNestedOneWithoutServiceInput = {
    create?: XOR<ICUServiceCreateWithoutServiceInput, ICUServiceUncheckedCreateWithoutServiceInput>
    connectOrCreate?: ICUServiceCreateOrConnectWithoutServiceInput
    connect?: ICUServiceWhereUniqueInput
  }

  export type OutpatientServiceUncheckedCreateNestedOneWithoutServiceInput = {
    create?: XOR<OutpatientServiceCreateWithoutServiceInput, OutpatientServiceUncheckedCreateWithoutServiceInput>
    connectOrCreate?: OutpatientServiceCreateOrConnectWithoutServiceInput
    connect?: OutpatientServiceWhereUniqueInput
  }

  export type ServiceUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ContactUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ContactCreateWithoutServiceInput, ContactUncheckedCreateWithoutServiceInput> | ContactCreateWithoutServiceInput[] | ContactUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutServiceInput | ContactCreateOrConnectWithoutServiceInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutServiceInput | ContactUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ContactCreateManyServiceInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutServiceInput | ContactUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutServiceInput | ContactUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type FacilityUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<FacilityCreateWithoutServicesInput, FacilityUncheckedCreateWithoutServicesInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutServicesInput
    upsert?: FacilityUpsertWithoutServicesInput
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutServicesInput, FacilityUpdateWithoutServicesInput>, FacilityUncheckedUpdateWithoutServicesInput>
  }

  export type DivisionUpdateOneWithoutServicesNestedInput = {
    create?: XOR<DivisionCreateWithoutServicesInput, DivisionUncheckedCreateWithoutServicesInput>
    connectOrCreate?: DivisionCreateOrConnectWithoutServicesInput
    upsert?: DivisionUpsertWithoutServicesInput
    disconnect?: DivisionWhereInput | boolean
    delete?: DivisionWhereInput | boolean
    connect?: DivisionWhereUniqueInput
    update?: XOR<XOR<DivisionUpdateToOneWithWhereWithoutServicesInput, DivisionUpdateWithoutServicesInput>, DivisionUncheckedUpdateWithoutServicesInput>
  }

  export type AmbulanceServiceUpdateOneWithoutServiceNestedInput = {
    create?: XOR<AmbulanceServiceCreateWithoutServiceInput, AmbulanceServiceUncheckedCreateWithoutServiceInput>
    connectOrCreate?: AmbulanceServiceCreateOrConnectWithoutServiceInput
    upsert?: AmbulanceServiceUpsertWithoutServiceInput
    disconnect?: AmbulanceServiceWhereInput | boolean
    delete?: AmbulanceServiceWhereInput | boolean
    connect?: AmbulanceServiceWhereUniqueInput
    update?: XOR<XOR<AmbulanceServiceUpdateToOneWithWhereWithoutServiceInput, AmbulanceServiceUpdateWithoutServiceInput>, AmbulanceServiceUncheckedUpdateWithoutServiceInput>
  }

  export type BloodBankServiceUpdateOneWithoutServiceNestedInput = {
    create?: XOR<BloodBankServiceCreateWithoutServiceInput, BloodBankServiceUncheckedCreateWithoutServiceInput>
    connectOrCreate?: BloodBankServiceCreateOrConnectWithoutServiceInput
    upsert?: BloodBankServiceUpsertWithoutServiceInput
    disconnect?: BloodBankServiceWhereInput | boolean
    delete?: BloodBankServiceWhereInput | boolean
    connect?: BloodBankServiceWhereUniqueInput
    update?: XOR<XOR<BloodBankServiceUpdateToOneWithWhereWithoutServiceInput, BloodBankServiceUpdateWithoutServiceInput>, BloodBankServiceUncheckedUpdateWithoutServiceInput>
  }

  export type ERServiceUpdateOneWithoutServiceNestedInput = {
    create?: XOR<ERServiceCreateWithoutServiceInput, ERServiceUncheckedCreateWithoutServiceInput>
    connectOrCreate?: ERServiceCreateOrConnectWithoutServiceInput
    upsert?: ERServiceUpsertWithoutServiceInput
    disconnect?: ERServiceWhereInput | boolean
    delete?: ERServiceWhereInput | boolean
    connect?: ERServiceWhereUniqueInput
    update?: XOR<XOR<ERServiceUpdateToOneWithWhereWithoutServiceInput, ERServiceUpdateWithoutServiceInput>, ERServiceUncheckedUpdateWithoutServiceInput>
  }

  export type ICUServiceUpdateOneWithoutServiceNestedInput = {
    create?: XOR<ICUServiceCreateWithoutServiceInput, ICUServiceUncheckedCreateWithoutServiceInput>
    connectOrCreate?: ICUServiceCreateOrConnectWithoutServiceInput
    upsert?: ICUServiceUpsertWithoutServiceInput
    disconnect?: ICUServiceWhereInput | boolean
    delete?: ICUServiceWhereInput | boolean
    connect?: ICUServiceWhereUniqueInput
    update?: XOR<XOR<ICUServiceUpdateToOneWithWhereWithoutServiceInput, ICUServiceUpdateWithoutServiceInput>, ICUServiceUncheckedUpdateWithoutServiceInput>
  }

  export type OutpatientServiceUpdateOneWithoutServiceNestedInput = {
    create?: XOR<OutpatientServiceCreateWithoutServiceInput, OutpatientServiceUncheckedCreateWithoutServiceInput>
    connectOrCreate?: OutpatientServiceCreateOrConnectWithoutServiceInput
    upsert?: OutpatientServiceUpsertWithoutServiceInput
    disconnect?: OutpatientServiceWhereInput | boolean
    delete?: OutpatientServiceWhereInput | boolean
    connect?: OutpatientServiceWhereUniqueInput
    update?: XOR<XOR<OutpatientServiceUpdateToOneWithWhereWithoutServiceInput, OutpatientServiceUpdateWithoutServiceInput>, OutpatientServiceUncheckedUpdateWithoutServiceInput>
  }

  export type ContactUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ContactCreateWithoutServiceInput, ContactUncheckedCreateWithoutServiceInput> | ContactCreateWithoutServiceInput[] | ContactUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutServiceInput | ContactCreateOrConnectWithoutServiceInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutServiceInput | ContactUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ContactCreateManyServiceInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutServiceInput | ContactUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutServiceInput | ContactUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type AmbulanceServiceUncheckedUpdateOneWithoutServiceNestedInput = {
    create?: XOR<AmbulanceServiceCreateWithoutServiceInput, AmbulanceServiceUncheckedCreateWithoutServiceInput>
    connectOrCreate?: AmbulanceServiceCreateOrConnectWithoutServiceInput
    upsert?: AmbulanceServiceUpsertWithoutServiceInput
    disconnect?: AmbulanceServiceWhereInput | boolean
    delete?: AmbulanceServiceWhereInput | boolean
    connect?: AmbulanceServiceWhereUniqueInput
    update?: XOR<XOR<AmbulanceServiceUpdateToOneWithWhereWithoutServiceInput, AmbulanceServiceUpdateWithoutServiceInput>, AmbulanceServiceUncheckedUpdateWithoutServiceInput>
  }

  export type BloodBankServiceUncheckedUpdateOneWithoutServiceNestedInput = {
    create?: XOR<BloodBankServiceCreateWithoutServiceInput, BloodBankServiceUncheckedCreateWithoutServiceInput>
    connectOrCreate?: BloodBankServiceCreateOrConnectWithoutServiceInput
    upsert?: BloodBankServiceUpsertWithoutServiceInput
    disconnect?: BloodBankServiceWhereInput | boolean
    delete?: BloodBankServiceWhereInput | boolean
    connect?: BloodBankServiceWhereUniqueInput
    update?: XOR<XOR<BloodBankServiceUpdateToOneWithWhereWithoutServiceInput, BloodBankServiceUpdateWithoutServiceInput>, BloodBankServiceUncheckedUpdateWithoutServiceInput>
  }

  export type ERServiceUncheckedUpdateOneWithoutServiceNestedInput = {
    create?: XOR<ERServiceCreateWithoutServiceInput, ERServiceUncheckedCreateWithoutServiceInput>
    connectOrCreate?: ERServiceCreateOrConnectWithoutServiceInput
    upsert?: ERServiceUpsertWithoutServiceInput
    disconnect?: ERServiceWhereInput | boolean
    delete?: ERServiceWhereInput | boolean
    connect?: ERServiceWhereUniqueInput
    update?: XOR<XOR<ERServiceUpdateToOneWithWhereWithoutServiceInput, ERServiceUpdateWithoutServiceInput>, ERServiceUncheckedUpdateWithoutServiceInput>
  }

  export type ICUServiceUncheckedUpdateOneWithoutServiceNestedInput = {
    create?: XOR<ICUServiceCreateWithoutServiceInput, ICUServiceUncheckedCreateWithoutServiceInput>
    connectOrCreate?: ICUServiceCreateOrConnectWithoutServiceInput
    upsert?: ICUServiceUpsertWithoutServiceInput
    disconnect?: ICUServiceWhereInput | boolean
    delete?: ICUServiceWhereInput | boolean
    connect?: ICUServiceWhereUniqueInput
    update?: XOR<XOR<ICUServiceUpdateToOneWithWhereWithoutServiceInput, ICUServiceUpdateWithoutServiceInput>, ICUServiceUncheckedUpdateWithoutServiceInput>
  }

  export type OutpatientServiceUncheckedUpdateOneWithoutServiceNestedInput = {
    create?: XOR<OutpatientServiceCreateWithoutServiceInput, OutpatientServiceUncheckedCreateWithoutServiceInput>
    connectOrCreate?: OutpatientServiceCreateOrConnectWithoutServiceInput
    upsert?: OutpatientServiceUpsertWithoutServiceInput
    disconnect?: OutpatientServiceWhereInput | boolean
    delete?: OutpatientServiceWhereInput | boolean
    connect?: OutpatientServiceWhereUniqueInput
    update?: XOR<XOR<OutpatientServiceUpdateToOneWithWhereWithoutServiceInput, OutpatientServiceUpdateWithoutServiceInput>, OutpatientServiceUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceCreateNestedOneWithoutAmbulanceServiceInput = {
    create?: XOR<ServiceCreateWithoutAmbulanceServiceInput, ServiceUncheckedCreateWithoutAmbulanceServiceInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutAmbulanceServiceInput
    connect?: ServiceWhereUniqueInput
  }

  export type EnumAvailabilityFieldUpdateOperationsInput = {
    set?: $Enums.Availability
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ServiceUpdateOneRequiredWithoutAmbulanceServiceNestedInput = {
    create?: XOR<ServiceCreateWithoutAmbulanceServiceInput, ServiceUncheckedCreateWithoutAmbulanceServiceInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutAmbulanceServiceInput
    upsert?: ServiceUpsertWithoutAmbulanceServiceInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutAmbulanceServiceInput, ServiceUpdateWithoutAmbulanceServiceInput>, ServiceUncheckedUpdateWithoutAmbulanceServiceInput>
  }

  export type BloodBankServiceCreateNestedOneWithoutBloodTypeAvailabilityInput = {
    create?: XOR<BloodBankServiceCreateWithoutBloodTypeAvailabilityInput, BloodBankServiceUncheckedCreateWithoutBloodTypeAvailabilityInput>
    connectOrCreate?: BloodBankServiceCreateOrConnectWithoutBloodTypeAvailabilityInput
    connect?: BloodBankServiceWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BloodBankServiceUpdateOneRequiredWithoutBloodTypeAvailabilityNestedInput = {
    create?: XOR<BloodBankServiceCreateWithoutBloodTypeAvailabilityInput, BloodBankServiceUncheckedCreateWithoutBloodTypeAvailabilityInput>
    connectOrCreate?: BloodBankServiceCreateOrConnectWithoutBloodTypeAvailabilityInput
    upsert?: BloodBankServiceUpsertWithoutBloodTypeAvailabilityInput
    connect?: BloodBankServiceWhereUniqueInput
    update?: XOR<XOR<BloodBankServiceUpdateToOneWithWhereWithoutBloodTypeAvailabilityInput, BloodBankServiceUpdateWithoutBloodTypeAvailabilityInput>, BloodBankServiceUncheckedUpdateWithoutBloodTypeAvailabilityInput>
  }

  export type BloodTypeMappingCreateNestedOneWithoutBloodBankServiceInput = {
    create?: XOR<BloodTypeMappingCreateWithoutBloodBankServiceInput, BloodTypeMappingUncheckedCreateWithoutBloodBankServiceInput>
    connectOrCreate?: BloodTypeMappingCreateOrConnectWithoutBloodBankServiceInput
    connect?: BloodTypeMappingWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutBloodBankServiceInput = {
    create?: XOR<ServiceCreateWithoutBloodBankServiceInput, ServiceUncheckedCreateWithoutBloodBankServiceInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBloodBankServiceInput
    connect?: ServiceWhereUniqueInput
  }

  export type BloodTypeMappingUncheckedCreateNestedOneWithoutBloodBankServiceInput = {
    create?: XOR<BloodTypeMappingCreateWithoutBloodBankServiceInput, BloodTypeMappingUncheckedCreateWithoutBloodBankServiceInput>
    connectOrCreate?: BloodTypeMappingCreateOrConnectWithoutBloodBankServiceInput
    connect?: BloodTypeMappingWhereUniqueInput
  }

  export type BloodTypeMappingUpdateOneWithoutBloodBankServiceNestedInput = {
    create?: XOR<BloodTypeMappingCreateWithoutBloodBankServiceInput, BloodTypeMappingUncheckedCreateWithoutBloodBankServiceInput>
    connectOrCreate?: BloodTypeMappingCreateOrConnectWithoutBloodBankServiceInput
    upsert?: BloodTypeMappingUpsertWithoutBloodBankServiceInput
    disconnect?: BloodTypeMappingWhereInput | boolean
    delete?: BloodTypeMappingWhereInput | boolean
    connect?: BloodTypeMappingWhereUniqueInput
    update?: XOR<XOR<BloodTypeMappingUpdateToOneWithWhereWithoutBloodBankServiceInput, BloodTypeMappingUpdateWithoutBloodBankServiceInput>, BloodTypeMappingUncheckedUpdateWithoutBloodBankServiceInput>
  }

  export type ServiceUpdateOneRequiredWithoutBloodBankServiceNestedInput = {
    create?: XOR<ServiceCreateWithoutBloodBankServiceInput, ServiceUncheckedCreateWithoutBloodBankServiceInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBloodBankServiceInput
    upsert?: ServiceUpsertWithoutBloodBankServiceInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutBloodBankServiceInput, ServiceUpdateWithoutBloodBankServiceInput>, ServiceUncheckedUpdateWithoutBloodBankServiceInput>
  }

  export type BloodTypeMappingUncheckedUpdateOneWithoutBloodBankServiceNestedInput = {
    create?: XOR<BloodTypeMappingCreateWithoutBloodBankServiceInput, BloodTypeMappingUncheckedCreateWithoutBloodBankServiceInput>
    connectOrCreate?: BloodTypeMappingCreateOrConnectWithoutBloodBankServiceInput
    upsert?: BloodTypeMappingUpsertWithoutBloodBankServiceInput
    disconnect?: BloodTypeMappingWhereInput | boolean
    delete?: BloodTypeMappingWhereInput | boolean
    connect?: BloodTypeMappingWhereUniqueInput
    update?: XOR<XOR<BloodTypeMappingUpdateToOneWithWhereWithoutBloodBankServiceInput, BloodTypeMappingUpdateWithoutBloodBankServiceInput>, BloodTypeMappingUncheckedUpdateWithoutBloodBankServiceInput>
  }

  export type ServiceCreateNestedOneWithoutErServiceInput = {
    create?: XOR<ServiceCreateWithoutErServiceInput, ServiceUncheckedCreateWithoutErServiceInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutErServiceInput
    connect?: ServiceWhereUniqueInput
  }

  export type EnumLoadFieldUpdateOperationsInput = {
    set?: $Enums.Load
  }

  export type ServiceUpdateOneRequiredWithoutErServiceNestedInput = {
    create?: XOR<ServiceCreateWithoutErServiceInput, ServiceUncheckedCreateWithoutErServiceInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutErServiceInput
    upsert?: ServiceUpsertWithoutErServiceInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutErServiceInput, ServiceUpdateWithoutErServiceInput>, ServiceUncheckedUpdateWithoutErServiceInput>
  }

  export type ServiceCreateNestedOneWithoutIcuServiceInput = {
    create?: XOR<ServiceCreateWithoutIcuServiceInput, ServiceUncheckedCreateWithoutIcuServiceInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutIcuServiceInput
    connect?: ServiceWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutIcuServiceNestedInput = {
    create?: XOR<ServiceCreateWithoutIcuServiceInput, ServiceUncheckedCreateWithoutIcuServiceInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutIcuServiceInput
    upsert?: ServiceUpsertWithoutIcuServiceInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutIcuServiceInput, ServiceUpdateWithoutIcuServiceInput>, ServiceUncheckedUpdateWithoutIcuServiceInput>
  }

  export type ServiceCreateNestedOneWithoutOutpatientServiceInput = {
    create?: XOR<ServiceCreateWithoutOutpatientServiceInput, ServiceUncheckedCreateWithoutOutpatientServiceInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutOutpatientServiceInput
    connect?: ServiceWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutOutpatientServiceNestedInput = {
    create?: XOR<ServiceCreateWithoutOutpatientServiceInput, ServiceUncheckedCreateWithoutOutpatientServiceInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutOutpatientServiceInput
    upsert?: ServiceUpsertWithoutOutpatientServiceInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutOutpatientServiceInput, ServiceUpdateWithoutOutpatientServiceInput>, ServiceUncheckedUpdateWithoutOutpatientServiceInput>
  }

  export type FacilityCreateNestedOneWithoutContactsInput = {
    create?: XOR<FacilityCreateWithoutContactsInput, FacilityUncheckedCreateWithoutContactsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutContactsInput
    connect?: FacilityWhereUniqueInput
  }

  export type DivisionCreateNestedOneWithoutContactsInput = {
    create?: XOR<DivisionCreateWithoutContactsInput, DivisionUncheckedCreateWithoutContactsInput>
    connectOrCreate?: DivisionCreateOrConnectWithoutContactsInput
    connect?: DivisionWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutPhoneNumbersInput = {
    create?: XOR<ServiceCreateWithoutPhoneNumbersInput, ServiceUncheckedCreateWithoutPhoneNumbersInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutPhoneNumbersInput
    connect?: ServiceWhereUniqueInput
  }

  export type EnumContactTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContactType
  }

  export type FacilityUpdateOneWithoutContactsNestedInput = {
    create?: XOR<FacilityCreateWithoutContactsInput, FacilityUncheckedCreateWithoutContactsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutContactsInput
    upsert?: FacilityUpsertWithoutContactsInput
    disconnect?: FacilityWhereInput | boolean
    delete?: FacilityWhereInput | boolean
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutContactsInput, FacilityUpdateWithoutContactsInput>, FacilityUncheckedUpdateWithoutContactsInput>
  }

  export type DivisionUpdateOneWithoutContactsNestedInput = {
    create?: XOR<DivisionCreateWithoutContactsInput, DivisionUncheckedCreateWithoutContactsInput>
    connectOrCreate?: DivisionCreateOrConnectWithoutContactsInput
    upsert?: DivisionUpsertWithoutContactsInput
    disconnect?: DivisionWhereInput | boolean
    delete?: DivisionWhereInput | boolean
    connect?: DivisionWhereUniqueInput
    update?: XOR<XOR<DivisionUpdateToOneWithWhereWithoutContactsInput, DivisionUpdateWithoutContactsInput>, DivisionUncheckedUpdateWithoutContactsInput>
  }

  export type ServiceUpdateOneWithoutPhoneNumbersNestedInput = {
    create?: XOR<ServiceCreateWithoutPhoneNumbersInput, ServiceUncheckedCreateWithoutPhoneNumbersInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutPhoneNumbersInput
    upsert?: ServiceUpsertWithoutPhoneNumbersInput
    disconnect?: ServiceWhereInput | boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutPhoneNumbersInput, ServiceUpdateWithoutPhoneNumbersInput>, ServiceUncheckedUpdateWithoutPhoneNumbersInput>
  }

  export type FacilityCreateNestedOneWithoutLogsInput = {
    create?: XOR<FacilityCreateWithoutLogsInput, FacilityUncheckedCreateWithoutLogsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutLogsInput
    connect?: FacilityWhereUniqueInput
  }

  export type DivisionCreateNestedOneWithoutLogsInput = {
    create?: XOR<DivisionCreateWithoutLogsInput, DivisionUncheckedCreateWithoutLogsInput>
    connectOrCreate?: DivisionCreateOrConnectWithoutLogsInput
    connect?: DivisionWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutUpdateLogInput = {
    create?: XOR<EmployeeCreateWithoutUpdateLogInput, EmployeeUncheckedCreateWithoutUpdateLogInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUpdateLogInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EnumActionFieldUpdateOperationsInput = {
    set?: $Enums.Action
  }

  export type FacilityUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<FacilityCreateWithoutLogsInput, FacilityUncheckedCreateWithoutLogsInput>
    connectOrCreate?: FacilityCreateOrConnectWithoutLogsInput
    upsert?: FacilityUpsertWithoutLogsInput
    connect?: FacilityWhereUniqueInput
    update?: XOR<XOR<FacilityUpdateToOneWithWhereWithoutLogsInput, FacilityUpdateWithoutLogsInput>, FacilityUncheckedUpdateWithoutLogsInput>
  }

  export type DivisionUpdateOneWithoutLogsNestedInput = {
    create?: XOR<DivisionCreateWithoutLogsInput, DivisionUncheckedCreateWithoutLogsInput>
    connectOrCreate?: DivisionCreateOrConnectWithoutLogsInput
    upsert?: DivisionUpsertWithoutLogsInput
    disconnect?: DivisionWhereInput | boolean
    delete?: DivisionWhereInput | boolean
    connect?: DivisionWhereUniqueInput
    update?: XOR<XOR<DivisionUpdateToOneWithWhereWithoutLogsInput, DivisionUpdateWithoutLogsInput>, DivisionUncheckedUpdateWithoutLogsInput>
  }

  export type EmployeeUpdateOneRequiredWithoutUpdateLogNestedInput = {
    create?: XOR<EmployeeCreateWithoutUpdateLogInput, EmployeeUncheckedCreateWithoutUpdateLogInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUpdateLogInput
    upsert?: EmployeeUpsertWithoutUpdateLogInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutUpdateLogInput, EmployeeUpdateWithoutUpdateLogInput>, EmployeeUncheckedUpdateWithoutUpdateLogInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumFacilityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FacilityType | EnumFacilityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FacilityType[] | ListEnumFacilityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FacilityType[] | ListEnumFacilityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFacilityTypeFilter<$PrismaModel> | $Enums.FacilityType
  }

  export type NestedEnumOwnershipFilter<$PrismaModel = never> = {
    equals?: $Enums.Ownership | EnumOwnershipFieldRefInput<$PrismaModel>
    in?: $Enums.Ownership[] | ListEnumOwnershipFieldRefInput<$PrismaModel>
    notIn?: $Enums.Ownership[] | ListEnumOwnershipFieldRefInput<$PrismaModel>
    not?: NestedEnumOwnershipFilter<$PrismaModel> | $Enums.Ownership
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumFacilityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FacilityType | EnumFacilityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FacilityType[] | ListEnumFacilityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FacilityType[] | ListEnumFacilityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFacilityTypeWithAggregatesFilter<$PrismaModel> | $Enums.FacilityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFacilityTypeFilter<$PrismaModel>
    _max?: NestedEnumFacilityTypeFilter<$PrismaModel>
  }

  export type NestedEnumOwnershipWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Ownership | EnumOwnershipFieldRefInput<$PrismaModel>
    in?: $Enums.Ownership[] | ListEnumOwnershipFieldRefInput<$PrismaModel>
    notIn?: $Enums.Ownership[] | ListEnumOwnershipFieldRefInput<$PrismaModel>
    not?: NestedEnumOwnershipWithAggregatesFilter<$PrismaModel> | $Enums.Ownership
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOwnershipFilter<$PrismaModel>
    _max?: NestedEnumOwnershipFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumAvailabilityFilter<$PrismaModel = never> = {
    equals?: $Enums.Availability | EnumAvailabilityFieldRefInput<$PrismaModel>
    in?: $Enums.Availability[] | ListEnumAvailabilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Availability[] | ListEnumAvailabilityFieldRefInput<$PrismaModel>
    not?: NestedEnumAvailabilityFilter<$PrismaModel> | $Enums.Availability
  }

  export type NestedEnumAvailabilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Availability | EnumAvailabilityFieldRefInput<$PrismaModel>
    in?: $Enums.Availability[] | ListEnumAvailabilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Availability[] | ListEnumAvailabilityFieldRefInput<$PrismaModel>
    not?: NestedEnumAvailabilityWithAggregatesFilter<$PrismaModel> | $Enums.Availability
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAvailabilityFilter<$PrismaModel>
    _max?: NestedEnumAvailabilityFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumLoadFilter<$PrismaModel = never> = {
    equals?: $Enums.Load | EnumLoadFieldRefInput<$PrismaModel>
    in?: $Enums.Load[] | ListEnumLoadFieldRefInput<$PrismaModel>
    notIn?: $Enums.Load[] | ListEnumLoadFieldRefInput<$PrismaModel>
    not?: NestedEnumLoadFilter<$PrismaModel> | $Enums.Load
  }

  export type NestedEnumLoadWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Load | EnumLoadFieldRefInput<$PrismaModel>
    in?: $Enums.Load[] | ListEnumLoadFieldRefInput<$PrismaModel>
    notIn?: $Enums.Load[] | ListEnumLoadFieldRefInput<$PrismaModel>
    not?: NestedEnumLoadWithAggregatesFilter<$PrismaModel> | $Enums.Load
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoadFilter<$PrismaModel>
    _max?: NestedEnumLoadFilter<$PrismaModel>
  }

  export type NestedEnumContactTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeFilter<$PrismaModel> | $Enums.ContactType
  }

  export type NestedEnumContactTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContactType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactTypeFilter<$PrismaModel>
    _max?: NestedEnumContactTypeFilter<$PrismaModel>
  }

  export type NestedEnumActionFilter<$PrismaModel = never> = {
    equals?: $Enums.Action | EnumActionFieldRefInput<$PrismaModel>
    in?: $Enums.Action[] | ListEnumActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Action[] | ListEnumActionFieldRefInput<$PrismaModel>
    not?: NestedEnumActionFilter<$PrismaModel> | $Enums.Action
  }

  export type NestedEnumActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Action | EnumActionFieldRefInput<$PrismaModel>
    in?: $Enums.Action[] | ListEnumActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Action[] | ListEnumActionFieldRefInput<$PrismaModel>
    not?: NestedEnumActionWithAggregatesFilter<$PrismaModel> | $Enums.Action
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionFilter<$PrismaModel>
    _max?: NestedEnumActionFilter<$PrismaModel>
  }

  export type POrCCreateWithoutRegionInput = {
    pOrCID: number
    name: string
    id?: number
    cOrMs?: COrMCreateNestedManyWithoutPOrCInput
    addresses?: AddressCreateNestedManyWithoutPOrCInput
  }

  export type POrCUncheckedCreateWithoutRegionInput = {
    pOrCID: number
    name: string
    id?: number
    cOrMs?: COrMUncheckedCreateNestedManyWithoutPOrCInput
    addresses?: AddressUncheckedCreateNestedManyWithoutPOrCInput
  }

  export type POrCCreateOrConnectWithoutRegionInput = {
    where: POrCWhereUniqueInput
    create: XOR<POrCCreateWithoutRegionInput, POrCUncheckedCreateWithoutRegionInput>
  }

  export type POrCCreateManyRegionInputEnvelope = {
    data: POrCCreateManyRegionInput | POrCCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type AddressCreateWithoutRegionInput = {
    street: string
    pOrC: POrCCreateNestedOneWithoutAddressesInput
    cOrM: COrMCreateNestedOneWithoutAddressesInput
    brgy: BrgyCreateNestedOneWithoutAddressesInput
    facility: FacilityCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutRegionInput = {
    pOrCID: number
    cOrMID: number
    brgyID: number
    street: string
    facilityID: string
  }

  export type AddressCreateOrConnectWithoutRegionInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutRegionInput, AddressUncheckedCreateWithoutRegionInput>
  }

  export type AddressCreateManyRegionInputEnvelope = {
    data: AddressCreateManyRegionInput | AddressCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type POrCUpsertWithWhereUniqueWithoutRegionInput = {
    where: POrCWhereUniqueInput
    update: XOR<POrCUpdateWithoutRegionInput, POrCUncheckedUpdateWithoutRegionInput>
    create: XOR<POrCCreateWithoutRegionInput, POrCUncheckedCreateWithoutRegionInput>
  }

  export type POrCUpdateWithWhereUniqueWithoutRegionInput = {
    where: POrCWhereUniqueInput
    data: XOR<POrCUpdateWithoutRegionInput, POrCUncheckedUpdateWithoutRegionInput>
  }

  export type POrCUpdateManyWithWhereWithoutRegionInput = {
    where: POrCScalarWhereInput
    data: XOR<POrCUpdateManyMutationInput, POrCUncheckedUpdateManyWithoutRegionInput>
  }

  export type POrCScalarWhereInput = {
    AND?: POrCScalarWhereInput | POrCScalarWhereInput[]
    OR?: POrCScalarWhereInput[]
    NOT?: POrCScalarWhereInput | POrCScalarWhereInput[]
    pOrCID?: IntFilter<"POrC"> | number
    name?: StringFilter<"POrC"> | string
    id?: IntFilter<"POrC"> | number
    regionID?: IntFilter<"POrC"> | number
  }

  export type AddressUpsertWithWhereUniqueWithoutRegionInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutRegionInput, AddressUncheckedUpdateWithoutRegionInput>
    create: XOR<AddressCreateWithoutRegionInput, AddressUncheckedCreateWithoutRegionInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutRegionInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutRegionInput, AddressUncheckedUpdateWithoutRegionInput>
  }

  export type AddressUpdateManyWithWhereWithoutRegionInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutRegionInput>
  }

  export type AddressScalarWhereInput = {
    AND?: AddressScalarWhereInput | AddressScalarWhereInput[]
    OR?: AddressScalarWhereInput[]
    NOT?: AddressScalarWhereInput | AddressScalarWhereInput[]
    regionID?: IntFilter<"Address"> | number
    pOrCID?: IntFilter<"Address"> | number
    cOrMID?: IntFilter<"Address"> | number
    brgyID?: IntFilter<"Address"> | number
    street?: StringFilter<"Address"> | string
    facilityID?: StringFilter<"Address"> | string
  }

  export type RegionCreateWithoutPOrCsInput = {
    regionID: number
    name: string
    id?: number
    addresses?: AddressCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateWithoutPOrCsInput = {
    regionID: number
    name: string
    id?: number
    addresses?: AddressUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionCreateOrConnectWithoutPOrCsInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutPOrCsInput, RegionUncheckedCreateWithoutPOrCsInput>
  }

  export type COrMCreateWithoutPOrCInput = {
    cOrMID: number
    name: string
    id?: number
    brgys?: BrgyCreateNestedManyWithoutCOrMInput
    addresses?: AddressCreateNestedManyWithoutCOrMInput
  }

  export type COrMUncheckedCreateWithoutPOrCInput = {
    cOrMID: number
    name: string
    id?: number
    brgys?: BrgyUncheckedCreateNestedManyWithoutCOrMInput
    addresses?: AddressUncheckedCreateNestedManyWithoutCOrMInput
  }

  export type COrMCreateOrConnectWithoutPOrCInput = {
    where: COrMWhereUniqueInput
    create: XOR<COrMCreateWithoutPOrCInput, COrMUncheckedCreateWithoutPOrCInput>
  }

  export type COrMCreateManyPOrCInputEnvelope = {
    data: COrMCreateManyPOrCInput | COrMCreateManyPOrCInput[]
    skipDuplicates?: boolean
  }

  export type AddressCreateWithoutPOrCInput = {
    street: string
    region: RegionCreateNestedOneWithoutAddressesInput
    cOrM: COrMCreateNestedOneWithoutAddressesInput
    brgy: BrgyCreateNestedOneWithoutAddressesInput
    facility: FacilityCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutPOrCInput = {
    regionID: number
    cOrMID: number
    brgyID: number
    street: string
    facilityID: string
  }

  export type AddressCreateOrConnectWithoutPOrCInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutPOrCInput, AddressUncheckedCreateWithoutPOrCInput>
  }

  export type AddressCreateManyPOrCInputEnvelope = {
    data: AddressCreateManyPOrCInput | AddressCreateManyPOrCInput[]
    skipDuplicates?: boolean
  }

  export type RegionUpsertWithoutPOrCsInput = {
    update: XOR<RegionUpdateWithoutPOrCsInput, RegionUncheckedUpdateWithoutPOrCsInput>
    create: XOR<RegionCreateWithoutPOrCsInput, RegionUncheckedCreateWithoutPOrCsInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutPOrCsInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutPOrCsInput, RegionUncheckedUpdateWithoutPOrCsInput>
  }

  export type RegionUpdateWithoutPOrCsInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    addresses?: AddressUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateWithoutPOrCsInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    addresses?: AddressUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type COrMUpsertWithWhereUniqueWithoutPOrCInput = {
    where: COrMWhereUniqueInput
    update: XOR<COrMUpdateWithoutPOrCInput, COrMUncheckedUpdateWithoutPOrCInput>
    create: XOR<COrMCreateWithoutPOrCInput, COrMUncheckedCreateWithoutPOrCInput>
  }

  export type COrMUpdateWithWhereUniqueWithoutPOrCInput = {
    where: COrMWhereUniqueInput
    data: XOR<COrMUpdateWithoutPOrCInput, COrMUncheckedUpdateWithoutPOrCInput>
  }

  export type COrMUpdateManyWithWhereWithoutPOrCInput = {
    where: COrMScalarWhereInput
    data: XOR<COrMUpdateManyMutationInput, COrMUncheckedUpdateManyWithoutPOrCInput>
  }

  export type COrMScalarWhereInput = {
    AND?: COrMScalarWhereInput | COrMScalarWhereInput[]
    OR?: COrMScalarWhereInput[]
    NOT?: COrMScalarWhereInput | COrMScalarWhereInput[]
    cOrMID?: IntFilter<"COrM"> | number
    name?: StringFilter<"COrM"> | string
    id?: IntFilter<"COrM"> | number
    pOrCID?: IntFilter<"COrM"> | number
  }

  export type AddressUpsertWithWhereUniqueWithoutPOrCInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutPOrCInput, AddressUncheckedUpdateWithoutPOrCInput>
    create: XOR<AddressCreateWithoutPOrCInput, AddressUncheckedCreateWithoutPOrCInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutPOrCInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutPOrCInput, AddressUncheckedUpdateWithoutPOrCInput>
  }

  export type AddressUpdateManyWithWhereWithoutPOrCInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutPOrCInput>
  }

  export type POrCCreateWithoutCOrMsInput = {
    pOrCID: number
    name: string
    id?: number
    region: RegionCreateNestedOneWithoutPOrCsInput
    addresses?: AddressCreateNestedManyWithoutPOrCInput
  }

  export type POrCUncheckedCreateWithoutCOrMsInput = {
    pOrCID: number
    name: string
    id?: number
    regionID: number
    addresses?: AddressUncheckedCreateNestedManyWithoutPOrCInput
  }

  export type POrCCreateOrConnectWithoutCOrMsInput = {
    where: POrCWhereUniqueInput
    create: XOR<POrCCreateWithoutCOrMsInput, POrCUncheckedCreateWithoutCOrMsInput>
  }

  export type BrgyCreateWithoutCOrMInput = {
    brgyID: number
    name: string
    id?: number
    addresses?: AddressCreateNestedManyWithoutBrgyInput
  }

  export type BrgyUncheckedCreateWithoutCOrMInput = {
    brgyID: number
    name: string
    id?: number
    addresses?: AddressUncheckedCreateNestedManyWithoutBrgyInput
  }

  export type BrgyCreateOrConnectWithoutCOrMInput = {
    where: BrgyWhereUniqueInput
    create: XOR<BrgyCreateWithoutCOrMInput, BrgyUncheckedCreateWithoutCOrMInput>
  }

  export type BrgyCreateManyCOrMInputEnvelope = {
    data: BrgyCreateManyCOrMInput | BrgyCreateManyCOrMInput[]
    skipDuplicates?: boolean
  }

  export type AddressCreateWithoutCOrMInput = {
    street: string
    region: RegionCreateNestedOneWithoutAddressesInput
    pOrC: POrCCreateNestedOneWithoutAddressesInput
    brgy: BrgyCreateNestedOneWithoutAddressesInput
    facility: FacilityCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutCOrMInput = {
    regionID: number
    pOrCID: number
    brgyID: number
    street: string
    facilityID: string
  }

  export type AddressCreateOrConnectWithoutCOrMInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutCOrMInput, AddressUncheckedCreateWithoutCOrMInput>
  }

  export type AddressCreateManyCOrMInputEnvelope = {
    data: AddressCreateManyCOrMInput | AddressCreateManyCOrMInput[]
    skipDuplicates?: boolean
  }

  export type POrCUpsertWithoutCOrMsInput = {
    update: XOR<POrCUpdateWithoutCOrMsInput, POrCUncheckedUpdateWithoutCOrMsInput>
    create: XOR<POrCCreateWithoutCOrMsInput, POrCUncheckedCreateWithoutCOrMsInput>
    where?: POrCWhereInput
  }

  export type POrCUpdateToOneWithWhereWithoutCOrMsInput = {
    where?: POrCWhereInput
    data: XOR<POrCUpdateWithoutCOrMsInput, POrCUncheckedUpdateWithoutCOrMsInput>
  }

  export type POrCUpdateWithoutCOrMsInput = {
    pOrCID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    region?: RegionUpdateOneRequiredWithoutPOrCsNestedInput
    addresses?: AddressUpdateManyWithoutPOrCNestedInput
  }

  export type POrCUncheckedUpdateWithoutCOrMsInput = {
    pOrCID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    regionID?: IntFieldUpdateOperationsInput | number
    addresses?: AddressUncheckedUpdateManyWithoutPOrCNestedInput
  }

  export type BrgyUpsertWithWhereUniqueWithoutCOrMInput = {
    where: BrgyWhereUniqueInput
    update: XOR<BrgyUpdateWithoutCOrMInput, BrgyUncheckedUpdateWithoutCOrMInput>
    create: XOR<BrgyCreateWithoutCOrMInput, BrgyUncheckedCreateWithoutCOrMInput>
  }

  export type BrgyUpdateWithWhereUniqueWithoutCOrMInput = {
    where: BrgyWhereUniqueInput
    data: XOR<BrgyUpdateWithoutCOrMInput, BrgyUncheckedUpdateWithoutCOrMInput>
  }

  export type BrgyUpdateManyWithWhereWithoutCOrMInput = {
    where: BrgyScalarWhereInput
    data: XOR<BrgyUpdateManyMutationInput, BrgyUncheckedUpdateManyWithoutCOrMInput>
  }

  export type BrgyScalarWhereInput = {
    AND?: BrgyScalarWhereInput | BrgyScalarWhereInput[]
    OR?: BrgyScalarWhereInput[]
    NOT?: BrgyScalarWhereInput | BrgyScalarWhereInput[]
    brgyID?: IntFilter<"Brgy"> | number
    name?: StringFilter<"Brgy"> | string
    id?: IntFilter<"Brgy"> | number
    cOrMID?: IntFilter<"Brgy"> | number
  }

  export type AddressUpsertWithWhereUniqueWithoutCOrMInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutCOrMInput, AddressUncheckedUpdateWithoutCOrMInput>
    create: XOR<AddressCreateWithoutCOrMInput, AddressUncheckedCreateWithoutCOrMInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutCOrMInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutCOrMInput, AddressUncheckedUpdateWithoutCOrMInput>
  }

  export type AddressUpdateManyWithWhereWithoutCOrMInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutCOrMInput>
  }

  export type COrMCreateWithoutBrgysInput = {
    cOrMID: number
    name: string
    id?: number
    pOrC: POrCCreateNestedOneWithoutCOrMsInput
    addresses?: AddressCreateNestedManyWithoutCOrMInput
  }

  export type COrMUncheckedCreateWithoutBrgysInput = {
    cOrMID: number
    name: string
    id?: number
    pOrCID: number
    addresses?: AddressUncheckedCreateNestedManyWithoutCOrMInput
  }

  export type COrMCreateOrConnectWithoutBrgysInput = {
    where: COrMWhereUniqueInput
    create: XOR<COrMCreateWithoutBrgysInput, COrMUncheckedCreateWithoutBrgysInput>
  }

  export type AddressCreateWithoutBrgyInput = {
    street: string
    region: RegionCreateNestedOneWithoutAddressesInput
    pOrC: POrCCreateNestedOneWithoutAddressesInput
    cOrM: COrMCreateNestedOneWithoutAddressesInput
    facility: FacilityCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutBrgyInput = {
    regionID: number
    pOrCID: number
    cOrMID: number
    street: string
    facilityID: string
  }

  export type AddressCreateOrConnectWithoutBrgyInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutBrgyInput, AddressUncheckedCreateWithoutBrgyInput>
  }

  export type AddressCreateManyBrgyInputEnvelope = {
    data: AddressCreateManyBrgyInput | AddressCreateManyBrgyInput[]
    skipDuplicates?: boolean
  }

  export type COrMUpsertWithoutBrgysInput = {
    update: XOR<COrMUpdateWithoutBrgysInput, COrMUncheckedUpdateWithoutBrgysInput>
    create: XOR<COrMCreateWithoutBrgysInput, COrMUncheckedCreateWithoutBrgysInput>
    where?: COrMWhereInput
  }

  export type COrMUpdateToOneWithWhereWithoutBrgysInput = {
    where?: COrMWhereInput
    data: XOR<COrMUpdateWithoutBrgysInput, COrMUncheckedUpdateWithoutBrgysInput>
  }

  export type COrMUpdateWithoutBrgysInput = {
    cOrMID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    pOrC?: POrCUpdateOneRequiredWithoutCOrMsNestedInput
    addresses?: AddressUpdateManyWithoutCOrMNestedInput
  }

  export type COrMUncheckedUpdateWithoutBrgysInput = {
    cOrMID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    pOrCID?: IntFieldUpdateOperationsInput | number
    addresses?: AddressUncheckedUpdateManyWithoutCOrMNestedInput
  }

  export type AddressUpsertWithWhereUniqueWithoutBrgyInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutBrgyInput, AddressUncheckedUpdateWithoutBrgyInput>
    create: XOR<AddressCreateWithoutBrgyInput, AddressUncheckedCreateWithoutBrgyInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutBrgyInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutBrgyInput, AddressUncheckedUpdateWithoutBrgyInput>
  }

  export type AddressUpdateManyWithWhereWithoutBrgyInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutBrgyInput>
  }

  export type RegionCreateWithoutAddressesInput = {
    regionID: number
    name: string
    id?: number
    pOrCs?: POrCCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateWithoutAddressesInput = {
    regionID: number
    name: string
    id?: number
    pOrCs?: POrCUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionCreateOrConnectWithoutAddressesInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutAddressesInput, RegionUncheckedCreateWithoutAddressesInput>
  }

  export type POrCCreateWithoutAddressesInput = {
    pOrCID: number
    name: string
    id?: number
    region: RegionCreateNestedOneWithoutPOrCsInput
    cOrMs?: COrMCreateNestedManyWithoutPOrCInput
  }

  export type POrCUncheckedCreateWithoutAddressesInput = {
    pOrCID: number
    name: string
    id?: number
    regionID: number
    cOrMs?: COrMUncheckedCreateNestedManyWithoutPOrCInput
  }

  export type POrCCreateOrConnectWithoutAddressesInput = {
    where: POrCWhereUniqueInput
    create: XOR<POrCCreateWithoutAddressesInput, POrCUncheckedCreateWithoutAddressesInput>
  }

  export type COrMCreateWithoutAddressesInput = {
    cOrMID: number
    name: string
    id?: number
    pOrC: POrCCreateNestedOneWithoutCOrMsInput
    brgys?: BrgyCreateNestedManyWithoutCOrMInput
  }

  export type COrMUncheckedCreateWithoutAddressesInput = {
    cOrMID: number
    name: string
    id?: number
    pOrCID: number
    brgys?: BrgyUncheckedCreateNestedManyWithoutCOrMInput
  }

  export type COrMCreateOrConnectWithoutAddressesInput = {
    where: COrMWhereUniqueInput
    create: XOR<COrMCreateWithoutAddressesInput, COrMUncheckedCreateWithoutAddressesInput>
  }

  export type BrgyCreateWithoutAddressesInput = {
    brgyID: number
    name: string
    id?: number
    cOrM: COrMCreateNestedOneWithoutBrgysInput
  }

  export type BrgyUncheckedCreateWithoutAddressesInput = {
    brgyID: number
    name: string
    id?: number
    cOrMID: number
  }

  export type BrgyCreateOrConnectWithoutAddressesInput = {
    where: BrgyWhereUniqueInput
    create: XOR<BrgyCreateWithoutAddressesInput, BrgyUncheckedCreateWithoutAddressesInput>
  }

  export type FacilityCreateWithoutAddressInput = {
    facilityID?: string
    name: string
    photo: string
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    facilityType: $Enums.FacilityType
    ownership: $Enums.Ownership
    bookingSystem?: string | null
    acceptedProviders?: FacilityCreateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutFacilityInput
    services?: ServiceCreateNestedManyWithoutFacilityInput
    employees?: EmployeeCreateNestedManyWithoutFacilityInput
    divisions?: DivisionCreateNestedManyWithoutFacilityInput
    logs?: UpdateLogCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutAddressInput = {
    facilityID?: string
    name: string
    photo: string
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    facilityType: $Enums.FacilityType
    ownership: $Enums.Ownership
    bookingSystem?: string | null
    acceptedProviders?: FacilityCreateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutFacilityInput
    services?: ServiceUncheckedCreateNestedManyWithoutFacilityInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutFacilityInput
    divisions?: DivisionUncheckedCreateNestedManyWithoutFacilityInput
    logs?: UpdateLogUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutAddressInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutAddressInput, FacilityUncheckedCreateWithoutAddressInput>
  }

  export type RegionUpsertWithoutAddressesInput = {
    update: XOR<RegionUpdateWithoutAddressesInput, RegionUncheckedUpdateWithoutAddressesInput>
    create: XOR<RegionCreateWithoutAddressesInput, RegionUncheckedCreateWithoutAddressesInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutAddressesInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutAddressesInput, RegionUncheckedUpdateWithoutAddressesInput>
  }

  export type RegionUpdateWithoutAddressesInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    pOrCs?: POrCUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateWithoutAddressesInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    pOrCs?: POrCUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type POrCUpsertWithoutAddressesInput = {
    update: XOR<POrCUpdateWithoutAddressesInput, POrCUncheckedUpdateWithoutAddressesInput>
    create: XOR<POrCCreateWithoutAddressesInput, POrCUncheckedCreateWithoutAddressesInput>
    where?: POrCWhereInput
  }

  export type POrCUpdateToOneWithWhereWithoutAddressesInput = {
    where?: POrCWhereInput
    data: XOR<POrCUpdateWithoutAddressesInput, POrCUncheckedUpdateWithoutAddressesInput>
  }

  export type POrCUpdateWithoutAddressesInput = {
    pOrCID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    region?: RegionUpdateOneRequiredWithoutPOrCsNestedInput
    cOrMs?: COrMUpdateManyWithoutPOrCNestedInput
  }

  export type POrCUncheckedUpdateWithoutAddressesInput = {
    pOrCID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    regionID?: IntFieldUpdateOperationsInput | number
    cOrMs?: COrMUncheckedUpdateManyWithoutPOrCNestedInput
  }

  export type COrMUpsertWithoutAddressesInput = {
    update: XOR<COrMUpdateWithoutAddressesInput, COrMUncheckedUpdateWithoutAddressesInput>
    create: XOR<COrMCreateWithoutAddressesInput, COrMUncheckedCreateWithoutAddressesInput>
    where?: COrMWhereInput
  }

  export type COrMUpdateToOneWithWhereWithoutAddressesInput = {
    where?: COrMWhereInput
    data: XOR<COrMUpdateWithoutAddressesInput, COrMUncheckedUpdateWithoutAddressesInput>
  }

  export type COrMUpdateWithoutAddressesInput = {
    cOrMID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    pOrC?: POrCUpdateOneRequiredWithoutCOrMsNestedInput
    brgys?: BrgyUpdateManyWithoutCOrMNestedInput
  }

  export type COrMUncheckedUpdateWithoutAddressesInput = {
    cOrMID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    pOrCID?: IntFieldUpdateOperationsInput | number
    brgys?: BrgyUncheckedUpdateManyWithoutCOrMNestedInput
  }

  export type BrgyUpsertWithoutAddressesInput = {
    update: XOR<BrgyUpdateWithoutAddressesInput, BrgyUncheckedUpdateWithoutAddressesInput>
    create: XOR<BrgyCreateWithoutAddressesInput, BrgyUncheckedCreateWithoutAddressesInput>
    where?: BrgyWhereInput
  }

  export type BrgyUpdateToOneWithWhereWithoutAddressesInput = {
    where?: BrgyWhereInput
    data: XOR<BrgyUpdateWithoutAddressesInput, BrgyUncheckedUpdateWithoutAddressesInput>
  }

  export type BrgyUpdateWithoutAddressesInput = {
    brgyID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    cOrM?: COrMUpdateOneRequiredWithoutBrgysNestedInput
  }

  export type BrgyUncheckedUpdateWithoutAddressesInput = {
    brgyID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    cOrMID?: IntFieldUpdateOperationsInput | number
  }

  export type FacilityUpsertWithoutAddressInput = {
    update: XOR<FacilityUpdateWithoutAddressInput, FacilityUncheckedUpdateWithoutAddressInput>
    create: XOR<FacilityCreateWithoutAddressInput, FacilityUncheckedCreateWithoutAddressInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutAddressInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutAddressInput, FacilityUncheckedUpdateWithoutAddressInput>
  }

  export type FacilityUpdateWithoutAddressInput = {
    facilityID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityType?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    ownership?: EnumOwnershipFieldUpdateOperationsInput | $Enums.Ownership
    bookingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedProviders?: FacilityUpdateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutFacilityNestedInput
    services?: ServiceUpdateManyWithoutFacilityNestedInput
    employees?: EmployeeUpdateManyWithoutFacilityNestedInput
    divisions?: DivisionUpdateManyWithoutFacilityNestedInput
    logs?: UpdateLogUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutAddressInput = {
    facilityID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityType?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    ownership?: EnumOwnershipFieldUpdateOperationsInput | $Enums.Ownership
    bookingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedProviders?: FacilityUpdateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutFacilityNestedInput
    services?: ServiceUncheckedUpdateManyWithoutFacilityNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutFacilityNestedInput
    divisions?: DivisionUncheckedUpdateManyWithoutFacilityNestedInput
    logs?: UpdateLogUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type AddressCreateWithoutFacilityInput = {
    street: string
    region: RegionCreateNestedOneWithoutAddressesInput
    pOrC: POrCCreateNestedOneWithoutAddressesInput
    cOrM: COrMCreateNestedOneWithoutAddressesInput
    brgy: BrgyCreateNestedOneWithoutAddressesInput
  }

  export type AddressUncheckedCreateWithoutFacilityInput = {
    regionID: number
    pOrCID: number
    cOrMID: number
    brgyID: number
    street: string
  }

  export type AddressCreateOrConnectWithoutFacilityInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutFacilityInput, AddressUncheckedCreateWithoutFacilityInput>
  }

  export type ContactCreateWithoutFacilityInput = {
    contactID?: string
    info: string
    type: $Enums.ContactType
    division?: DivisionCreateNestedOneWithoutContactsInput
    service?: ServiceCreateNestedOneWithoutPhoneNumbersInput
  }

  export type ContactUncheckedCreateWithoutFacilityInput = {
    contactID?: string
    info: string
    type: $Enums.ContactType
    divisionID?: string | null
    serviceID?: string | null
  }

  export type ContactCreateOrConnectWithoutFacilityInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutFacilityInput, ContactUncheckedCreateWithoutFacilityInput>
  }

  export type ContactCreateManyFacilityInputEnvelope = {
    data: ContactCreateManyFacilityInput | ContactCreateManyFacilityInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCreateWithoutFacilityInput = {
    serviceID?: string
    type: string
    keywords?: ServiceCreatekeywordsInput | string[]
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumbers?: ContactCreateNestedManyWithoutServiceInput
    division?: DivisionCreateNestedOneWithoutServicesInput
    ambulanceService?: AmbulanceServiceCreateNestedOneWithoutServiceInput
    bloodBankService?: BloodBankServiceCreateNestedOneWithoutServiceInput
    erService?: ERServiceCreateNestedOneWithoutServiceInput
    icuService?: ICUServiceCreateNestedOneWithoutServiceInput
    outpatientService?: OutpatientServiceCreateNestedOneWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutFacilityInput = {
    serviceID?: string
    type: string
    keywords?: ServiceCreatekeywordsInput | string[]
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    divisionID?: string | null
    phoneNumbers?: ContactUncheckedCreateNestedManyWithoutServiceInput
    ambulanceService?: AmbulanceServiceUncheckedCreateNestedOneWithoutServiceInput
    bloodBankService?: BloodBankServiceUncheckedCreateNestedOneWithoutServiceInput
    erService?: ERServiceUncheckedCreateNestedOneWithoutServiceInput
    icuService?: ICUServiceUncheckedCreateNestedOneWithoutServiceInput
    outpatientService?: OutpatientServiceUncheckedCreateNestedOneWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutFacilityInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutFacilityInput, ServiceUncheckedCreateWithoutFacilityInput>
  }

  export type ServiceCreateManyFacilityInputEnvelope = {
    data: ServiceCreateManyFacilityInput | ServiceCreateManyFacilityInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutFacilityInput = {
    employeeID?: string
    password: string
    role: $Enums.Role
    fname: string
    mname?: string | null
    lname: string
    photo?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutEmployeeInput
    divisions?: DivisionCreateNestedManyWithoutAdminsInput
    updateLog?: UpdateLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutFacilityInput = {
    employeeID?: string
    password: string
    role: $Enums.Role
    fname: string
    mname?: string | null
    lname: string
    photo?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutEmployeeInput
    divisions?: DivisionUncheckedCreateNestedManyWithoutAdminsInput
    updateLog?: UpdateLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutFacilityInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutFacilityInput, EmployeeUncheckedCreateWithoutFacilityInput>
  }

  export type EmployeeCreateManyFacilityInputEnvelope = {
    data: EmployeeCreateManyFacilityInput | EmployeeCreateManyFacilityInput[]
    skipDuplicates?: boolean
  }

  export type DivisionCreateWithoutFacilityInput = {
    divisionID?: string
    name: string
    openingTime: Date | string
    closingTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutDivisionInput
    services?: ServiceCreateNestedManyWithoutDivisionInput
    admins?: EmployeeCreateNestedManyWithoutDivisionsInput
    logs?: UpdateLogCreateNestedManyWithoutDivisionInput
  }

  export type DivisionUncheckedCreateWithoutFacilityInput = {
    divisionID?: string
    name: string
    openingTime: Date | string
    closingTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutDivisionInput
    services?: ServiceUncheckedCreateNestedManyWithoutDivisionInput
    admins?: EmployeeUncheckedCreateNestedManyWithoutDivisionsInput
    logs?: UpdateLogUncheckedCreateNestedManyWithoutDivisionInput
  }

  export type DivisionCreateOrConnectWithoutFacilityInput = {
    where: DivisionWhereUniqueInput
    create: XOR<DivisionCreateWithoutFacilityInput, DivisionUncheckedCreateWithoutFacilityInput>
  }

  export type DivisionCreateManyFacilityInputEnvelope = {
    data: DivisionCreateManyFacilityInput | DivisionCreateManyFacilityInput[]
    skipDuplicates?: boolean
  }

  export type UpdateLogCreateWithoutFacilityInput = {
    updateLogID?: string
    entity: string
    action: $Enums.Action
    createdAt?: Date | string
    division?: DivisionCreateNestedOneWithoutLogsInput
    employee: EmployeeCreateNestedOneWithoutUpdateLogInput
  }

  export type UpdateLogUncheckedCreateWithoutFacilityInput = {
    updateLogID?: string
    entity: string
    action: $Enums.Action
    createdAt?: Date | string
    divisionID?: string | null
    employeeID: string
  }

  export type UpdateLogCreateOrConnectWithoutFacilityInput = {
    where: UpdateLogWhereUniqueInput
    create: XOR<UpdateLogCreateWithoutFacilityInput, UpdateLogUncheckedCreateWithoutFacilityInput>
  }

  export type UpdateLogCreateManyFacilityInputEnvelope = {
    data: UpdateLogCreateManyFacilityInput | UpdateLogCreateManyFacilityInput[]
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithoutFacilityInput = {
    update: XOR<AddressUpdateWithoutFacilityInput, AddressUncheckedUpdateWithoutFacilityInput>
    create: XOR<AddressCreateWithoutFacilityInput, AddressUncheckedCreateWithoutFacilityInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutFacilityInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutFacilityInput, AddressUncheckedUpdateWithoutFacilityInput>
  }

  export type AddressUpdateWithoutFacilityInput = {
    street?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutAddressesNestedInput
    pOrC?: POrCUpdateOneRequiredWithoutAddressesNestedInput
    cOrM?: COrMUpdateOneRequiredWithoutAddressesNestedInput
    brgy?: BrgyUpdateOneRequiredWithoutAddressesNestedInput
  }

  export type AddressUncheckedUpdateWithoutFacilityInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    pOrCID?: IntFieldUpdateOperationsInput | number
    cOrMID?: IntFieldUpdateOperationsInput | number
    brgyID?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
  }

  export type ContactUpsertWithWhereUniqueWithoutFacilityInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutFacilityInput, ContactUncheckedUpdateWithoutFacilityInput>
    create: XOR<ContactCreateWithoutFacilityInput, ContactUncheckedCreateWithoutFacilityInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutFacilityInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutFacilityInput, ContactUncheckedUpdateWithoutFacilityInput>
  }

  export type ContactUpdateManyWithWhereWithoutFacilityInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutFacilityInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    contactID?: StringFilter<"Contact"> | string
    info?: StringFilter<"Contact"> | string
    type?: EnumContactTypeFilter<"Contact"> | $Enums.ContactType
    facilityID?: StringNullableFilter<"Contact"> | string | null
    divisionID?: StringNullableFilter<"Contact"> | string | null
    serviceID?: StringNullableFilter<"Contact"> | string | null
  }

  export type ServiceUpsertWithWhereUniqueWithoutFacilityInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutFacilityInput, ServiceUncheckedUpdateWithoutFacilityInput>
    create: XOR<ServiceCreateWithoutFacilityInput, ServiceUncheckedCreateWithoutFacilityInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutFacilityInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutFacilityInput, ServiceUncheckedUpdateWithoutFacilityInput>
  }

  export type ServiceUpdateManyWithWhereWithoutFacilityInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutFacilityInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    serviceID?: StringFilter<"Service"> | string
    type?: StringFilter<"Service"> | string
    keywords?: StringNullableListFilter<"Service">
    note?: StringNullableFilter<"Service"> | string | null
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    facilityID?: StringFilter<"Service"> | string
    divisionID?: StringNullableFilter<"Service"> | string | null
  }

  export type EmployeeUpsertWithWhereUniqueWithoutFacilityInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutFacilityInput, EmployeeUncheckedUpdateWithoutFacilityInput>
    create: XOR<EmployeeCreateWithoutFacilityInput, EmployeeUncheckedCreateWithoutFacilityInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutFacilityInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutFacilityInput, EmployeeUncheckedUpdateWithoutFacilityInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutFacilityInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutFacilityInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    employeeID?: StringFilter<"Employee"> | string
    password?: StringFilter<"Employee"> | string
    role?: EnumRoleFilter<"Employee"> | $Enums.Role
    fname?: StringFilter<"Employee"> | string
    mname?: StringNullableFilter<"Employee"> | string | null
    lname?: StringFilter<"Employee"> | string
    photo?: StringFilter<"Employee"> | string
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    facilityID?: StringFilter<"Employee"> | string
  }

  export type DivisionUpsertWithWhereUniqueWithoutFacilityInput = {
    where: DivisionWhereUniqueInput
    update: XOR<DivisionUpdateWithoutFacilityInput, DivisionUncheckedUpdateWithoutFacilityInput>
    create: XOR<DivisionCreateWithoutFacilityInput, DivisionUncheckedCreateWithoutFacilityInput>
  }

  export type DivisionUpdateWithWhereUniqueWithoutFacilityInput = {
    where: DivisionWhereUniqueInput
    data: XOR<DivisionUpdateWithoutFacilityInput, DivisionUncheckedUpdateWithoutFacilityInput>
  }

  export type DivisionUpdateManyWithWhereWithoutFacilityInput = {
    where: DivisionScalarWhereInput
    data: XOR<DivisionUpdateManyMutationInput, DivisionUncheckedUpdateManyWithoutFacilityInput>
  }

  export type DivisionScalarWhereInput = {
    AND?: DivisionScalarWhereInput | DivisionScalarWhereInput[]
    OR?: DivisionScalarWhereInput[]
    NOT?: DivisionScalarWhereInput | DivisionScalarWhereInput[]
    divisionID?: StringFilter<"Division"> | string
    name?: StringFilter<"Division"> | string
    openingTime?: DateTimeFilter<"Division"> | Date | string
    closingTime?: DateTimeFilter<"Division"> | Date | string
    createdAt?: DateTimeFilter<"Division"> | Date | string
    updatedAt?: DateTimeFilter<"Division"> | Date | string
    facilityID?: StringFilter<"Division"> | string
  }

  export type UpdateLogUpsertWithWhereUniqueWithoutFacilityInput = {
    where: UpdateLogWhereUniqueInput
    update: XOR<UpdateLogUpdateWithoutFacilityInput, UpdateLogUncheckedUpdateWithoutFacilityInput>
    create: XOR<UpdateLogCreateWithoutFacilityInput, UpdateLogUncheckedCreateWithoutFacilityInput>
  }

  export type UpdateLogUpdateWithWhereUniqueWithoutFacilityInput = {
    where: UpdateLogWhereUniqueInput
    data: XOR<UpdateLogUpdateWithoutFacilityInput, UpdateLogUncheckedUpdateWithoutFacilityInput>
  }

  export type UpdateLogUpdateManyWithWhereWithoutFacilityInput = {
    where: UpdateLogScalarWhereInput
    data: XOR<UpdateLogUpdateManyMutationInput, UpdateLogUncheckedUpdateManyWithoutFacilityInput>
  }

  export type UpdateLogScalarWhereInput = {
    AND?: UpdateLogScalarWhereInput | UpdateLogScalarWhereInput[]
    OR?: UpdateLogScalarWhereInput[]
    NOT?: UpdateLogScalarWhereInput | UpdateLogScalarWhereInput[]
    updateLogID?: StringFilter<"UpdateLog"> | string
    entity?: StringFilter<"UpdateLog"> | string
    action?: EnumActionFilter<"UpdateLog"> | $Enums.Action
    createdAt?: DateTimeFilter<"UpdateLog"> | Date | string
    facilityID?: StringFilter<"UpdateLog"> | string
    divisionID?: StringNullableFilter<"UpdateLog"> | string | null
    employeeID?: StringFilter<"UpdateLog"> | string
  }

  export type ContactCreateWithoutDivisionInput = {
    contactID?: string
    info: string
    type: $Enums.ContactType
    facility?: FacilityCreateNestedOneWithoutContactsInput
    service?: ServiceCreateNestedOneWithoutPhoneNumbersInput
  }

  export type ContactUncheckedCreateWithoutDivisionInput = {
    contactID?: string
    info: string
    type: $Enums.ContactType
    facilityID?: string | null
    serviceID?: string | null
  }

  export type ContactCreateOrConnectWithoutDivisionInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutDivisionInput, ContactUncheckedCreateWithoutDivisionInput>
  }

  export type ContactCreateManyDivisionInputEnvelope = {
    data: ContactCreateManyDivisionInput | ContactCreateManyDivisionInput[]
    skipDuplicates?: boolean
  }

  export type FacilityCreateWithoutDivisionsInput = {
    facilityID?: string
    name: string
    photo: string
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    facilityType: $Enums.FacilityType
    ownership: $Enums.Ownership
    bookingSystem?: string | null
    acceptedProviders?: FacilityCreateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: Date | string
    address?: AddressCreateNestedOneWithoutFacilityInput
    contacts?: ContactCreateNestedManyWithoutFacilityInput
    services?: ServiceCreateNestedManyWithoutFacilityInput
    employees?: EmployeeCreateNestedManyWithoutFacilityInput
    logs?: UpdateLogCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutDivisionsInput = {
    facilityID?: string
    name: string
    photo: string
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    facilityType: $Enums.FacilityType
    ownership: $Enums.Ownership
    bookingSystem?: string | null
    acceptedProviders?: FacilityCreateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: Date | string
    address?: AddressUncheckedCreateNestedOneWithoutFacilityInput
    contacts?: ContactUncheckedCreateNestedManyWithoutFacilityInput
    services?: ServiceUncheckedCreateNestedManyWithoutFacilityInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutFacilityInput
    logs?: UpdateLogUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutDivisionsInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutDivisionsInput, FacilityUncheckedCreateWithoutDivisionsInput>
  }

  export type ServiceCreateWithoutDivisionInput = {
    serviceID?: string
    type: string
    keywords?: ServiceCreatekeywordsInput | string[]
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumbers?: ContactCreateNestedManyWithoutServiceInput
    facility: FacilityCreateNestedOneWithoutServicesInput
    ambulanceService?: AmbulanceServiceCreateNestedOneWithoutServiceInput
    bloodBankService?: BloodBankServiceCreateNestedOneWithoutServiceInput
    erService?: ERServiceCreateNestedOneWithoutServiceInput
    icuService?: ICUServiceCreateNestedOneWithoutServiceInput
    outpatientService?: OutpatientServiceCreateNestedOneWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutDivisionInput = {
    serviceID?: string
    type: string
    keywords?: ServiceCreatekeywordsInput | string[]
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilityID: string
    phoneNumbers?: ContactUncheckedCreateNestedManyWithoutServiceInput
    ambulanceService?: AmbulanceServiceUncheckedCreateNestedOneWithoutServiceInput
    bloodBankService?: BloodBankServiceUncheckedCreateNestedOneWithoutServiceInput
    erService?: ERServiceUncheckedCreateNestedOneWithoutServiceInput
    icuService?: ICUServiceUncheckedCreateNestedOneWithoutServiceInput
    outpatientService?: OutpatientServiceUncheckedCreateNestedOneWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutDivisionInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutDivisionInput, ServiceUncheckedCreateWithoutDivisionInput>
  }

  export type ServiceCreateManyDivisionInputEnvelope = {
    data: ServiceCreateManyDivisionInput | ServiceCreateManyDivisionInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutDivisionsInput = {
    employeeID?: string
    password: string
    role: $Enums.Role
    fname: string
    mname?: string | null
    lname: string
    photo?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutEmployeeInput
    facility: FacilityCreateNestedOneWithoutEmployeesInput
    updateLog?: UpdateLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutDivisionsInput = {
    employeeID?: string
    password: string
    role: $Enums.Role
    fname: string
    mname?: string | null
    lname: string
    photo?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    facilityID: string
    sessions?: SessionUncheckedCreateNestedManyWithoutEmployeeInput
    updateLog?: UpdateLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutDivisionsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDivisionsInput, EmployeeUncheckedCreateWithoutDivisionsInput>
  }

  export type UpdateLogCreateWithoutDivisionInput = {
    updateLogID?: string
    entity: string
    action: $Enums.Action
    createdAt?: Date | string
    facility: FacilityCreateNestedOneWithoutLogsInput
    employee: EmployeeCreateNestedOneWithoutUpdateLogInput
  }

  export type UpdateLogUncheckedCreateWithoutDivisionInput = {
    updateLogID?: string
    entity: string
    action: $Enums.Action
    createdAt?: Date | string
    facilityID: string
    employeeID: string
  }

  export type UpdateLogCreateOrConnectWithoutDivisionInput = {
    where: UpdateLogWhereUniqueInput
    create: XOR<UpdateLogCreateWithoutDivisionInput, UpdateLogUncheckedCreateWithoutDivisionInput>
  }

  export type UpdateLogCreateManyDivisionInputEnvelope = {
    data: UpdateLogCreateManyDivisionInput | UpdateLogCreateManyDivisionInput[]
    skipDuplicates?: boolean
  }

  export type ContactUpsertWithWhereUniqueWithoutDivisionInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutDivisionInput, ContactUncheckedUpdateWithoutDivisionInput>
    create: XOR<ContactCreateWithoutDivisionInput, ContactUncheckedCreateWithoutDivisionInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutDivisionInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutDivisionInput, ContactUncheckedUpdateWithoutDivisionInput>
  }

  export type ContactUpdateManyWithWhereWithoutDivisionInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutDivisionInput>
  }

  export type FacilityUpsertWithoutDivisionsInput = {
    update: XOR<FacilityUpdateWithoutDivisionsInput, FacilityUncheckedUpdateWithoutDivisionsInput>
    create: XOR<FacilityCreateWithoutDivisionsInput, FacilityUncheckedCreateWithoutDivisionsInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutDivisionsInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutDivisionsInput, FacilityUncheckedUpdateWithoutDivisionsInput>
  }

  export type FacilityUpdateWithoutDivisionsInput = {
    facilityID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityType?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    ownership?: EnumOwnershipFieldUpdateOperationsInput | $Enums.Ownership
    bookingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedProviders?: FacilityUpdateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateOneWithoutFacilityNestedInput
    contacts?: ContactUpdateManyWithoutFacilityNestedInput
    services?: ServiceUpdateManyWithoutFacilityNestedInput
    employees?: EmployeeUpdateManyWithoutFacilityNestedInput
    logs?: UpdateLogUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutDivisionsInput = {
    facilityID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityType?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    ownership?: EnumOwnershipFieldUpdateOperationsInput | $Enums.Ownership
    bookingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedProviders?: FacilityUpdateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUncheckedUpdateOneWithoutFacilityNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutFacilityNestedInput
    services?: ServiceUncheckedUpdateManyWithoutFacilityNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutFacilityNestedInput
    logs?: UpdateLogUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type ServiceUpsertWithWhereUniqueWithoutDivisionInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutDivisionInput, ServiceUncheckedUpdateWithoutDivisionInput>
    create: XOR<ServiceCreateWithoutDivisionInput, ServiceUncheckedCreateWithoutDivisionInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutDivisionInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutDivisionInput, ServiceUncheckedUpdateWithoutDivisionInput>
  }

  export type ServiceUpdateManyWithWhereWithoutDivisionInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutDivisionInput>
  }

  export type EmployeeUpsertWithWhereUniqueWithoutDivisionsInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutDivisionsInput, EmployeeUncheckedUpdateWithoutDivisionsInput>
    create: XOR<EmployeeCreateWithoutDivisionsInput, EmployeeUncheckedCreateWithoutDivisionsInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutDivisionsInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutDivisionsInput, EmployeeUncheckedUpdateWithoutDivisionsInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutDivisionsInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutDivisionsInput>
  }

  export type UpdateLogUpsertWithWhereUniqueWithoutDivisionInput = {
    where: UpdateLogWhereUniqueInput
    update: XOR<UpdateLogUpdateWithoutDivisionInput, UpdateLogUncheckedUpdateWithoutDivisionInput>
    create: XOR<UpdateLogCreateWithoutDivisionInput, UpdateLogUncheckedCreateWithoutDivisionInput>
  }

  export type UpdateLogUpdateWithWhereUniqueWithoutDivisionInput = {
    where: UpdateLogWhereUniqueInput
    data: XOR<UpdateLogUpdateWithoutDivisionInput, UpdateLogUncheckedUpdateWithoutDivisionInput>
  }

  export type UpdateLogUpdateManyWithWhereWithoutDivisionInput = {
    where: UpdateLogScalarWhereInput
    data: XOR<UpdateLogUpdateManyMutationInput, UpdateLogUncheckedUpdateManyWithoutDivisionInput>
  }

  export type SessionCreateWithoutEmployeeInput = {
    sessionID: string
    expiresAt: Date | string
  }

  export type SessionUncheckedCreateWithoutEmployeeInput = {
    sessionID: string
    expiresAt: Date | string
  }

  export type SessionCreateOrConnectWithoutEmployeeInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutEmployeeInput, SessionUncheckedCreateWithoutEmployeeInput>
  }

  export type SessionCreateManyEmployeeInputEnvelope = {
    data: SessionCreateManyEmployeeInput | SessionCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type FacilityCreateWithoutEmployeesInput = {
    facilityID?: string
    name: string
    photo: string
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    facilityType: $Enums.FacilityType
    ownership: $Enums.Ownership
    bookingSystem?: string | null
    acceptedProviders?: FacilityCreateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: Date | string
    address?: AddressCreateNestedOneWithoutFacilityInput
    contacts?: ContactCreateNestedManyWithoutFacilityInput
    services?: ServiceCreateNestedManyWithoutFacilityInput
    divisions?: DivisionCreateNestedManyWithoutFacilityInput
    logs?: UpdateLogCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutEmployeesInput = {
    facilityID?: string
    name: string
    photo: string
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    facilityType: $Enums.FacilityType
    ownership: $Enums.Ownership
    bookingSystem?: string | null
    acceptedProviders?: FacilityCreateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: Date | string
    address?: AddressUncheckedCreateNestedOneWithoutFacilityInput
    contacts?: ContactUncheckedCreateNestedManyWithoutFacilityInput
    services?: ServiceUncheckedCreateNestedManyWithoutFacilityInput
    divisions?: DivisionUncheckedCreateNestedManyWithoutFacilityInput
    logs?: UpdateLogUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutEmployeesInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutEmployeesInput, FacilityUncheckedCreateWithoutEmployeesInput>
  }

  export type DivisionCreateWithoutAdminsInput = {
    divisionID?: string
    name: string
    openingTime: Date | string
    closingTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutDivisionInput
    facility: FacilityCreateNestedOneWithoutDivisionsInput
    services?: ServiceCreateNestedManyWithoutDivisionInput
    logs?: UpdateLogCreateNestedManyWithoutDivisionInput
  }

  export type DivisionUncheckedCreateWithoutAdminsInput = {
    divisionID?: string
    name: string
    openingTime: Date | string
    closingTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    facilityID: string
    contacts?: ContactUncheckedCreateNestedManyWithoutDivisionInput
    services?: ServiceUncheckedCreateNestedManyWithoutDivisionInput
    logs?: UpdateLogUncheckedCreateNestedManyWithoutDivisionInput
  }

  export type DivisionCreateOrConnectWithoutAdminsInput = {
    where: DivisionWhereUniqueInput
    create: XOR<DivisionCreateWithoutAdminsInput, DivisionUncheckedCreateWithoutAdminsInput>
  }

  export type UpdateLogCreateWithoutEmployeeInput = {
    updateLogID?: string
    entity: string
    action: $Enums.Action
    createdAt?: Date | string
    facility: FacilityCreateNestedOneWithoutLogsInput
    division?: DivisionCreateNestedOneWithoutLogsInput
  }

  export type UpdateLogUncheckedCreateWithoutEmployeeInput = {
    updateLogID?: string
    entity: string
    action: $Enums.Action
    createdAt?: Date | string
    facilityID: string
    divisionID?: string | null
  }

  export type UpdateLogCreateOrConnectWithoutEmployeeInput = {
    where: UpdateLogWhereUniqueInput
    create: XOR<UpdateLogCreateWithoutEmployeeInput, UpdateLogUncheckedCreateWithoutEmployeeInput>
  }

  export type UpdateLogCreateManyEmployeeInputEnvelope = {
    data: UpdateLogCreateManyEmployeeInput | UpdateLogCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutEmployeeInput, SessionUncheckedUpdateWithoutEmployeeInput>
    create: XOR<SessionCreateWithoutEmployeeInput, SessionUncheckedCreateWithoutEmployeeInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutEmployeeInput, SessionUncheckedUpdateWithoutEmployeeInput>
  }

  export type SessionUpdateManyWithWhereWithoutEmployeeInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    sessionID?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    employeeID?: StringFilter<"Session"> | string
  }

  export type FacilityUpsertWithoutEmployeesInput = {
    update: XOR<FacilityUpdateWithoutEmployeesInput, FacilityUncheckedUpdateWithoutEmployeesInput>
    create: XOR<FacilityCreateWithoutEmployeesInput, FacilityUncheckedCreateWithoutEmployeesInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutEmployeesInput, FacilityUncheckedUpdateWithoutEmployeesInput>
  }

  export type FacilityUpdateWithoutEmployeesInput = {
    facilityID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityType?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    ownership?: EnumOwnershipFieldUpdateOperationsInput | $Enums.Ownership
    bookingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedProviders?: FacilityUpdateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateOneWithoutFacilityNestedInput
    contacts?: ContactUpdateManyWithoutFacilityNestedInput
    services?: ServiceUpdateManyWithoutFacilityNestedInput
    divisions?: DivisionUpdateManyWithoutFacilityNestedInput
    logs?: UpdateLogUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutEmployeesInput = {
    facilityID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityType?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    ownership?: EnumOwnershipFieldUpdateOperationsInput | $Enums.Ownership
    bookingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedProviders?: FacilityUpdateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUncheckedUpdateOneWithoutFacilityNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutFacilityNestedInput
    services?: ServiceUncheckedUpdateManyWithoutFacilityNestedInput
    divisions?: DivisionUncheckedUpdateManyWithoutFacilityNestedInput
    logs?: UpdateLogUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type DivisionUpsertWithWhereUniqueWithoutAdminsInput = {
    where: DivisionWhereUniqueInput
    update: XOR<DivisionUpdateWithoutAdminsInput, DivisionUncheckedUpdateWithoutAdminsInput>
    create: XOR<DivisionCreateWithoutAdminsInput, DivisionUncheckedCreateWithoutAdminsInput>
  }

  export type DivisionUpdateWithWhereUniqueWithoutAdminsInput = {
    where: DivisionWhereUniqueInput
    data: XOR<DivisionUpdateWithoutAdminsInput, DivisionUncheckedUpdateWithoutAdminsInput>
  }

  export type DivisionUpdateManyWithWhereWithoutAdminsInput = {
    where: DivisionScalarWhereInput
    data: XOR<DivisionUpdateManyMutationInput, DivisionUncheckedUpdateManyWithoutAdminsInput>
  }

  export type UpdateLogUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: UpdateLogWhereUniqueInput
    update: XOR<UpdateLogUpdateWithoutEmployeeInput, UpdateLogUncheckedUpdateWithoutEmployeeInput>
    create: XOR<UpdateLogCreateWithoutEmployeeInput, UpdateLogUncheckedCreateWithoutEmployeeInput>
  }

  export type UpdateLogUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: UpdateLogWhereUniqueInput
    data: XOR<UpdateLogUpdateWithoutEmployeeInput, UpdateLogUncheckedUpdateWithoutEmployeeInput>
  }

  export type UpdateLogUpdateManyWithWhereWithoutEmployeeInput = {
    where: UpdateLogScalarWhereInput
    data: XOR<UpdateLogUpdateManyMutationInput, UpdateLogUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeCreateWithoutSessionsInput = {
    employeeID?: string
    password: string
    role: $Enums.Role
    fname: string
    mname?: string | null
    lname: string
    photo?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    facility: FacilityCreateNestedOneWithoutEmployeesInput
    divisions?: DivisionCreateNestedManyWithoutAdminsInput
    updateLog?: UpdateLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutSessionsInput = {
    employeeID?: string
    password: string
    role: $Enums.Role
    fname: string
    mname?: string | null
    lname: string
    photo?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    facilityID: string
    divisions?: DivisionUncheckedCreateNestedManyWithoutAdminsInput
    updateLog?: UpdateLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutSessionsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutSessionsInput, EmployeeUncheckedCreateWithoutSessionsInput>
  }

  export type EmployeeUpsertWithoutSessionsInput = {
    update: XOR<EmployeeUpdateWithoutSessionsInput, EmployeeUncheckedUpdateWithoutSessionsInput>
    create: XOR<EmployeeCreateWithoutSessionsInput, EmployeeUncheckedCreateWithoutSessionsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutSessionsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutSessionsInput, EmployeeUncheckedUpdateWithoutSessionsInput>
  }

  export type EmployeeUpdateWithoutSessionsInput = {
    employeeID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    fname?: StringFieldUpdateOperationsInput | string
    mname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneRequiredWithoutEmployeesNestedInput
    divisions?: DivisionUpdateManyWithoutAdminsNestedInput
    updateLog?: UpdateLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutSessionsInput = {
    employeeID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    fname?: StringFieldUpdateOperationsInput | string
    mname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
    divisions?: DivisionUncheckedUpdateManyWithoutAdminsNestedInput
    updateLog?: UpdateLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type ContactCreateWithoutServiceInput = {
    contactID?: string
    info: string
    type: $Enums.ContactType
    facility?: FacilityCreateNestedOneWithoutContactsInput
    division?: DivisionCreateNestedOneWithoutContactsInput
  }

  export type ContactUncheckedCreateWithoutServiceInput = {
    contactID?: string
    info: string
    type: $Enums.ContactType
    facilityID?: string | null
    divisionID?: string | null
  }

  export type ContactCreateOrConnectWithoutServiceInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutServiceInput, ContactUncheckedCreateWithoutServiceInput>
  }

  export type ContactCreateManyServiceInputEnvelope = {
    data: ContactCreateManyServiceInput | ContactCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type FacilityCreateWithoutServicesInput = {
    facilityID?: string
    name: string
    photo: string
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    facilityType: $Enums.FacilityType
    ownership: $Enums.Ownership
    bookingSystem?: string | null
    acceptedProviders?: FacilityCreateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: Date | string
    address?: AddressCreateNestedOneWithoutFacilityInput
    contacts?: ContactCreateNestedManyWithoutFacilityInput
    employees?: EmployeeCreateNestedManyWithoutFacilityInput
    divisions?: DivisionCreateNestedManyWithoutFacilityInput
    logs?: UpdateLogCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutServicesInput = {
    facilityID?: string
    name: string
    photo: string
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    facilityType: $Enums.FacilityType
    ownership: $Enums.Ownership
    bookingSystem?: string | null
    acceptedProviders?: FacilityCreateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: Date | string
    address?: AddressUncheckedCreateNestedOneWithoutFacilityInput
    contacts?: ContactUncheckedCreateNestedManyWithoutFacilityInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutFacilityInput
    divisions?: DivisionUncheckedCreateNestedManyWithoutFacilityInput
    logs?: UpdateLogUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutServicesInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutServicesInput, FacilityUncheckedCreateWithoutServicesInput>
  }

  export type DivisionCreateWithoutServicesInput = {
    divisionID?: string
    name: string
    openingTime: Date | string
    closingTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutDivisionInput
    facility: FacilityCreateNestedOneWithoutDivisionsInput
    admins?: EmployeeCreateNestedManyWithoutDivisionsInput
    logs?: UpdateLogCreateNestedManyWithoutDivisionInput
  }

  export type DivisionUncheckedCreateWithoutServicesInput = {
    divisionID?: string
    name: string
    openingTime: Date | string
    closingTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    facilityID: string
    contacts?: ContactUncheckedCreateNestedManyWithoutDivisionInput
    admins?: EmployeeUncheckedCreateNestedManyWithoutDivisionsInput
    logs?: UpdateLogUncheckedCreateNestedManyWithoutDivisionInput
  }

  export type DivisionCreateOrConnectWithoutServicesInput = {
    where: DivisionWhereUniqueInput
    create: XOR<DivisionCreateWithoutServicesInput, DivisionUncheckedCreateWithoutServicesInput>
  }

  export type AmbulanceServiceCreateWithoutServiceInput = {
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    availability?: $Enums.Availability
    baseRate: number
    minCoverageRadius: number
    mileageRate: number
    maxCoverageRadius: number
  }

  export type AmbulanceServiceUncheckedCreateWithoutServiceInput = {
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    availability?: $Enums.Availability
    baseRate: number
    minCoverageRadius: number
    mileageRate: number
    maxCoverageRadius: number
  }

  export type AmbulanceServiceCreateOrConnectWithoutServiceInput = {
    where: AmbulanceServiceWhereUniqueInput
    create: XOR<AmbulanceServiceCreateWithoutServiceInput, AmbulanceServiceUncheckedCreateWithoutServiceInput>
  }

  export type BloodBankServiceCreateWithoutServiceInput = {
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    basePricePerUnit: number
    turnaroundTimeD: number
    turnaroundTimeH: number
    bloodTypeAvailability?: BloodTypeMappingCreateNestedOneWithoutBloodBankServiceInput
  }

  export type BloodBankServiceUncheckedCreateWithoutServiceInput = {
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    basePricePerUnit: number
    turnaroundTimeD: number
    turnaroundTimeH: number
    bloodTypeAvailability?: BloodTypeMappingUncheckedCreateNestedOneWithoutBloodBankServiceInput
  }

  export type BloodBankServiceCreateOrConnectWithoutServiceInput = {
    where: BloodBankServiceWhereUniqueInput
    create: XOR<BloodBankServiceCreateWithoutServiceInput, BloodBankServiceUncheckedCreateWithoutServiceInput>
  }

  export type ERServiceCreateWithoutServiceInput = {
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    load?: $Enums.Load
    availableBeds?: number
    nonUrgentPatients?: number
    nonUrgentQueueLength?: number
    urgentPatients?: number
    urgentQueueLength?: number
    criticalPatients?: number
    criticalQueueLength?: number
  }

  export type ERServiceUncheckedCreateWithoutServiceInput = {
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    load?: $Enums.Load
    availableBeds?: number
    nonUrgentPatients?: number
    nonUrgentQueueLength?: number
    urgentPatients?: number
    urgentQueueLength?: number
    criticalPatients?: number
    criticalQueueLength?: number
  }

  export type ERServiceCreateOrConnectWithoutServiceInput = {
    where: ERServiceWhereUniqueInput
    create: XOR<ERServiceCreateWithoutServiceInput, ERServiceUncheckedCreateWithoutServiceInput>
  }

  export type ICUServiceCreateWithoutServiceInput = {
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    load?: $Enums.Load
    baseRate: number
    availableBeds?: number
    cardiacSupport?: boolean
    neurologicalSupport?: boolean
    renalSupport?: boolean
    respiratorySupport?: boolean
  }

  export type ICUServiceUncheckedCreateWithoutServiceInput = {
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    load?: $Enums.Load
    baseRate: number
    availableBeds?: number
    cardiacSupport?: boolean
    neurologicalSupport?: boolean
    renalSupport?: boolean
    respiratorySupport?: boolean
  }

  export type ICUServiceCreateOrConnectWithoutServiceInput = {
    where: ICUServiceWhereUniqueInput
    create: XOR<ICUServiceCreateWithoutServiceInput, ICUServiceUncheckedCreateWithoutServiceInput>
  }

  export type OutpatientServiceCreateWithoutServiceInput = {
    basePrice: number
    completionTimeD: number
    completionTimeH: number
    isAvailable?: boolean
    acceptsWalkIns: boolean
  }

  export type OutpatientServiceUncheckedCreateWithoutServiceInput = {
    basePrice: number
    completionTimeD: number
    completionTimeH: number
    isAvailable?: boolean
    acceptsWalkIns: boolean
  }

  export type OutpatientServiceCreateOrConnectWithoutServiceInput = {
    where: OutpatientServiceWhereUniqueInput
    create: XOR<OutpatientServiceCreateWithoutServiceInput, OutpatientServiceUncheckedCreateWithoutServiceInput>
  }

  export type ContactUpsertWithWhereUniqueWithoutServiceInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutServiceInput, ContactUncheckedUpdateWithoutServiceInput>
    create: XOR<ContactCreateWithoutServiceInput, ContactUncheckedCreateWithoutServiceInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutServiceInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutServiceInput, ContactUncheckedUpdateWithoutServiceInput>
  }

  export type ContactUpdateManyWithWhereWithoutServiceInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutServiceInput>
  }

  export type FacilityUpsertWithoutServicesInput = {
    update: XOR<FacilityUpdateWithoutServicesInput, FacilityUncheckedUpdateWithoutServicesInput>
    create: XOR<FacilityCreateWithoutServicesInput, FacilityUncheckedCreateWithoutServicesInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutServicesInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutServicesInput, FacilityUncheckedUpdateWithoutServicesInput>
  }

  export type FacilityUpdateWithoutServicesInput = {
    facilityID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityType?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    ownership?: EnumOwnershipFieldUpdateOperationsInput | $Enums.Ownership
    bookingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedProviders?: FacilityUpdateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateOneWithoutFacilityNestedInput
    contacts?: ContactUpdateManyWithoutFacilityNestedInput
    employees?: EmployeeUpdateManyWithoutFacilityNestedInput
    divisions?: DivisionUpdateManyWithoutFacilityNestedInput
    logs?: UpdateLogUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutServicesInput = {
    facilityID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityType?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    ownership?: EnumOwnershipFieldUpdateOperationsInput | $Enums.Ownership
    bookingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedProviders?: FacilityUpdateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUncheckedUpdateOneWithoutFacilityNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutFacilityNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutFacilityNestedInput
    divisions?: DivisionUncheckedUpdateManyWithoutFacilityNestedInput
    logs?: UpdateLogUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type DivisionUpsertWithoutServicesInput = {
    update: XOR<DivisionUpdateWithoutServicesInput, DivisionUncheckedUpdateWithoutServicesInput>
    create: XOR<DivisionCreateWithoutServicesInput, DivisionUncheckedCreateWithoutServicesInput>
    where?: DivisionWhereInput
  }

  export type DivisionUpdateToOneWithWhereWithoutServicesInput = {
    where?: DivisionWhereInput
    data: XOR<DivisionUpdateWithoutServicesInput, DivisionUncheckedUpdateWithoutServicesInput>
  }

  export type DivisionUpdateWithoutServicesInput = {
    divisionID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    openingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutDivisionNestedInput
    facility?: FacilityUpdateOneRequiredWithoutDivisionsNestedInput
    admins?: EmployeeUpdateManyWithoutDivisionsNestedInput
    logs?: UpdateLogUpdateManyWithoutDivisionNestedInput
  }

  export type DivisionUncheckedUpdateWithoutServicesInput = {
    divisionID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    openingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
    contacts?: ContactUncheckedUpdateManyWithoutDivisionNestedInput
    admins?: EmployeeUncheckedUpdateManyWithoutDivisionsNestedInput
    logs?: UpdateLogUncheckedUpdateManyWithoutDivisionNestedInput
  }

  export type AmbulanceServiceUpsertWithoutServiceInput = {
    update: XOR<AmbulanceServiceUpdateWithoutServiceInput, AmbulanceServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<AmbulanceServiceCreateWithoutServiceInput, AmbulanceServiceUncheckedCreateWithoutServiceInput>
    where?: AmbulanceServiceWhereInput
  }

  export type AmbulanceServiceUpdateToOneWithWhereWithoutServiceInput = {
    where?: AmbulanceServiceWhereInput
    data: XOR<AmbulanceServiceUpdateWithoutServiceInput, AmbulanceServiceUncheckedUpdateWithoutServiceInput>
  }

  export type AmbulanceServiceUpdateWithoutServiceInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availability?: EnumAvailabilityFieldUpdateOperationsInput | $Enums.Availability
    baseRate?: FloatFieldUpdateOperationsInput | number
    minCoverageRadius?: FloatFieldUpdateOperationsInput | number
    mileageRate?: FloatFieldUpdateOperationsInput | number
    maxCoverageRadius?: FloatFieldUpdateOperationsInput | number
  }

  export type AmbulanceServiceUncheckedUpdateWithoutServiceInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availability?: EnumAvailabilityFieldUpdateOperationsInput | $Enums.Availability
    baseRate?: FloatFieldUpdateOperationsInput | number
    minCoverageRadius?: FloatFieldUpdateOperationsInput | number
    mileageRate?: FloatFieldUpdateOperationsInput | number
    maxCoverageRadius?: FloatFieldUpdateOperationsInput | number
  }

  export type BloodBankServiceUpsertWithoutServiceInput = {
    update: XOR<BloodBankServiceUpdateWithoutServiceInput, BloodBankServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<BloodBankServiceCreateWithoutServiceInput, BloodBankServiceUncheckedCreateWithoutServiceInput>
    where?: BloodBankServiceWhereInput
  }

  export type BloodBankServiceUpdateToOneWithWhereWithoutServiceInput = {
    where?: BloodBankServiceWhereInput
    data: XOR<BloodBankServiceUpdateWithoutServiceInput, BloodBankServiceUncheckedUpdateWithoutServiceInput>
  }

  export type BloodBankServiceUpdateWithoutServiceInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    basePricePerUnit?: FloatFieldUpdateOperationsInput | number
    turnaroundTimeD?: IntFieldUpdateOperationsInput | number
    turnaroundTimeH?: IntFieldUpdateOperationsInput | number
    bloodTypeAvailability?: BloodTypeMappingUpdateOneWithoutBloodBankServiceNestedInput
  }

  export type BloodBankServiceUncheckedUpdateWithoutServiceInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    basePricePerUnit?: FloatFieldUpdateOperationsInput | number
    turnaroundTimeD?: IntFieldUpdateOperationsInput | number
    turnaroundTimeH?: IntFieldUpdateOperationsInput | number
    bloodTypeAvailability?: BloodTypeMappingUncheckedUpdateOneWithoutBloodBankServiceNestedInput
  }

  export type ERServiceUpsertWithoutServiceInput = {
    update: XOR<ERServiceUpdateWithoutServiceInput, ERServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<ERServiceCreateWithoutServiceInput, ERServiceUncheckedCreateWithoutServiceInput>
    where?: ERServiceWhereInput
  }

  export type ERServiceUpdateToOneWithWhereWithoutServiceInput = {
    where?: ERServiceWhereInput
    data: XOR<ERServiceUpdateWithoutServiceInput, ERServiceUncheckedUpdateWithoutServiceInput>
  }

  export type ERServiceUpdateWithoutServiceInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    load?: EnumLoadFieldUpdateOperationsInput | $Enums.Load
    availableBeds?: IntFieldUpdateOperationsInput | number
    nonUrgentPatients?: IntFieldUpdateOperationsInput | number
    nonUrgentQueueLength?: IntFieldUpdateOperationsInput | number
    urgentPatients?: IntFieldUpdateOperationsInput | number
    urgentQueueLength?: IntFieldUpdateOperationsInput | number
    criticalPatients?: IntFieldUpdateOperationsInput | number
    criticalQueueLength?: IntFieldUpdateOperationsInput | number
  }

  export type ERServiceUncheckedUpdateWithoutServiceInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    load?: EnumLoadFieldUpdateOperationsInput | $Enums.Load
    availableBeds?: IntFieldUpdateOperationsInput | number
    nonUrgentPatients?: IntFieldUpdateOperationsInput | number
    nonUrgentQueueLength?: IntFieldUpdateOperationsInput | number
    urgentPatients?: IntFieldUpdateOperationsInput | number
    urgentQueueLength?: IntFieldUpdateOperationsInput | number
    criticalPatients?: IntFieldUpdateOperationsInput | number
    criticalQueueLength?: IntFieldUpdateOperationsInput | number
  }

  export type ICUServiceUpsertWithoutServiceInput = {
    update: XOR<ICUServiceUpdateWithoutServiceInput, ICUServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<ICUServiceCreateWithoutServiceInput, ICUServiceUncheckedCreateWithoutServiceInput>
    where?: ICUServiceWhereInput
  }

  export type ICUServiceUpdateToOneWithWhereWithoutServiceInput = {
    where?: ICUServiceWhereInput
    data: XOR<ICUServiceUpdateWithoutServiceInput, ICUServiceUncheckedUpdateWithoutServiceInput>
  }

  export type ICUServiceUpdateWithoutServiceInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    load?: EnumLoadFieldUpdateOperationsInput | $Enums.Load
    baseRate?: FloatFieldUpdateOperationsInput | number
    availableBeds?: IntFieldUpdateOperationsInput | number
    cardiacSupport?: BoolFieldUpdateOperationsInput | boolean
    neurologicalSupport?: BoolFieldUpdateOperationsInput | boolean
    renalSupport?: BoolFieldUpdateOperationsInput | boolean
    respiratorySupport?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ICUServiceUncheckedUpdateWithoutServiceInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    load?: EnumLoadFieldUpdateOperationsInput | $Enums.Load
    baseRate?: FloatFieldUpdateOperationsInput | number
    availableBeds?: IntFieldUpdateOperationsInput | number
    cardiacSupport?: BoolFieldUpdateOperationsInput | boolean
    neurologicalSupport?: BoolFieldUpdateOperationsInput | boolean
    renalSupport?: BoolFieldUpdateOperationsInput | boolean
    respiratorySupport?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OutpatientServiceUpsertWithoutServiceInput = {
    update: XOR<OutpatientServiceUpdateWithoutServiceInput, OutpatientServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<OutpatientServiceCreateWithoutServiceInput, OutpatientServiceUncheckedCreateWithoutServiceInput>
    where?: OutpatientServiceWhereInput
  }

  export type OutpatientServiceUpdateToOneWithWhereWithoutServiceInput = {
    where?: OutpatientServiceWhereInput
    data: XOR<OutpatientServiceUpdateWithoutServiceInput, OutpatientServiceUncheckedUpdateWithoutServiceInput>
  }

  export type OutpatientServiceUpdateWithoutServiceInput = {
    basePrice?: FloatFieldUpdateOperationsInput | number
    completionTimeD?: IntFieldUpdateOperationsInput | number
    completionTimeH?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    acceptsWalkIns?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OutpatientServiceUncheckedUpdateWithoutServiceInput = {
    basePrice?: FloatFieldUpdateOperationsInput | number
    completionTimeD?: IntFieldUpdateOperationsInput | number
    completionTimeH?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    acceptsWalkIns?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceCreateWithoutAmbulanceServiceInput = {
    serviceID?: string
    type: string
    keywords?: ServiceCreatekeywordsInput | string[]
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumbers?: ContactCreateNestedManyWithoutServiceInput
    facility: FacilityCreateNestedOneWithoutServicesInput
    division?: DivisionCreateNestedOneWithoutServicesInput
    bloodBankService?: BloodBankServiceCreateNestedOneWithoutServiceInput
    erService?: ERServiceCreateNestedOneWithoutServiceInput
    icuService?: ICUServiceCreateNestedOneWithoutServiceInput
    outpatientService?: OutpatientServiceCreateNestedOneWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutAmbulanceServiceInput = {
    serviceID?: string
    type: string
    keywords?: ServiceCreatekeywordsInput | string[]
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilityID: string
    divisionID?: string | null
    phoneNumbers?: ContactUncheckedCreateNestedManyWithoutServiceInput
    bloodBankService?: BloodBankServiceUncheckedCreateNestedOneWithoutServiceInput
    erService?: ERServiceUncheckedCreateNestedOneWithoutServiceInput
    icuService?: ICUServiceUncheckedCreateNestedOneWithoutServiceInput
    outpatientService?: OutpatientServiceUncheckedCreateNestedOneWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutAmbulanceServiceInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutAmbulanceServiceInput, ServiceUncheckedCreateWithoutAmbulanceServiceInput>
  }

  export type ServiceUpsertWithoutAmbulanceServiceInput = {
    update: XOR<ServiceUpdateWithoutAmbulanceServiceInput, ServiceUncheckedUpdateWithoutAmbulanceServiceInput>
    create: XOR<ServiceCreateWithoutAmbulanceServiceInput, ServiceUncheckedCreateWithoutAmbulanceServiceInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutAmbulanceServiceInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutAmbulanceServiceInput, ServiceUncheckedUpdateWithoutAmbulanceServiceInput>
  }

  export type ServiceUpdateWithoutAmbulanceServiceInput = {
    serviceID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ServiceUpdatekeywordsInput | string[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumbers?: ContactUpdateManyWithoutServiceNestedInput
    facility?: FacilityUpdateOneRequiredWithoutServicesNestedInput
    division?: DivisionUpdateOneWithoutServicesNestedInput
    bloodBankService?: BloodBankServiceUpdateOneWithoutServiceNestedInput
    erService?: ERServiceUpdateOneWithoutServiceNestedInput
    icuService?: ICUServiceUpdateOneWithoutServiceNestedInput
    outpatientService?: OutpatientServiceUpdateOneWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutAmbulanceServiceInput = {
    serviceID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ServiceUpdatekeywordsInput | string[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
    divisionID?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumbers?: ContactUncheckedUpdateManyWithoutServiceNestedInput
    bloodBankService?: BloodBankServiceUncheckedUpdateOneWithoutServiceNestedInput
    erService?: ERServiceUncheckedUpdateOneWithoutServiceNestedInput
    icuService?: ICUServiceUncheckedUpdateOneWithoutServiceNestedInput
    outpatientService?: OutpatientServiceUncheckedUpdateOneWithoutServiceNestedInput
  }

  export type BloodBankServiceCreateWithoutBloodTypeAvailabilityInput = {
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    basePricePerUnit: number
    turnaroundTimeD: number
    turnaroundTimeH: number
    service: ServiceCreateNestedOneWithoutBloodBankServiceInput
  }

  export type BloodBankServiceUncheckedCreateWithoutBloodTypeAvailabilityInput = {
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    basePricePerUnit: number
    turnaroundTimeD: number
    turnaroundTimeH: number
    serviceID: string
  }

  export type BloodBankServiceCreateOrConnectWithoutBloodTypeAvailabilityInput = {
    where: BloodBankServiceWhereUniqueInput
    create: XOR<BloodBankServiceCreateWithoutBloodTypeAvailabilityInput, BloodBankServiceUncheckedCreateWithoutBloodTypeAvailabilityInput>
  }

  export type BloodBankServiceUpsertWithoutBloodTypeAvailabilityInput = {
    update: XOR<BloodBankServiceUpdateWithoutBloodTypeAvailabilityInput, BloodBankServiceUncheckedUpdateWithoutBloodTypeAvailabilityInput>
    create: XOR<BloodBankServiceCreateWithoutBloodTypeAvailabilityInput, BloodBankServiceUncheckedCreateWithoutBloodTypeAvailabilityInput>
    where?: BloodBankServiceWhereInput
  }

  export type BloodBankServiceUpdateToOneWithWhereWithoutBloodTypeAvailabilityInput = {
    where?: BloodBankServiceWhereInput
    data: XOR<BloodBankServiceUpdateWithoutBloodTypeAvailabilityInput, BloodBankServiceUncheckedUpdateWithoutBloodTypeAvailabilityInput>
  }

  export type BloodBankServiceUpdateWithoutBloodTypeAvailabilityInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    basePricePerUnit?: FloatFieldUpdateOperationsInput | number
    turnaroundTimeD?: IntFieldUpdateOperationsInput | number
    turnaroundTimeH?: IntFieldUpdateOperationsInput | number
    service?: ServiceUpdateOneRequiredWithoutBloodBankServiceNestedInput
  }

  export type BloodBankServiceUncheckedUpdateWithoutBloodTypeAvailabilityInput = {
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    basePricePerUnit?: FloatFieldUpdateOperationsInput | number
    turnaroundTimeD?: IntFieldUpdateOperationsInput | number
    turnaroundTimeH?: IntFieldUpdateOperationsInput | number
    serviceID?: StringFieldUpdateOperationsInput | string
  }

  export type BloodTypeMappingCreateWithoutBloodBankServiceInput = {
    A_P?: boolean
    A_N?: boolean
    B_P?: boolean
    B_N?: boolean
    O_P?: boolean
    O_N?: boolean
    AB_P?: boolean
    AB_N?: boolean
  }

  export type BloodTypeMappingUncheckedCreateWithoutBloodBankServiceInput = {
    A_P?: boolean
    A_N?: boolean
    B_P?: boolean
    B_N?: boolean
    O_P?: boolean
    O_N?: boolean
    AB_P?: boolean
    AB_N?: boolean
  }

  export type BloodTypeMappingCreateOrConnectWithoutBloodBankServiceInput = {
    where: BloodTypeMappingWhereUniqueInput
    create: XOR<BloodTypeMappingCreateWithoutBloodBankServiceInput, BloodTypeMappingUncheckedCreateWithoutBloodBankServiceInput>
  }

  export type ServiceCreateWithoutBloodBankServiceInput = {
    serviceID?: string
    type: string
    keywords?: ServiceCreatekeywordsInput | string[]
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumbers?: ContactCreateNestedManyWithoutServiceInput
    facility: FacilityCreateNestedOneWithoutServicesInput
    division?: DivisionCreateNestedOneWithoutServicesInput
    ambulanceService?: AmbulanceServiceCreateNestedOneWithoutServiceInput
    erService?: ERServiceCreateNestedOneWithoutServiceInput
    icuService?: ICUServiceCreateNestedOneWithoutServiceInput
    outpatientService?: OutpatientServiceCreateNestedOneWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutBloodBankServiceInput = {
    serviceID?: string
    type: string
    keywords?: ServiceCreatekeywordsInput | string[]
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilityID: string
    divisionID?: string | null
    phoneNumbers?: ContactUncheckedCreateNestedManyWithoutServiceInput
    ambulanceService?: AmbulanceServiceUncheckedCreateNestedOneWithoutServiceInput
    erService?: ERServiceUncheckedCreateNestedOneWithoutServiceInput
    icuService?: ICUServiceUncheckedCreateNestedOneWithoutServiceInput
    outpatientService?: OutpatientServiceUncheckedCreateNestedOneWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutBloodBankServiceInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutBloodBankServiceInput, ServiceUncheckedCreateWithoutBloodBankServiceInput>
  }

  export type BloodTypeMappingUpsertWithoutBloodBankServiceInput = {
    update: XOR<BloodTypeMappingUpdateWithoutBloodBankServiceInput, BloodTypeMappingUncheckedUpdateWithoutBloodBankServiceInput>
    create: XOR<BloodTypeMappingCreateWithoutBloodBankServiceInput, BloodTypeMappingUncheckedCreateWithoutBloodBankServiceInput>
    where?: BloodTypeMappingWhereInput
  }

  export type BloodTypeMappingUpdateToOneWithWhereWithoutBloodBankServiceInput = {
    where?: BloodTypeMappingWhereInput
    data: XOR<BloodTypeMappingUpdateWithoutBloodBankServiceInput, BloodTypeMappingUncheckedUpdateWithoutBloodBankServiceInput>
  }

  export type BloodTypeMappingUpdateWithoutBloodBankServiceInput = {
    A_P?: BoolFieldUpdateOperationsInput | boolean
    A_N?: BoolFieldUpdateOperationsInput | boolean
    B_P?: BoolFieldUpdateOperationsInput | boolean
    B_N?: BoolFieldUpdateOperationsInput | boolean
    O_P?: BoolFieldUpdateOperationsInput | boolean
    O_N?: BoolFieldUpdateOperationsInput | boolean
    AB_P?: BoolFieldUpdateOperationsInput | boolean
    AB_N?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BloodTypeMappingUncheckedUpdateWithoutBloodBankServiceInput = {
    A_P?: BoolFieldUpdateOperationsInput | boolean
    A_N?: BoolFieldUpdateOperationsInput | boolean
    B_P?: BoolFieldUpdateOperationsInput | boolean
    B_N?: BoolFieldUpdateOperationsInput | boolean
    O_P?: BoolFieldUpdateOperationsInput | boolean
    O_N?: BoolFieldUpdateOperationsInput | boolean
    AB_P?: BoolFieldUpdateOperationsInput | boolean
    AB_N?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceUpsertWithoutBloodBankServiceInput = {
    update: XOR<ServiceUpdateWithoutBloodBankServiceInput, ServiceUncheckedUpdateWithoutBloodBankServiceInput>
    create: XOR<ServiceCreateWithoutBloodBankServiceInput, ServiceUncheckedCreateWithoutBloodBankServiceInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutBloodBankServiceInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutBloodBankServiceInput, ServiceUncheckedUpdateWithoutBloodBankServiceInput>
  }

  export type ServiceUpdateWithoutBloodBankServiceInput = {
    serviceID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ServiceUpdatekeywordsInput | string[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumbers?: ContactUpdateManyWithoutServiceNestedInput
    facility?: FacilityUpdateOneRequiredWithoutServicesNestedInput
    division?: DivisionUpdateOneWithoutServicesNestedInput
    ambulanceService?: AmbulanceServiceUpdateOneWithoutServiceNestedInput
    erService?: ERServiceUpdateOneWithoutServiceNestedInput
    icuService?: ICUServiceUpdateOneWithoutServiceNestedInput
    outpatientService?: OutpatientServiceUpdateOneWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutBloodBankServiceInput = {
    serviceID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ServiceUpdatekeywordsInput | string[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
    divisionID?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumbers?: ContactUncheckedUpdateManyWithoutServiceNestedInput
    ambulanceService?: AmbulanceServiceUncheckedUpdateOneWithoutServiceNestedInput
    erService?: ERServiceUncheckedUpdateOneWithoutServiceNestedInput
    icuService?: ICUServiceUncheckedUpdateOneWithoutServiceNestedInput
    outpatientService?: OutpatientServiceUncheckedUpdateOneWithoutServiceNestedInput
  }

  export type ServiceCreateWithoutErServiceInput = {
    serviceID?: string
    type: string
    keywords?: ServiceCreatekeywordsInput | string[]
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumbers?: ContactCreateNestedManyWithoutServiceInput
    facility: FacilityCreateNestedOneWithoutServicesInput
    division?: DivisionCreateNestedOneWithoutServicesInput
    ambulanceService?: AmbulanceServiceCreateNestedOneWithoutServiceInput
    bloodBankService?: BloodBankServiceCreateNestedOneWithoutServiceInput
    icuService?: ICUServiceCreateNestedOneWithoutServiceInput
    outpatientService?: OutpatientServiceCreateNestedOneWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutErServiceInput = {
    serviceID?: string
    type: string
    keywords?: ServiceCreatekeywordsInput | string[]
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilityID: string
    divisionID?: string | null
    phoneNumbers?: ContactUncheckedCreateNestedManyWithoutServiceInput
    ambulanceService?: AmbulanceServiceUncheckedCreateNestedOneWithoutServiceInput
    bloodBankService?: BloodBankServiceUncheckedCreateNestedOneWithoutServiceInput
    icuService?: ICUServiceUncheckedCreateNestedOneWithoutServiceInput
    outpatientService?: OutpatientServiceUncheckedCreateNestedOneWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutErServiceInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutErServiceInput, ServiceUncheckedCreateWithoutErServiceInput>
  }

  export type ServiceUpsertWithoutErServiceInput = {
    update: XOR<ServiceUpdateWithoutErServiceInput, ServiceUncheckedUpdateWithoutErServiceInput>
    create: XOR<ServiceCreateWithoutErServiceInput, ServiceUncheckedCreateWithoutErServiceInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutErServiceInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutErServiceInput, ServiceUncheckedUpdateWithoutErServiceInput>
  }

  export type ServiceUpdateWithoutErServiceInput = {
    serviceID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ServiceUpdatekeywordsInput | string[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumbers?: ContactUpdateManyWithoutServiceNestedInput
    facility?: FacilityUpdateOneRequiredWithoutServicesNestedInput
    division?: DivisionUpdateOneWithoutServicesNestedInput
    ambulanceService?: AmbulanceServiceUpdateOneWithoutServiceNestedInput
    bloodBankService?: BloodBankServiceUpdateOneWithoutServiceNestedInput
    icuService?: ICUServiceUpdateOneWithoutServiceNestedInput
    outpatientService?: OutpatientServiceUpdateOneWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutErServiceInput = {
    serviceID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ServiceUpdatekeywordsInput | string[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
    divisionID?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumbers?: ContactUncheckedUpdateManyWithoutServiceNestedInput
    ambulanceService?: AmbulanceServiceUncheckedUpdateOneWithoutServiceNestedInput
    bloodBankService?: BloodBankServiceUncheckedUpdateOneWithoutServiceNestedInput
    icuService?: ICUServiceUncheckedUpdateOneWithoutServiceNestedInput
    outpatientService?: OutpatientServiceUncheckedUpdateOneWithoutServiceNestedInput
  }

  export type ServiceCreateWithoutIcuServiceInput = {
    serviceID?: string
    type: string
    keywords?: ServiceCreatekeywordsInput | string[]
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumbers?: ContactCreateNestedManyWithoutServiceInput
    facility: FacilityCreateNestedOneWithoutServicesInput
    division?: DivisionCreateNestedOneWithoutServicesInput
    ambulanceService?: AmbulanceServiceCreateNestedOneWithoutServiceInput
    bloodBankService?: BloodBankServiceCreateNestedOneWithoutServiceInput
    erService?: ERServiceCreateNestedOneWithoutServiceInput
    outpatientService?: OutpatientServiceCreateNestedOneWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutIcuServiceInput = {
    serviceID?: string
    type: string
    keywords?: ServiceCreatekeywordsInput | string[]
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilityID: string
    divisionID?: string | null
    phoneNumbers?: ContactUncheckedCreateNestedManyWithoutServiceInput
    ambulanceService?: AmbulanceServiceUncheckedCreateNestedOneWithoutServiceInput
    bloodBankService?: BloodBankServiceUncheckedCreateNestedOneWithoutServiceInput
    erService?: ERServiceUncheckedCreateNestedOneWithoutServiceInput
    outpatientService?: OutpatientServiceUncheckedCreateNestedOneWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutIcuServiceInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutIcuServiceInput, ServiceUncheckedCreateWithoutIcuServiceInput>
  }

  export type ServiceUpsertWithoutIcuServiceInput = {
    update: XOR<ServiceUpdateWithoutIcuServiceInput, ServiceUncheckedUpdateWithoutIcuServiceInput>
    create: XOR<ServiceCreateWithoutIcuServiceInput, ServiceUncheckedCreateWithoutIcuServiceInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutIcuServiceInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutIcuServiceInput, ServiceUncheckedUpdateWithoutIcuServiceInput>
  }

  export type ServiceUpdateWithoutIcuServiceInput = {
    serviceID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ServiceUpdatekeywordsInput | string[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumbers?: ContactUpdateManyWithoutServiceNestedInput
    facility?: FacilityUpdateOneRequiredWithoutServicesNestedInput
    division?: DivisionUpdateOneWithoutServicesNestedInput
    ambulanceService?: AmbulanceServiceUpdateOneWithoutServiceNestedInput
    bloodBankService?: BloodBankServiceUpdateOneWithoutServiceNestedInput
    erService?: ERServiceUpdateOneWithoutServiceNestedInput
    outpatientService?: OutpatientServiceUpdateOneWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutIcuServiceInput = {
    serviceID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ServiceUpdatekeywordsInput | string[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
    divisionID?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumbers?: ContactUncheckedUpdateManyWithoutServiceNestedInput
    ambulanceService?: AmbulanceServiceUncheckedUpdateOneWithoutServiceNestedInput
    bloodBankService?: BloodBankServiceUncheckedUpdateOneWithoutServiceNestedInput
    erService?: ERServiceUncheckedUpdateOneWithoutServiceNestedInput
    outpatientService?: OutpatientServiceUncheckedUpdateOneWithoutServiceNestedInput
  }

  export type ServiceCreateWithoutOutpatientServiceInput = {
    serviceID?: string
    type: string
    keywords?: ServiceCreatekeywordsInput | string[]
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumbers?: ContactCreateNestedManyWithoutServiceInput
    facility: FacilityCreateNestedOneWithoutServicesInput
    division?: DivisionCreateNestedOneWithoutServicesInput
    ambulanceService?: AmbulanceServiceCreateNestedOneWithoutServiceInput
    bloodBankService?: BloodBankServiceCreateNestedOneWithoutServiceInput
    erService?: ERServiceCreateNestedOneWithoutServiceInput
    icuService?: ICUServiceCreateNestedOneWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutOutpatientServiceInput = {
    serviceID?: string
    type: string
    keywords?: ServiceCreatekeywordsInput | string[]
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilityID: string
    divisionID?: string | null
    phoneNumbers?: ContactUncheckedCreateNestedManyWithoutServiceInput
    ambulanceService?: AmbulanceServiceUncheckedCreateNestedOneWithoutServiceInput
    bloodBankService?: BloodBankServiceUncheckedCreateNestedOneWithoutServiceInput
    erService?: ERServiceUncheckedCreateNestedOneWithoutServiceInput
    icuService?: ICUServiceUncheckedCreateNestedOneWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutOutpatientServiceInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutOutpatientServiceInput, ServiceUncheckedCreateWithoutOutpatientServiceInput>
  }

  export type ServiceUpsertWithoutOutpatientServiceInput = {
    update: XOR<ServiceUpdateWithoutOutpatientServiceInput, ServiceUncheckedUpdateWithoutOutpatientServiceInput>
    create: XOR<ServiceCreateWithoutOutpatientServiceInput, ServiceUncheckedCreateWithoutOutpatientServiceInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutOutpatientServiceInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutOutpatientServiceInput, ServiceUncheckedUpdateWithoutOutpatientServiceInput>
  }

  export type ServiceUpdateWithoutOutpatientServiceInput = {
    serviceID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ServiceUpdatekeywordsInput | string[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumbers?: ContactUpdateManyWithoutServiceNestedInput
    facility?: FacilityUpdateOneRequiredWithoutServicesNestedInput
    division?: DivisionUpdateOneWithoutServicesNestedInput
    ambulanceService?: AmbulanceServiceUpdateOneWithoutServiceNestedInput
    bloodBankService?: BloodBankServiceUpdateOneWithoutServiceNestedInput
    erService?: ERServiceUpdateOneWithoutServiceNestedInput
    icuService?: ICUServiceUpdateOneWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutOutpatientServiceInput = {
    serviceID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ServiceUpdatekeywordsInput | string[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
    divisionID?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumbers?: ContactUncheckedUpdateManyWithoutServiceNestedInput
    ambulanceService?: AmbulanceServiceUncheckedUpdateOneWithoutServiceNestedInput
    bloodBankService?: BloodBankServiceUncheckedUpdateOneWithoutServiceNestedInput
    erService?: ERServiceUncheckedUpdateOneWithoutServiceNestedInput
    icuService?: ICUServiceUncheckedUpdateOneWithoutServiceNestedInput
  }

  export type FacilityCreateWithoutContactsInput = {
    facilityID?: string
    name: string
    photo: string
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    facilityType: $Enums.FacilityType
    ownership: $Enums.Ownership
    bookingSystem?: string | null
    acceptedProviders?: FacilityCreateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: Date | string
    address?: AddressCreateNestedOneWithoutFacilityInput
    services?: ServiceCreateNestedManyWithoutFacilityInput
    employees?: EmployeeCreateNestedManyWithoutFacilityInput
    divisions?: DivisionCreateNestedManyWithoutFacilityInput
    logs?: UpdateLogCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutContactsInput = {
    facilityID?: string
    name: string
    photo: string
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    facilityType: $Enums.FacilityType
    ownership: $Enums.Ownership
    bookingSystem?: string | null
    acceptedProviders?: FacilityCreateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: Date | string
    address?: AddressUncheckedCreateNestedOneWithoutFacilityInput
    services?: ServiceUncheckedCreateNestedManyWithoutFacilityInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutFacilityInput
    divisions?: DivisionUncheckedCreateNestedManyWithoutFacilityInput
    logs?: UpdateLogUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutContactsInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutContactsInput, FacilityUncheckedCreateWithoutContactsInput>
  }

  export type DivisionCreateWithoutContactsInput = {
    divisionID?: string
    name: string
    openingTime: Date | string
    closingTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    facility: FacilityCreateNestedOneWithoutDivisionsInput
    services?: ServiceCreateNestedManyWithoutDivisionInput
    admins?: EmployeeCreateNestedManyWithoutDivisionsInput
    logs?: UpdateLogCreateNestedManyWithoutDivisionInput
  }

  export type DivisionUncheckedCreateWithoutContactsInput = {
    divisionID?: string
    name: string
    openingTime: Date | string
    closingTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    facilityID: string
    services?: ServiceUncheckedCreateNestedManyWithoutDivisionInput
    admins?: EmployeeUncheckedCreateNestedManyWithoutDivisionsInput
    logs?: UpdateLogUncheckedCreateNestedManyWithoutDivisionInput
  }

  export type DivisionCreateOrConnectWithoutContactsInput = {
    where: DivisionWhereUniqueInput
    create: XOR<DivisionCreateWithoutContactsInput, DivisionUncheckedCreateWithoutContactsInput>
  }

  export type ServiceCreateWithoutPhoneNumbersInput = {
    serviceID?: string
    type: string
    keywords?: ServiceCreatekeywordsInput | string[]
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facility: FacilityCreateNestedOneWithoutServicesInput
    division?: DivisionCreateNestedOneWithoutServicesInput
    ambulanceService?: AmbulanceServiceCreateNestedOneWithoutServiceInput
    bloodBankService?: BloodBankServiceCreateNestedOneWithoutServiceInput
    erService?: ERServiceCreateNestedOneWithoutServiceInput
    icuService?: ICUServiceCreateNestedOneWithoutServiceInput
    outpatientService?: OutpatientServiceCreateNestedOneWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutPhoneNumbersInput = {
    serviceID?: string
    type: string
    keywords?: ServiceCreatekeywordsInput | string[]
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilityID: string
    divisionID?: string | null
    ambulanceService?: AmbulanceServiceUncheckedCreateNestedOneWithoutServiceInput
    bloodBankService?: BloodBankServiceUncheckedCreateNestedOneWithoutServiceInput
    erService?: ERServiceUncheckedCreateNestedOneWithoutServiceInput
    icuService?: ICUServiceUncheckedCreateNestedOneWithoutServiceInput
    outpatientService?: OutpatientServiceUncheckedCreateNestedOneWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutPhoneNumbersInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutPhoneNumbersInput, ServiceUncheckedCreateWithoutPhoneNumbersInput>
  }

  export type FacilityUpsertWithoutContactsInput = {
    update: XOR<FacilityUpdateWithoutContactsInput, FacilityUncheckedUpdateWithoutContactsInput>
    create: XOR<FacilityCreateWithoutContactsInput, FacilityUncheckedCreateWithoutContactsInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutContactsInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutContactsInput, FacilityUncheckedUpdateWithoutContactsInput>
  }

  export type FacilityUpdateWithoutContactsInput = {
    facilityID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityType?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    ownership?: EnumOwnershipFieldUpdateOperationsInput | $Enums.Ownership
    bookingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedProviders?: FacilityUpdateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateOneWithoutFacilityNestedInput
    services?: ServiceUpdateManyWithoutFacilityNestedInput
    employees?: EmployeeUpdateManyWithoutFacilityNestedInput
    divisions?: DivisionUpdateManyWithoutFacilityNestedInput
    logs?: UpdateLogUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutContactsInput = {
    facilityID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityType?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    ownership?: EnumOwnershipFieldUpdateOperationsInput | $Enums.Ownership
    bookingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedProviders?: FacilityUpdateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUncheckedUpdateOneWithoutFacilityNestedInput
    services?: ServiceUncheckedUpdateManyWithoutFacilityNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutFacilityNestedInput
    divisions?: DivisionUncheckedUpdateManyWithoutFacilityNestedInput
    logs?: UpdateLogUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type DivisionUpsertWithoutContactsInput = {
    update: XOR<DivisionUpdateWithoutContactsInput, DivisionUncheckedUpdateWithoutContactsInput>
    create: XOR<DivisionCreateWithoutContactsInput, DivisionUncheckedCreateWithoutContactsInput>
    where?: DivisionWhereInput
  }

  export type DivisionUpdateToOneWithWhereWithoutContactsInput = {
    where?: DivisionWhereInput
    data: XOR<DivisionUpdateWithoutContactsInput, DivisionUncheckedUpdateWithoutContactsInput>
  }

  export type DivisionUpdateWithoutContactsInput = {
    divisionID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    openingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneRequiredWithoutDivisionsNestedInput
    services?: ServiceUpdateManyWithoutDivisionNestedInput
    admins?: EmployeeUpdateManyWithoutDivisionsNestedInput
    logs?: UpdateLogUpdateManyWithoutDivisionNestedInput
  }

  export type DivisionUncheckedUpdateWithoutContactsInput = {
    divisionID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    openingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
    services?: ServiceUncheckedUpdateManyWithoutDivisionNestedInput
    admins?: EmployeeUncheckedUpdateManyWithoutDivisionsNestedInput
    logs?: UpdateLogUncheckedUpdateManyWithoutDivisionNestedInput
  }

  export type ServiceUpsertWithoutPhoneNumbersInput = {
    update: XOR<ServiceUpdateWithoutPhoneNumbersInput, ServiceUncheckedUpdateWithoutPhoneNumbersInput>
    create: XOR<ServiceCreateWithoutPhoneNumbersInput, ServiceUncheckedCreateWithoutPhoneNumbersInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutPhoneNumbersInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutPhoneNumbersInput, ServiceUncheckedUpdateWithoutPhoneNumbersInput>
  }

  export type ServiceUpdateWithoutPhoneNumbersInput = {
    serviceID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ServiceUpdatekeywordsInput | string[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneRequiredWithoutServicesNestedInput
    division?: DivisionUpdateOneWithoutServicesNestedInput
    ambulanceService?: AmbulanceServiceUpdateOneWithoutServiceNestedInput
    bloodBankService?: BloodBankServiceUpdateOneWithoutServiceNestedInput
    erService?: ERServiceUpdateOneWithoutServiceNestedInput
    icuService?: ICUServiceUpdateOneWithoutServiceNestedInput
    outpatientService?: OutpatientServiceUpdateOneWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutPhoneNumbersInput = {
    serviceID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ServiceUpdatekeywordsInput | string[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
    divisionID?: NullableStringFieldUpdateOperationsInput | string | null
    ambulanceService?: AmbulanceServiceUncheckedUpdateOneWithoutServiceNestedInput
    bloodBankService?: BloodBankServiceUncheckedUpdateOneWithoutServiceNestedInput
    erService?: ERServiceUncheckedUpdateOneWithoutServiceNestedInput
    icuService?: ICUServiceUncheckedUpdateOneWithoutServiceNestedInput
    outpatientService?: OutpatientServiceUncheckedUpdateOneWithoutServiceNestedInput
  }

  export type FacilityCreateWithoutLogsInput = {
    facilityID?: string
    name: string
    photo: string
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    facilityType: $Enums.FacilityType
    ownership: $Enums.Ownership
    bookingSystem?: string | null
    acceptedProviders?: FacilityCreateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: Date | string
    address?: AddressCreateNestedOneWithoutFacilityInput
    contacts?: ContactCreateNestedManyWithoutFacilityInput
    services?: ServiceCreateNestedManyWithoutFacilityInput
    employees?: EmployeeCreateNestedManyWithoutFacilityInput
    divisions?: DivisionCreateNestedManyWithoutFacilityInput
  }

  export type FacilityUncheckedCreateWithoutLogsInput = {
    facilityID?: string
    name: string
    photo: string
    openingTime?: Date | string | null
    closingTime?: Date | string | null
    facilityType: $Enums.FacilityType
    ownership: $Enums.Ownership
    bookingSystem?: string | null
    acceptedProviders?: FacilityCreateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: Date | string
    address?: AddressUncheckedCreateNestedOneWithoutFacilityInput
    contacts?: ContactUncheckedCreateNestedManyWithoutFacilityInput
    services?: ServiceUncheckedCreateNestedManyWithoutFacilityInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutFacilityInput
    divisions?: DivisionUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCreateOrConnectWithoutLogsInput = {
    where: FacilityWhereUniqueInput
    create: XOR<FacilityCreateWithoutLogsInput, FacilityUncheckedCreateWithoutLogsInput>
  }

  export type DivisionCreateWithoutLogsInput = {
    divisionID?: string
    name: string
    openingTime: Date | string
    closingTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutDivisionInput
    facility: FacilityCreateNestedOneWithoutDivisionsInput
    services?: ServiceCreateNestedManyWithoutDivisionInput
    admins?: EmployeeCreateNestedManyWithoutDivisionsInput
  }

  export type DivisionUncheckedCreateWithoutLogsInput = {
    divisionID?: string
    name: string
    openingTime: Date | string
    closingTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    facilityID: string
    contacts?: ContactUncheckedCreateNestedManyWithoutDivisionInput
    services?: ServiceUncheckedCreateNestedManyWithoutDivisionInput
    admins?: EmployeeUncheckedCreateNestedManyWithoutDivisionsInput
  }

  export type DivisionCreateOrConnectWithoutLogsInput = {
    where: DivisionWhereUniqueInput
    create: XOR<DivisionCreateWithoutLogsInput, DivisionUncheckedCreateWithoutLogsInput>
  }

  export type EmployeeCreateWithoutUpdateLogInput = {
    employeeID?: string
    password: string
    role: $Enums.Role
    fname: string
    mname?: string | null
    lname: string
    photo?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutEmployeeInput
    facility: FacilityCreateNestedOneWithoutEmployeesInput
    divisions?: DivisionCreateNestedManyWithoutAdminsInput
  }

  export type EmployeeUncheckedCreateWithoutUpdateLogInput = {
    employeeID?: string
    password: string
    role: $Enums.Role
    fname: string
    mname?: string | null
    lname: string
    photo?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    facilityID: string
    sessions?: SessionUncheckedCreateNestedManyWithoutEmployeeInput
    divisions?: DivisionUncheckedCreateNestedManyWithoutAdminsInput
  }

  export type EmployeeCreateOrConnectWithoutUpdateLogInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutUpdateLogInput, EmployeeUncheckedCreateWithoutUpdateLogInput>
  }

  export type FacilityUpsertWithoutLogsInput = {
    update: XOR<FacilityUpdateWithoutLogsInput, FacilityUncheckedUpdateWithoutLogsInput>
    create: XOR<FacilityCreateWithoutLogsInput, FacilityUncheckedCreateWithoutLogsInput>
    where?: FacilityWhereInput
  }

  export type FacilityUpdateToOneWithWhereWithoutLogsInput = {
    where?: FacilityWhereInput
    data: XOR<FacilityUpdateWithoutLogsInput, FacilityUncheckedUpdateWithoutLogsInput>
  }

  export type FacilityUpdateWithoutLogsInput = {
    facilityID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityType?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    ownership?: EnumOwnershipFieldUpdateOperationsInput | $Enums.Ownership
    bookingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedProviders?: FacilityUpdateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateOneWithoutFacilityNestedInput
    contacts?: ContactUpdateManyWithoutFacilityNestedInput
    services?: ServiceUpdateManyWithoutFacilityNestedInput
    employees?: EmployeeUpdateManyWithoutFacilityNestedInput
    divisions?: DivisionUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityUncheckedUpdateWithoutLogsInput = {
    facilityID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    openingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closingTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    facilityType?: EnumFacilityTypeFieldUpdateOperationsInput | $Enums.FacilityType
    ownership?: EnumOwnershipFieldUpdateOperationsInput | $Enums.Ownership
    bookingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedProviders?: FacilityUpdateacceptedProvidersInput | $Enums.Provider[]
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUncheckedUpdateOneWithoutFacilityNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutFacilityNestedInput
    services?: ServiceUncheckedUpdateManyWithoutFacilityNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutFacilityNestedInput
    divisions?: DivisionUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type DivisionUpsertWithoutLogsInput = {
    update: XOR<DivisionUpdateWithoutLogsInput, DivisionUncheckedUpdateWithoutLogsInput>
    create: XOR<DivisionCreateWithoutLogsInput, DivisionUncheckedCreateWithoutLogsInput>
    where?: DivisionWhereInput
  }

  export type DivisionUpdateToOneWithWhereWithoutLogsInput = {
    where?: DivisionWhereInput
    data: XOR<DivisionUpdateWithoutLogsInput, DivisionUncheckedUpdateWithoutLogsInput>
  }

  export type DivisionUpdateWithoutLogsInput = {
    divisionID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    openingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutDivisionNestedInput
    facility?: FacilityUpdateOneRequiredWithoutDivisionsNestedInput
    services?: ServiceUpdateManyWithoutDivisionNestedInput
    admins?: EmployeeUpdateManyWithoutDivisionsNestedInput
  }

  export type DivisionUncheckedUpdateWithoutLogsInput = {
    divisionID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    openingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
    contacts?: ContactUncheckedUpdateManyWithoutDivisionNestedInput
    services?: ServiceUncheckedUpdateManyWithoutDivisionNestedInput
    admins?: EmployeeUncheckedUpdateManyWithoutDivisionsNestedInput
  }

  export type EmployeeUpsertWithoutUpdateLogInput = {
    update: XOR<EmployeeUpdateWithoutUpdateLogInput, EmployeeUncheckedUpdateWithoutUpdateLogInput>
    create: XOR<EmployeeCreateWithoutUpdateLogInput, EmployeeUncheckedCreateWithoutUpdateLogInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutUpdateLogInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutUpdateLogInput, EmployeeUncheckedUpdateWithoutUpdateLogInput>
  }

  export type EmployeeUpdateWithoutUpdateLogInput = {
    employeeID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    fname?: StringFieldUpdateOperationsInput | string
    mname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutEmployeeNestedInput
    facility?: FacilityUpdateOneRequiredWithoutEmployeesNestedInput
    divisions?: DivisionUpdateManyWithoutAdminsNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutUpdateLogInput = {
    employeeID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    fname?: StringFieldUpdateOperationsInput | string
    mname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
    sessions?: SessionUncheckedUpdateManyWithoutEmployeeNestedInput
    divisions?: DivisionUncheckedUpdateManyWithoutAdminsNestedInput
  }

  export type POrCCreateManyRegionInput = {
    pOrCID: number
    name: string
    id?: number
  }

  export type AddressCreateManyRegionInput = {
    pOrCID: number
    cOrMID: number
    brgyID: number
    street: string
    facilityID: string
  }

  export type POrCUpdateWithoutRegionInput = {
    pOrCID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    cOrMs?: COrMUpdateManyWithoutPOrCNestedInput
    addresses?: AddressUpdateManyWithoutPOrCNestedInput
  }

  export type POrCUncheckedUpdateWithoutRegionInput = {
    pOrCID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    cOrMs?: COrMUncheckedUpdateManyWithoutPOrCNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutPOrCNestedInput
  }

  export type POrCUncheckedUpdateManyWithoutRegionInput = {
    pOrCID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
  }

  export type AddressUpdateWithoutRegionInput = {
    street?: StringFieldUpdateOperationsInput | string
    pOrC?: POrCUpdateOneRequiredWithoutAddressesNestedInput
    cOrM?: COrMUpdateOneRequiredWithoutAddressesNestedInput
    brgy?: BrgyUpdateOneRequiredWithoutAddressesNestedInput
    facility?: FacilityUpdateOneRequiredWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutRegionInput = {
    pOrCID?: IntFieldUpdateOperationsInput | number
    cOrMID?: IntFieldUpdateOperationsInput | number
    brgyID?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    facilityID?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateManyWithoutRegionInput = {
    pOrCID?: IntFieldUpdateOperationsInput | number
    cOrMID?: IntFieldUpdateOperationsInput | number
    brgyID?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    facilityID?: StringFieldUpdateOperationsInput | string
  }

  export type COrMCreateManyPOrCInput = {
    cOrMID: number
    name: string
    id?: number
  }

  export type AddressCreateManyPOrCInput = {
    regionID: number
    cOrMID: number
    brgyID: number
    street: string
    facilityID: string
  }

  export type COrMUpdateWithoutPOrCInput = {
    cOrMID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    brgys?: BrgyUpdateManyWithoutCOrMNestedInput
    addresses?: AddressUpdateManyWithoutCOrMNestedInput
  }

  export type COrMUncheckedUpdateWithoutPOrCInput = {
    cOrMID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    brgys?: BrgyUncheckedUpdateManyWithoutCOrMNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutCOrMNestedInput
  }

  export type COrMUncheckedUpdateManyWithoutPOrCInput = {
    cOrMID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
  }

  export type AddressUpdateWithoutPOrCInput = {
    street?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutAddressesNestedInput
    cOrM?: COrMUpdateOneRequiredWithoutAddressesNestedInput
    brgy?: BrgyUpdateOneRequiredWithoutAddressesNestedInput
    facility?: FacilityUpdateOneRequiredWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutPOrCInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    cOrMID?: IntFieldUpdateOperationsInput | number
    brgyID?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    facilityID?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateManyWithoutPOrCInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    cOrMID?: IntFieldUpdateOperationsInput | number
    brgyID?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    facilityID?: StringFieldUpdateOperationsInput | string
  }

  export type BrgyCreateManyCOrMInput = {
    brgyID: number
    name: string
    id?: number
  }

  export type AddressCreateManyCOrMInput = {
    regionID: number
    pOrCID: number
    brgyID: number
    street: string
    facilityID: string
  }

  export type BrgyUpdateWithoutCOrMInput = {
    brgyID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    addresses?: AddressUpdateManyWithoutBrgyNestedInput
  }

  export type BrgyUncheckedUpdateWithoutCOrMInput = {
    brgyID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    addresses?: AddressUncheckedUpdateManyWithoutBrgyNestedInput
  }

  export type BrgyUncheckedUpdateManyWithoutCOrMInput = {
    brgyID?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
  }

  export type AddressUpdateWithoutCOrMInput = {
    street?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutAddressesNestedInput
    pOrC?: POrCUpdateOneRequiredWithoutAddressesNestedInput
    brgy?: BrgyUpdateOneRequiredWithoutAddressesNestedInput
    facility?: FacilityUpdateOneRequiredWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutCOrMInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    pOrCID?: IntFieldUpdateOperationsInput | number
    brgyID?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    facilityID?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateManyWithoutCOrMInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    pOrCID?: IntFieldUpdateOperationsInput | number
    brgyID?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    facilityID?: StringFieldUpdateOperationsInput | string
  }

  export type AddressCreateManyBrgyInput = {
    regionID: number
    pOrCID: number
    cOrMID: number
    street: string
    facilityID: string
  }

  export type AddressUpdateWithoutBrgyInput = {
    street?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutAddressesNestedInput
    pOrC?: POrCUpdateOneRequiredWithoutAddressesNestedInput
    cOrM?: COrMUpdateOneRequiredWithoutAddressesNestedInput
    facility?: FacilityUpdateOneRequiredWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutBrgyInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    pOrCID?: IntFieldUpdateOperationsInput | number
    cOrMID?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    facilityID?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateManyWithoutBrgyInput = {
    regionID?: IntFieldUpdateOperationsInput | number
    pOrCID?: IntFieldUpdateOperationsInput | number
    cOrMID?: IntFieldUpdateOperationsInput | number
    street?: StringFieldUpdateOperationsInput | string
    facilityID?: StringFieldUpdateOperationsInput | string
  }

  export type ContactCreateManyFacilityInput = {
    contactID?: string
    info: string
    type: $Enums.ContactType
    divisionID?: string | null
    serviceID?: string | null
  }

  export type ServiceCreateManyFacilityInput = {
    serviceID?: string
    type: string
    keywords?: ServiceCreatekeywordsInput | string[]
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    divisionID?: string | null
  }

  export type EmployeeCreateManyFacilityInput = {
    employeeID?: string
    password: string
    role: $Enums.Role
    fname: string
    mname?: string | null
    lname: string
    photo?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DivisionCreateManyFacilityInput = {
    divisionID?: string
    name: string
    openingTime: Date | string
    closingTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UpdateLogCreateManyFacilityInput = {
    updateLogID?: string
    entity: string
    action: $Enums.Action
    createdAt?: Date | string
    divisionID?: string | null
    employeeID: string
  }

  export type ContactUpdateWithoutFacilityInput = {
    contactID?: StringFieldUpdateOperationsInput | string
    info?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    division?: DivisionUpdateOneWithoutContactsNestedInput
    service?: ServiceUpdateOneWithoutPhoneNumbersNestedInput
  }

  export type ContactUncheckedUpdateWithoutFacilityInput = {
    contactID?: StringFieldUpdateOperationsInput | string
    info?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    divisionID?: NullableStringFieldUpdateOperationsInput | string | null
    serviceID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactUncheckedUpdateManyWithoutFacilityInput = {
    contactID?: StringFieldUpdateOperationsInput | string
    info?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    divisionID?: NullableStringFieldUpdateOperationsInput | string | null
    serviceID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceUpdateWithoutFacilityInput = {
    serviceID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ServiceUpdatekeywordsInput | string[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumbers?: ContactUpdateManyWithoutServiceNestedInput
    division?: DivisionUpdateOneWithoutServicesNestedInput
    ambulanceService?: AmbulanceServiceUpdateOneWithoutServiceNestedInput
    bloodBankService?: BloodBankServiceUpdateOneWithoutServiceNestedInput
    erService?: ERServiceUpdateOneWithoutServiceNestedInput
    icuService?: ICUServiceUpdateOneWithoutServiceNestedInput
    outpatientService?: OutpatientServiceUpdateOneWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutFacilityInput = {
    serviceID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ServiceUpdatekeywordsInput | string[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    divisionID?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumbers?: ContactUncheckedUpdateManyWithoutServiceNestedInput
    ambulanceService?: AmbulanceServiceUncheckedUpdateOneWithoutServiceNestedInput
    bloodBankService?: BloodBankServiceUncheckedUpdateOneWithoutServiceNestedInput
    erService?: ERServiceUncheckedUpdateOneWithoutServiceNestedInput
    icuService?: ICUServiceUncheckedUpdateOneWithoutServiceNestedInput
    outpatientService?: OutpatientServiceUncheckedUpdateOneWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutFacilityInput = {
    serviceID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ServiceUpdatekeywordsInput | string[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    divisionID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeUpdateWithoutFacilityInput = {
    employeeID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    fname?: StringFieldUpdateOperationsInput | string
    mname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutEmployeeNestedInput
    divisions?: DivisionUpdateManyWithoutAdminsNestedInput
    updateLog?: UpdateLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutFacilityInput = {
    employeeID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    fname?: StringFieldUpdateOperationsInput | string
    mname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutEmployeeNestedInput
    divisions?: DivisionUncheckedUpdateManyWithoutAdminsNestedInput
    updateLog?: UpdateLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutFacilityInput = {
    employeeID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    fname?: StringFieldUpdateOperationsInput | string
    mname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DivisionUpdateWithoutFacilityInput = {
    divisionID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    openingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutDivisionNestedInput
    services?: ServiceUpdateManyWithoutDivisionNestedInput
    admins?: EmployeeUpdateManyWithoutDivisionsNestedInput
    logs?: UpdateLogUpdateManyWithoutDivisionNestedInput
  }

  export type DivisionUncheckedUpdateWithoutFacilityInput = {
    divisionID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    openingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutDivisionNestedInput
    services?: ServiceUncheckedUpdateManyWithoutDivisionNestedInput
    admins?: EmployeeUncheckedUpdateManyWithoutDivisionsNestedInput
    logs?: UpdateLogUncheckedUpdateManyWithoutDivisionNestedInput
  }

  export type DivisionUncheckedUpdateManyWithoutFacilityInput = {
    divisionID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    openingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UpdateLogUpdateWithoutFacilityInput = {
    updateLogID?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    action?: EnumActionFieldUpdateOperationsInput | $Enums.Action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    division?: DivisionUpdateOneWithoutLogsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutUpdateLogNestedInput
  }

  export type UpdateLogUncheckedUpdateWithoutFacilityInput = {
    updateLogID?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    action?: EnumActionFieldUpdateOperationsInput | $Enums.Action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    divisionID?: NullableStringFieldUpdateOperationsInput | string | null
    employeeID?: StringFieldUpdateOperationsInput | string
  }

  export type UpdateLogUncheckedUpdateManyWithoutFacilityInput = {
    updateLogID?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    action?: EnumActionFieldUpdateOperationsInput | $Enums.Action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    divisionID?: NullableStringFieldUpdateOperationsInput | string | null
    employeeID?: StringFieldUpdateOperationsInput | string
  }

  export type ContactCreateManyDivisionInput = {
    contactID?: string
    info: string
    type: $Enums.ContactType
    facilityID?: string | null
    serviceID?: string | null
  }

  export type ServiceCreateManyDivisionInput = {
    serviceID?: string
    type: string
    keywords?: ServiceCreatekeywordsInput | string[]
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    facilityID: string
  }

  export type UpdateLogCreateManyDivisionInput = {
    updateLogID?: string
    entity: string
    action: $Enums.Action
    createdAt?: Date | string
    facilityID: string
    employeeID: string
  }

  export type ContactUpdateWithoutDivisionInput = {
    contactID?: StringFieldUpdateOperationsInput | string
    info?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    facility?: FacilityUpdateOneWithoutContactsNestedInput
    service?: ServiceUpdateOneWithoutPhoneNumbersNestedInput
  }

  export type ContactUncheckedUpdateWithoutDivisionInput = {
    contactID?: StringFieldUpdateOperationsInput | string
    info?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    facilityID?: NullableStringFieldUpdateOperationsInput | string | null
    serviceID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactUncheckedUpdateManyWithoutDivisionInput = {
    contactID?: StringFieldUpdateOperationsInput | string
    info?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    facilityID?: NullableStringFieldUpdateOperationsInput | string | null
    serviceID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceUpdateWithoutDivisionInput = {
    serviceID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ServiceUpdatekeywordsInput | string[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumbers?: ContactUpdateManyWithoutServiceNestedInput
    facility?: FacilityUpdateOneRequiredWithoutServicesNestedInput
    ambulanceService?: AmbulanceServiceUpdateOneWithoutServiceNestedInput
    bloodBankService?: BloodBankServiceUpdateOneWithoutServiceNestedInput
    erService?: ERServiceUpdateOneWithoutServiceNestedInput
    icuService?: ICUServiceUpdateOneWithoutServiceNestedInput
    outpatientService?: OutpatientServiceUpdateOneWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutDivisionInput = {
    serviceID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ServiceUpdatekeywordsInput | string[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
    phoneNumbers?: ContactUncheckedUpdateManyWithoutServiceNestedInput
    ambulanceService?: AmbulanceServiceUncheckedUpdateOneWithoutServiceNestedInput
    bloodBankService?: BloodBankServiceUncheckedUpdateOneWithoutServiceNestedInput
    erService?: ERServiceUncheckedUpdateOneWithoutServiceNestedInput
    icuService?: ICUServiceUncheckedUpdateOneWithoutServiceNestedInput
    outpatientService?: OutpatientServiceUncheckedUpdateOneWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutDivisionInput = {
    serviceID?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    keywords?: ServiceUpdatekeywordsInput | string[]
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeUpdateWithoutDivisionsInput = {
    employeeID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    fname?: StringFieldUpdateOperationsInput | string
    mname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutEmployeeNestedInput
    facility?: FacilityUpdateOneRequiredWithoutEmployeesNestedInput
    updateLog?: UpdateLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutDivisionsInput = {
    employeeID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    fname?: StringFieldUpdateOperationsInput | string
    mname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
    sessions?: SessionUncheckedUpdateManyWithoutEmployeeNestedInput
    updateLog?: UpdateLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutDivisionsInput = {
    employeeID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    fname?: StringFieldUpdateOperationsInput | string
    mname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
  }

  export type UpdateLogUpdateWithoutDivisionInput = {
    updateLogID?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    action?: EnumActionFieldUpdateOperationsInput | $Enums.Action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneRequiredWithoutLogsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutUpdateLogNestedInput
  }

  export type UpdateLogUncheckedUpdateWithoutDivisionInput = {
    updateLogID?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    action?: EnumActionFieldUpdateOperationsInput | $Enums.Action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
    employeeID?: StringFieldUpdateOperationsInput | string
  }

  export type UpdateLogUncheckedUpdateManyWithoutDivisionInput = {
    updateLogID?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    action?: EnumActionFieldUpdateOperationsInput | $Enums.Action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
    employeeID?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateManyEmployeeInput = {
    sessionID: string
    expiresAt: Date | string
  }

  export type UpdateLogCreateManyEmployeeInput = {
    updateLogID?: string
    entity: string
    action: $Enums.Action
    createdAt?: Date | string
    facilityID: string
    divisionID?: string | null
  }

  export type SessionUpdateWithoutEmployeeInput = {
    sessionID?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutEmployeeInput = {
    sessionID?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutEmployeeInput = {
    sessionID?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DivisionUpdateWithoutAdminsInput = {
    divisionID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    openingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutDivisionNestedInput
    facility?: FacilityUpdateOneRequiredWithoutDivisionsNestedInput
    services?: ServiceUpdateManyWithoutDivisionNestedInput
    logs?: UpdateLogUpdateManyWithoutDivisionNestedInput
  }

  export type DivisionUncheckedUpdateWithoutAdminsInput = {
    divisionID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    openingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
    contacts?: ContactUncheckedUpdateManyWithoutDivisionNestedInput
    services?: ServiceUncheckedUpdateManyWithoutDivisionNestedInput
    logs?: UpdateLogUncheckedUpdateManyWithoutDivisionNestedInput
  }

  export type DivisionUncheckedUpdateManyWithoutAdminsInput = {
    divisionID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    openingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    closingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
  }

  export type UpdateLogUpdateWithoutEmployeeInput = {
    updateLogID?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    action?: EnumActionFieldUpdateOperationsInput | $Enums.Action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityUpdateOneRequiredWithoutLogsNestedInput
    division?: DivisionUpdateOneWithoutLogsNestedInput
  }

  export type UpdateLogUncheckedUpdateWithoutEmployeeInput = {
    updateLogID?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    action?: EnumActionFieldUpdateOperationsInput | $Enums.Action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
    divisionID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UpdateLogUncheckedUpdateManyWithoutEmployeeInput = {
    updateLogID?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    action?: EnumActionFieldUpdateOperationsInput | $Enums.Action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facilityID?: StringFieldUpdateOperationsInput | string
    divisionID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactCreateManyServiceInput = {
    contactID?: string
    info: string
    type: $Enums.ContactType
    facilityID?: string | null
    divisionID?: string | null
  }

  export type ContactUpdateWithoutServiceInput = {
    contactID?: StringFieldUpdateOperationsInput | string
    info?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    facility?: FacilityUpdateOneWithoutContactsNestedInput
    division?: DivisionUpdateOneWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateWithoutServiceInput = {
    contactID?: StringFieldUpdateOperationsInput | string
    info?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    facilityID?: NullableStringFieldUpdateOperationsInput | string | null
    divisionID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactUncheckedUpdateManyWithoutServiceInput = {
    contactID?: StringFieldUpdateOperationsInput | string
    info?: StringFieldUpdateOperationsInput | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    facilityID?: NullableStringFieldUpdateOperationsInput | string | null
    divisionID?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}